---
title: "Operating Systems Notes"
read_time: false
excerpt: "Operating Systems Basics"
header:
  teaser: /assets/images/C_logo.png
  overlay_image: /assets/images/C_logo.png
  overlay_filter: 0.5 
toc: true
toc_label: "Contents"
toc_sticky: true
categories:
  - Notes
tags:
  - os
  - notes

---

# Lectures

## i4 ComSys, Wehrle (SoSe)

from [comsys website](https://www.comsys.rwth-aachen.de/teaching):
- Unix shell and programming language C
- Process management: processes, threads, inter-process communication
- CPU scheduling
- Process synchronization, deadlocks
- Memory management: virtual memory, segmentation, paging, fragmentation
- File system and I/O system
- Communication subsystem and sockets

from RWTH Online:
- Aufgaben und Struktur von Betriebssystemen
- Das Betriebssystem Unix
- Systemaufrufe und Shellprogrammierung
- Einführung in die Programmiersprache C
- Prozessverwaltung: Prozesse, Threads und Interprozesskommunikation
- Prozess-Synchronisation, Nebenläufigkeit und Deadlocks
- CPU-Scheduling
- Speicherverwaltung: Segmentierung, Paging, Fragmentierung, virtueller Speicher
- Stack- und Heap-Verwaltung, Garbage Collection
- Dateisystem und Rechteverwaltung
- I/O-System
- Verteilte Systeme
- Socket-Programmierung

## Power System Automation, Lankes

### 6SWS

Die Vorlesung vermittelt den Entwurf und den Aufbau von modernen Betriebssystemen. Hierzu wird zunächst der Aufbau von Rechnerarchitekturen analysiert und die Konsequenzen für die Systemsoftware gezogen.  Insbesondere werden Sicherheitsrisiken erläutert und wie die Systemsoftware den Nutzer vor Angriffen schützt. Neben Sicherheitsaspekten vermittelt die Vorlesung, welche Möglichkeiten zur Leistungssteigerung existieren und wie Optimierungsziele der Ressourcenverwaltung erreicht werden.

- Aufgaben und Struktur von Betriebssystemen
- Einführung in UNIX
- Programmierwerkzeuge
    - Verwaltung von Source Code
    - Einführung in dem Prozess des „Code Reviews“ und des automatisierten Testens
    - Rust vs. C/C++
- Systemnahe Programmierung
    - Prozessormodelle (insbesondere Intel 80x86)
    - Register- und Speichermodelle, Befehlsformate, Datentypen, Adressierungsarten
    - Instruktionslevelparallelität / Datenparalleliät
    - Mehrkern- und Mehrprozessor-Architekturen
        - Einführung in die nebenläufige Programmierung
        - Einführung in die Parallelisierung
        - Leistungsevaluation, Leistungsgrenzen (u.a. Amdahls Gesetz)
    - Funktionsaufrufe und ihre Konventionen
        - Sicherheitsrisiken, mögliche Angriffsszenarien („Exploits“) und existierende Schutztechniken
- Assembler und Assemblierung: Aufgaben, Funktionsweise
- Laden, Binden:
    - Statisches / dynamisches Binden, Laden mit / ohne Speicherverwaltung
    - Angriffsszenarien und existierende Schutztechniken
        - Adress Space Layout Randomization (ASLR)
- Entwurfsprinzipien
    - Monolithische Betriebssysteme
    - Microkernels (insbesondere seL4)
    - Unikernels / Library OS
    - Exokernels
    - Funktionale Sicherheit der Systemsoftware
        - z.B. durch die Verwendung einer sicheren, systemnahen Programmiersprache
- Betriebsmittel- und Prozessverwaltung
    - Aufgaben der Betriebsmittel- und Prozessverwaltung
    - Scheduling / Prozessplanung
    - Prozesssynchronisation
    - Verklemmungen
    - Interprozesskommunikation
- Unterbrechungen
    - Arten und Aufgaben von Unterbrechungen
    - Interruptsystem insbesondere des x86
    - Systemaufrufe
- Arbeitsspeicherverwaltung
    - Paging und Segmentierung
    - Demand Paging und Verdrängungsstrategien
    - Seitenkanalattacken am Beispiel von Meltdown
- Ein-/ Ausgabe
    - Memory-mapped I/O
    - Schichtung der E/A-Software
- Dateisysteme
    - Dateizugriff / Dateioperationen
    - Struktur und Schichtung
    - Journaling
- Isolierung von Systemkomponenten
    - Sandboxing
    - Betriebssystemvirtualisierung / Container
    - Virtuelle Maschinen

### 3SWS

- Modelle, Grundlagen und Konzepte von Betriebssystemen (Linux/UNIX, Windows; Beispielarchitektur: 80x86).
- Einleitung und Steuersprachen: Begriffsdefinitionen, Aufgaben und Struktur von Betriebssystemen, Steuersprachen und Shellprogrammierung (Bsp.: die Bourne-Shell), Programmierwerkzeuge.
- Betriebsmittel- und Prozessverwaltung: Aufgaben der Betriebsmittelverwaltung, Prozessverwaltung, Prozesssynchronisation, Verklemmungen.
- Unterbrechungen: Arten und Aufgaben von Unterbrechungen, das Interruptsystem der 80x86-Architektur.
- Arbeitsspeicherverwaltung: Grundlegende Strategien der Speicherverwaltung, Seitenadressierung, Seitenwechsel auf Abruf, Seitenverdrängungsstrategien, Segmentierung, Segmentierung/Seitenadressierung/Zugriffschutz in der 80x86-Architektur.
- Ein-/ Ausgabe: E/A in der 80x86-Architektur, Plattenspeicherverwaltung, Schichtung der E/A-Software.
- Dateisysteme: Definitionen, Dateizugriff, Dateioperationen, Struktur, Schichtung, Beispiel: Aufbau eines I-Node-basierten Dateisystems

# man pages

- see book appendix F.8 "Documentation"
- `man man` includes a list of all sections in the man pages
- `man -k some_keyword` to search man pages for `some_keyword`
- `man -s 6 --regex -k '.*'` to show the title of all manuals in section 6
- standard sections:
    - `RETURN VALUES` tells you what the function will return under success or failure
    - `ERRORS` tells what happens under failure
    - `SYNOPSIS`: 
        - what **arguments** to pass to a library call, 
        - what **header files** need to be included to use a library call
        - what **libraries you need to link with** to use the call
- look for the **definition of the structure** `timeval`:
    - using `grep`: use e.g. `grep 'struct timeval' /usr/include/sys/*.h` to look for the **definition of the structure** `timeval` in all files that end with `.h` in `/usr/include/sys`
    - using the compiler: `gcc -E main.c` (where `main.c` includes the header `time.h`) will produce a C file that has all of the needed structures and prototypes in it, including the definition of the `timeval` struct
- [What is in section 6 "Games"?](https://unix.stackexchange.com/a/487931)
    - see `ls /usr/games/`
- `man -a kill`: cycle through all of the different man pages named "kill"
    - `kill(2)` means `kill` in section 2

# Virtualization

## Processes

- process (abstraction) := a **running program**
- a typical system runs hundreds of processes at the same time

## Virtualizing the CPU

- **time sharing of the CPU**: the OS creates the **illusion that many CPUs exist** by running one process, stopping it and running another etc.
    - a resource (the CPU) is "divided **in time**" among the processes
    - allows users to run as many concurrent processes as they want
- drawback: if the CPUs are shared, each process will run more slowly
- **implementation** via ...
    - **mechanisms**
        - low-level methods or protocols that implement a needed piece of functionality
            - e.g. context switch ("stop one program and start another on a given CPU") (a "time-sharing mechanism")
    - **policies**
        - algorithms for making some kind of decision within the OS
            - e.g. scheduling policy ("decide which program the OS should run")
    - **separation of mechanisms and policies**
        - allows one to change mechanisms without having to change the policies and vice versa
        - a form of modularity

## Machine State of a process

- What constitutes a process?
- What parts of the machine matter to the program execution?
- **machine state**: what a program can read or update during its execution
    - components:
        - address space
            - instructions
            - data (which the program reads and writes)
        - registers
            - program counter (PC) aka instruction pointer (IP)
            - stack pointer
            - frame pointer
        - I/O information (e.g. list of the files the process currently has open)
- [address space, registers](https://www.quora.com/What-is-the-difference-between-registers-and-address-space)

## Process API (Overview)

- must be included in any interface of an OS:
    - create
    - destroy
    - wait
    - suspend a process
    - resume a process
    - get status information, e.g.
        - how long a process has run for
        - what state a process is in
- more details under [Process API](#process-api)

## Process Creation

1. loading of code and static data into address space
    - eagerly
    - lazily
2. allocate memory for the program's **stack** 
3. initialize the stack with arguments
    - fill in parameters to the `main()` function (i.e. the `argc` and `argv` arrays)
4. allocate some memory for the program's **heap**
5. initialization tasks related to I/O
    - UNIX default for each process: initialize three [file descriptors](#file-descriptors): stdin, stdout, stderr
6. start program at entry point `main()`
    - OS transfers control of the CPU to the newly-created process

## Process States

- Running
- Ready
- Blocked = "not ready to run until some event (e.g. I/O completion, reading from a disk, waiting for a packet from a network) takes place"

### Other states

- initial state
    - when process is being created
- final state (aka zombie state)
    - process exited, but has not been cleaned up
    - allows the **parent** that created the process to examine the **return code** of the child and then call `wait()` to clean up the child

### Scheduling

- scheduled = "moved from ready to running"
- descheduled = "moved from running to ready"
- OS scheduler = e.g. decides ...
    - to run process 2 while process 1 issued an I/O, 
    - not to switch back to process 1 when I/O is completed

## Data structures

- process list (aka task list)
- process control block (PCB)
    - register context (for context switches)

# Process API

# File Descriptors

- from [File Descriptor](https://en.wikipedia.org/wiki/File_descriptor):
    - On Linux, the set of file descriptors open in a process can be accessed under the path `/proc/PID/fd/`, where `PID` is the process identifier. File descriptor `/proc/PID/fd/0` is `stdin`, `/proc/PID/fd/1` is `stdout`, and `/proc/PID/fd/2` is `stderr`. As a shortcut to these, any running process can also access its own file descriptors through the folders `/proc/self/fd` and `/dev/fd`.
# UNIX System calls

## strace

- overview: [thegeekstuff](https://www.thegeekstuff.com/2011/11/strace-examples/):
- `strace some_command`: trace system calls and signals
- `strace ./avail_mem_malloc -l`: trace system calls and signals when running the command `./avail_mem_malloc -l` (source code of `./avail_mem_malloc -l` is in `/home/bra-ket/Desktop/Aachen/Uni/Basics_CS/OS/git/C_exercises/day_20_memory/avail_mem_malloc.c`)
- `strace -e mmap ./avail_mem_malloc -l`: filter a **specific** system call and/or signals, here: the `mmap` system call

## Related to Memory

- `mmap`, `munmap`: map or unmap files or devices into memory
- `brk`, `sbrk`: change data segment size

# Resource Limits

## setrlimit(), getrlimit()

- see [example setrlimit.c](https://github.com/pharath/C_exercises/blob/master/day_20_memory/setrlimit.c)
- see `man setrlimit`
    - **Trick**: to get `man` pages in color: 
        - install the `most` pager using `sudo apt-get install most`
        - in terminal set `export PAGER="most"`
        - to change `most` keybindings to vim keybindings `cp -iv /usr/share/doc/most/lesskeys.rc ~/.mostrc`

## ulimit

- get and set user limits
    - i.e. not for one process, but for one user!
- see `man ulimit`
- current user limits: `ulimit -a`

# Counting Processes

- see [how-to-count-the-number-of-processes-in-linux](https://coderscat.com/how-to-count-the-number-of-processes-in-linux/)
- `ps aux` 
    - `aux` are [BSD style flags](https://unix.stackexchange.com/a/106848)
        - a = show processes for all users
        - u = display the process's user/owner
        - x = also show processes not attached to a terminal

# Visualize Memory Usage

## smem

- see [How to visualize memory usage on Linux](https://www.xmodulo.com/visualize-memory-usage-linux.html)
- to fix the `NameError: name 'xrange' is not defined` edit `/bin/smem` and apply this [patch](https://bugs.debian.org/cgi-bin/bugreport.cgi?att=1;bug=958129;filename=smem-xrange-fix.patch;msg=5)

```bash
sudo apt install smem

# Pie chart
sudo python3 /bin/smem --pie name -c "pss" -U some_username

# Bar chart
sudo python3 /bin/smem --bar name -c "pss uss" -U some_username
```
