---
title: "C Notes"
read_time: false
excerpt: "For learning C. Content mostly from Bradley L. Jones, Peter Aitken - Sams Teach Yourself C in 21 Days -Sams (2002)."
header:
    teaser: /assets/images/C_logo.png
    overlay_image: /assets/images/C_logo.png
    overlay_filter: 0.5 
toc: true
toc_label: "Contents"
toc_sticky: true
categories:
    - Notes
tags:
    - c
    - notes

---

# Concepts

- [RWTH Grundgebiete der Informatik 1](https://online.rwth-aachen.de/RWTHonline/ee/ui/ca2/app/desktop/#/slc.tm.cp/student/courses/458361?$ctx=design=ca;lang=de&$scrollTo=toc_overview)
    - Gegenstand der Vorlesung ist die Einführung in Programmiertechniken, Datenstrukturen und Algorithmen anhand von C. 
    - Grundlegende Programmelemente: 
        - Skalare und zusammengesetzte Datentypen, Anweisungen, Kontrollfluß, Funktionen, Klassen, C-Programmstruktur und Programmierumgebung;
    - Programmanalyse: 
        - Wachstumsordnungen, Komplexitätsklassen, best/worst case Analyse; 
    - Lineare Datenstrukturen: 
        - Listen, Stacks, Queues, Iteration und Rekursion; 
    - Nichtlineare Datenstrukturen und Suchverfahren: 
        - Bäume, Graphen, Suchbäume, Hashtabellen; 
    - Algorithmenentwurf: 
        - Sortierverfahren, Heuristiken, Greedy-Algorithmen, grundlegende Optimierungsverfahren

# About C

- C is a **procedural** language, whereas C++ is an **object-oriented** language

# Documentation

- standard library
    - On Unix-like systems, the authoritative documentation of the actually implemented API is provided in the form of `man` pages. 
    - On most systems, man pages on standard library functions are in section 3 (e.g. `man 3 malloc`, `man 3 puts`, etc.) 
    - Section 7 may contain some more generic pages on underlying concepts (e.g. `man 7 math_error` in Linux).

# Build

## Source Code

- TODO

## Object Code

- With the help of an adequate **compiler**, for example GCC, your source code is translated into **object code**, first. 

## Binary files (ELF files)

- [What is an ELF file](https://linuxhint.com/understanding_elf_file_format/)
- Eventually, the **linker** translates the object code into a **binary file** that links the object code with the referenced **libraries**. 
- This binary file contains the single instructions as machine code that are understood by the CPU, and are executed as soon the compiled program is run.
- The binary file follows a specific **structure**, and one of the most common ones is named **ELF** that abbreviates **Executable and Linkable Format**. 
- ELF is widely used for 
    - executable files
    - relocatable object files
    - shared libraries
    - core dumps
- The specification does **not** clarify the **filename extension** for ELF files. In use is a variety of letter combinations, such as 
    - .axf, 
    - .bin, 
    - .elf, 
    - .o, 
    - .prx, 
    - .puff, 
    - .ko, 
    - .so, and 
    - .mod, 
    - or none.
- `man elf` gives you a handy summary about the structure of an ELF file

### ELF Header

- reading the ELF header:
    - `readelf -h elf_file`
        - read more about `readelf` in ([What is an ELF file](https://linuxhint.com/understanding_elf_file_format/))
    - `objdump -h elf_file`
- The ELF header is 32 bytes long, and identifies the format of the file. 
- It starts with a sequence of four unique bytes that are 0x7F followed by 0x45, 0x4c, and 0x46 which translates into the three letters E, L, and F. 
- Among other values, the header also indicates 
    - whether it is an ELF file for 32 or 64-bit format, 
    - uses little or big endianness, 
    - shows the ELF version 
    - as well as for which operating system the file was compiled for in order to interoperate with the right application binary interface (ABI) and cpu instruction set.

# Operator Precedence, Associativity

- When multiple operators of the same precedence level are used in an expression, they are evaluated according to their **associativity** ([source](https://www.programiz.com/cpp-programming/operators-precedence-associativity))

# Variables

## Initialization

see [Different ways to initialize a variable in C/C++](https://www.geeksforgeeks.org/different-ways-to-initialize-a-variable-in-c-c/)

## Global variables (aka External variables)

- external variable: a variable defined outside of any function
- scope: the scope is the entire source code file that contains the variable definition
- If you don't explicitly initialize an external variable when it's defined, the compiler initializes it to 0.
    - this is different than local variables!

### Best practice

- use them rarely
    - because usage violates the principle of **modular independence**
        - i.e each function should be self-contained/modular
- use them only when all or most of the program's functions need access to the variable 
- When a function uses an external variable, it is good programming practice to declare the variable within the function using the `extern` keyword (**C**: see [Storage-class specifiers](https://devdocs.io/c/language/storage_duration); **C++**: see [Storage-class specifiers](https://en.cppreference.com/w/c/language/storage_duration))

## Local variables

- aren't automatically initialized to 0 by the compiler
    - if not initialized they have an **undefined** or **garbage value**

## Static variables vs. Automatic variables

- local variables are **automatic** by default, i.e.
    - created anew each time the function is called
    - destroyed when execution leaves the function
        - thus doesn't retain its value between calls to the function in which it is defined.
- In order for a local variable to retain its value between function calls, it must be defined as **static** with the `static` keyword.
  ```c
  void print(int x)
  {
    static int lineCount;
    /* Additional code goes here */
  }
  ```
- (optional) if you want to, you can include the `auto` keyword in the definition
  ```c
  void func1(int y)
  {
    auto int count;
    /* Additional code goes here */
  }
  ```
- `static` and `auto` are **Storage-class specifiers** (see [below](#storage-duration))

### Storage Duration

From cppreference: [Storage duration](https://en.cppreference.com/w/c/language/storage_duration#Storage_duration)
- **Storage-class specifiers**: Specify *storage duration* (...) of objects and functions.
    - `auto` (automatic storage duration)
    - `register` (automatic storage duration)
    - `static` (static storage duration)
    - `extern` (static storage duration)
    - `_Thread_local` (thread storage duration)
- **Storage duration**: Every object has a property called *storage duration*, which limits the *object lifetime*. There are four kinds of storage duration in C:
    - **static**
        - The storage duration is the entire execution of the program
        - All objects declared static have this storage duration.
    - **automatic** 
        - The storage is allocated when the block in which the object was declared is entered and deallocated when it is exited by any means (goto, return, reaching the end).
        - All function parameters and non-static block-scope objects have this storage duration, as well as compound literals used at block scope.
    - **thread**
        - The storage duration is the entire execution of the thread in which it was created
    - **allocated**
        - The storage is allocated and deallocated on request, using **dynamic memory allocation** functions

# Int

- don't convert `int` to `float`
    - when an integer type is converted to a floating-point type, the resulting floating-point value might not exactly match the integer value (e.g. `2.999995` instead of `3`)
    - keep integer values in type `short`, `int`, `long`, or variables `long long`

## Low-order byte and High-order byte

From [stackoverflow](https://stackoverflow.com/questions/47117509/high-order-and-low-order-byte):
- In C, the size of an `int` is implementation defined, but is usually 2, or 4 bytes in size. The **high-order byte** would be the byte that contains the largest portion of the value. The **low-order byte** would be the byte that contains the smallest portion of the value. 
    - For example, if you have a 16-bit `int`, and the value is `5,243`, you'd write that **in hex** as `0x147B` (**phth**: 4 hex Stellen, weil 16-bit `int`). 
        - The high order byte is the `0x14` (**phth**: 1 byte = 8 bit, sodass 256 Werte möglich sind, was in hex **2 Ziffern** sind! Daher die `14` und nicht nur die `1` hinter dem `0x`.), and 
        - the low-order byte is the `0x7B`. 
    - A `char` is only 1 byte, so it is **always** contained within the lowest order byte. When written **in hex** (in left-to-right fashion) 
        - the low-order byte will always be the right-most 2 digits, and 
        - the high-order byte will be the left-most 2 digits (assuming they write all the bytes out, including leading 0s). 

# Arrays

## Definition

- **array**: a collection of data storage locations, each storing the same type of data and having the same name
- **array elements**: the storage locations of an array

## Declaration

- When you declare an array, the compiler **sets aside a block of memory large enough to hold the entire array**. 
- Individual array elements are stored in **sequential memory locations**.

## Initialization

- You can initialize **all or part of** an array when you first declare it
    - ANSI standard: the elements that are not initialized will be set to **zero**. 
        - however, it is best to make sure you know what a value is initialized to by setting it yourself.
- If you omit the array size, the compiler creates an array just large enough
- If you include too many initializers, the compiler detects an error.
    - **Note**: This is different from using subscripts which are out of bounds which will **not** be detected by the compiler!

## Subscripts

- the last element is **one less** than the number of elements in the array. 

## Passing arrays to a function

- **problem 1**: The only way you can pass an array to a function is by using a pointer to an array. (see [Passing Function arguments](#passing-function-arguments))
- **problem 2**: function that can handle arrays of different sizes (e.g. a function that finds the largest element in an array of integers)
    - How does the function know the size of the array whose address it was passed?
        - **method 1**: identify the last array element by storing a **special value** there (see [Strings](#strings))
        - **method 2**: Pass the function the array size as an argument

## Copy 2d array and assign it to another

From [stackoverflow](https://stackoverflow.com/questions/13903388/how-to-assign-values-of-array-to-another-arraymaking-copy-in-c):
```c
char arr[3][3] = { {'a','b','c'},{'d','e','f'},{'g','h','i'} };
char arr_copy[3][3];

memcpy(arr_copy, arr, sizeof arr_copy);
```

## Out of bounds error

- The C compiler doesn't recognize whether your program uses an array subscript that is out of bounds. 
- Your program compiles and links, but out-of-range subscripts generally produce erroneous results
    - from [source](https://stackoverflow.com/questions/9137157/no-out-of-bounds-error):
        - though, `clang` will do it for some cases if you pass `-fcatch-undefined-behavior` 
        - The `gcc` equivalent is `-fsanitize=undefined`. The `-ggdb` flag also helps; it causes compilation with extra debugging info, which can be the difference between having/not having line numbers pointing to the error in the code in `fsanitizer` output.
        - but this does not mean it is part of the C Standard!

## Best practice

- use `#define` statements to create constants that can be used when declaring arrays. Then you can easily change the number of elements in the array.
- do **not** use multidimensional arrays with **more than three** dimensions 

# Functions

## Best practice

- use `void foo(void);` to say "no parameters" in C, and it also works in C++. ([why this is important](https://stackoverflow.com/a/693794))

# Program Input/Output, Devices

- input
    - Data moved from an external location into RAM, where the program can access it
- output
    - Data sent to a location external to the program (common destinations: screen, printer, disk files)
- devices
    - collective term for input sources and output destinations

# Streams

- C carries out all input and output operations by means of streams
- **stream**: a sequence of bytes of data (e.g. a sequence of characters)
    - **input stream**: sequence of bytes flowing into a program
    - **output stream**: sequence of bytes flowing out of a program
- **advantage**: streams make input/output programming **device independent**
- **file**: every C stream is connected to a **file**, which is an intermediate step between the stream that your program deals with and the actual physical device being used for input or output
    - the details of interactions between streams, files, and devices are taken care of automatically by the C library functions and the operating system
- **2 modes of C streams**
    - **text stream**: consists only of characters (e.g. text data)
    - **binary stream**: consists of any sort of data

## Five Standard Streams

(the first 3 are C ANSI standard, the last 2 are only under Windows and DOS)

| Format Specifier | Type | Device |
| :---: | :---: | :---: |
stdin | Standard input | Keyboard
stdout | Standard output | Screen
stderr | Standard error | Screen
stdprn* | Standard printer | Printer (LPT1:)
stdaux* | Standard auxiliary | Serial port (COM1:)

# Stream Functions

- functions that deal with stream input and output

## Input Functions

- hierarchy of 3 levels
    - character input (`getchar`, `getch`, `getche`, `getc`, `fgetc`, `ungetc`)
    - line input (`gets`, `fgets`)
    - formatted input (`scanf`, `fflush`)

## Output Functions

- 3 categories
    - character output (`putchar`, `putc`, `fputc`)
    - line output (`puts`, `fputs`)
    - formatted output (`printf`, `fprintf`)

# printf

## Escape sequences

- see [Table of escape sequences](https://en.wikipedia.org/wiki/Escape_sequences_in_C#Table_of_escape_sequences)

## Format specifiers

| Format Specifier | Type |
| :---: | :---: |
`%c`	| Character
`%d`	| Signed integer
`%e` or `%E` |	Scientific notation of floats
`%f`	 | Float values
`%g` or `%G` |	Similar as `%e` or `%E`
`%hi` |	Signed integer (short)
`%hu` |	Unsigned Integer (short)
`%i` |	Unsigned integer
`%l` or `%ld` or `%li` |	Long
`%lf` |	Double
`%Lf` |	Long double
`%lu` |	Unsigned int or unsigned long
`%lli` or `%lld` |	Long long
`%llu` |	Unsigned long long
`%o` |	Octal representation
`%p` |	Pointer
`%s` |	String
`%u` |	Unsigned int
`%x` or `%X` |	Hexadecimal representation
`%n` |	Prints nothing
`%%` |	Prints `%` character

These are the basic format specifiers. We can add some other parts with the format specifiers. These are like below
- A minus symbol (`-`) sign tells left alignment
- A number after `%` specifies the minimum **field width**. If string is less than the width, it will be filled with spaces
- A period (`.`) is used to separate **field width** and **precision**

### Precision

From C99 §7.19.6.1:
- A `double` argument representing a floating-point number is converted to decimal notation in the style `[−]ddd.ddd`, where the number of digits after the decimal-point character is equal to the **precision** specification.
- If the precision is missing, it is taken as 6; if the precision is zero and the `#` flag is not specified, no decimal-point character appears. If a decimal-point character appears, at least one digit appears before it. 
- **The value is rounded to the appropriate number of digits**.

# scanf, gets, fgets

Read all characters up to the next newline character (`'\n'`, must use **single** quotes else it is a string literal).

## Control Characters

- **EOF**: If you're typing at the terminal and you want to provoke an end-of-file, use CTRL-D (unix-style systems) or CTRL-Z (Windows).

## scanf

- limitations:
    - `scanf()` cannot take strings with **spaces** in between characters as input, `gets()` and `fgets()` can

## gets

- prototype: `char *gets(char *str);`
- input stream is read from `stdin` until 
    - a newline (`'\n'`) or 
    - end-of-**file** (see [Control Characters](#control-characters)) is encountered 
- the newline (`'\n'`) is **replaced** with a null character (`'\0'`)
- return value: 
    - a pointer to the string (the same as `str`)
    - if `gets()` encounters an error or reads end-of-file: a null pointer
- the string is stored at the location indicated by `str`
- **important**: allocate sufficient memory space to store the string before calling `gets()`

## fgets

- prototype: `char *fgets(char *str, int n, FILE *fp);`
    - `FILE *fp` is used to specify the input stream (e.g. `stdin`)
    - `str` indicates where the input string is stored 
    - `n` specifies the maximum number of characters to be input
- input stream is read until 
    - a newline (`'\n'`) or 
    - end-of-line is encountered or 
    - `n - 1` characters have been read
- the newline (`'\n'`) is **included** in the string (different from `gets()`!) and a `'\0'` is appended before it is stored (i.e. strings are stored with trailing `'\n\0'`)
- the return values are the same as for `gets()`
- the string is stored at the location indicated by `str`

# Char

- use **single quotations** when initializing a variable
- char constants:
    - literal:
        - enclose a single character in **single quotation marks**
          ```c
          char code = 'x';
          ```
    - symbolic:
        - using `#define`
          ```c
          #define EX 'x'
          char code = EX; /* Sets code equal to 'x' */
          ```
        - using `const`
          ```c
          const char A = 'Z';
          ```
- When you store the character `a` in a type `char` variable, the compiler is really storing the ASCII value `97` 
- if you want to print the extended ASCII (aka CP437) characters, you must use an `unsigned char` 
    - not good practice, use UTF-8 instead (see [mapping from extended ASCII to UTF-8](https://en.wikipedia.org/wiki/Code_page_437#Character_set))

# Strings

## Definitions

- a string is a sequence of characters delineated by 
    - a pointer that points to the string's first character and 
    - a null character `\0` that indicates the end of the string ("null-terminated" string)
- From [C18 6.4.5](https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf):
    - A **character string literal** is a sequence of zero or more multibyte characters enclosed in double-quotes, as in `"xyz"`. 
    - A **UTF–8 string literal** is the same, except prefixed by `u8`. 
    - A **wide string literal** is the same, except prefixed by the letter `L`,`u`, or `U`.

## String Literals

String Literals sind "besondere" `char` arrays, die im read-only memory sein **können**, aber nicht müssen (abhängig von C implementation). Nach ISO C dürfen sie nicht modifiziert werden!

From [cppreference](https://en.cppreference.com/w/c/language/string_literal):  
- **character string literal**: The type of the literal is `char[N]`, where `N` is the size of the string in code units of the execution narrow encoding, including the null terminator.  
- A string literal is not necessarily a string; if a string literal has embedded null characters, it represents an array which contains more than one string:
  ```c
  char* p = "abc\0def"; // strlen(p) == 3, but the array has size 8
  ```
- String literals are **not modifiable** (and in fact may be placed in read-only memory such as `.rodata`). If a program attempts to modify the static array formed by a string literal, the behavior is undefined.
  ```c
  char* p = "Hello";
  p[1] = 'M'; // Undefined behavior
  char a[] = "Hello";
  a[1] = 'M'; // OK: a is not a string literal
  ```
  **phth note**: The latter variant is treated as
  ```c
  char a[] = { 'H', 'e', 'l', 'l', 'o', '\0'};
  a[1] = 'M'; // OK: a is not a string literal
  ```
  thus, `char a[] = "Hello";` **copies** each `char` byte of the string literal `"Hello"` into the **newly created** memory block of the array `a`, but the memory block storing `"Hello"`is **not** modified! `a` is a standard array, thus, like all standard arrays, it is modifiable. `a` points to **the array's** first element `'H'` and **not** to the string literal `"Hello"`'s first element!
    - from [cppreference](https://en.cppreference.com/w/c/language/array_initialization):
        - Successive bytes of the string literal (...), including the terminating null byte/character, initialize the elements of the array

Notes:
- phth: `.rodata` is the "[read-only data segment](https://en.wikipedia.org/wiki/Data_segment)", a portion of an object file or the corresponding address space of a program that contains static constants.
- phth: "may be placed in read-only memory" means they do not have to!

From the [C89 Rationale, 3.1.4 String literals](http://port70.net/~nsz/c/c89/rationale/c1.html#3-1-4):
- String literals are specified to be **unmodifiable**. 
- This specification allows implementations (phth: z.B. `gcc`, `clang`, etc)
    - to share copies of strings with identical text, 
    - to place string literals **in read-only memory**, and 
        - d.h. ob string literals in read-only memory sind oder nicht ist abhängig von der implementation
    - perform certain optimizations. 
- However, string literals **do not** have the type array of `const char`, 
    - in order to avoid the problems of pointer type checking, particularly with library functions, since assigning a pointer-to-`const char` to a plain pointer-to-`char` is not valid. 
- Those members of the Committee who insisted that string literals should be modifiable were content to have this practice designated a common extension (see F.5.5).

### FAQ - string literals

Good example code:
- see first two answers in [If char\*s are read only, why can I overwrite them?](https://stackoverflow.com/questions/44294649/if-chars-are-read-only-why-can-i-overwrite-them)
    - explains: [char \*str and char str\[\] are not the same](https://stackoverflow.com/questions/3843446/static-c-string-allocation-question)
    - **Warning**: [this stackoverflow answer](https://stackoverflow.com/a/62279000) is wrong! 
        - proof: see below: comment by [RobertS supports Monica Cellio](https://stackoverflow.com/users/12139179/roberts-supports-monica-cellio), 13949 reputation: "'Short answer: they are basically the same.' - No, they aren't. Both methods are completely different."
    - the same from a compiler perspective: [Why string is not modifiable in new compilers](https://stackoverflow.com/questions/17337825/why-string-is-not-modifiable-in-new-compilers)

## Create Strings as char arrays

element-by-element:
```c
char string[10] = { 'A', 'l', 'a', 'b', 'a', 'm', 'a', '\0' };
```

using string literal:
```c
char string[10] = "Alabama";
char message[] = "Great Caesar\'s Ghost!";
```
- use **double quotes**
- The array's name is a type `char` pointer to the beginning of the string
- the compiler calculates the size of the array for you, if no subscript is provided
    - **Note**: The expression within the brackets `[]` is referred to as a **subscript**
- the compiler **automatically** adds the terminating null character at the end of the string

## Create Strings without arrays

### Allocate string space at compilation

**static memory allocation**: explicitly allocating memory in the program source code by declaring variables, structures, and arrays
```c
char *message = "Great Caesar\'s Ghost!";
```
~~i.e. `*message` and `message[]` are equivalent!~~
- wrong: [why they are different](https://stackoverflow.com/questions/3843446/static-c-string-allocation-question)

**Note**:
- The pointer `*message` itself is stored at a different location than the literal string `"Great Caesar\'s Ghost!"` (see section [Pointer](#pointer)).
- The array's name is a type `char` pointer to the beginning of the string

### Allocate string space at runtime (malloc)

**dynamic memory allocation**:
```c
#include <stdlib.h>
#include <stdio.h>
int main( void )
{
    /* allocate memory for a 100-character string */
    char *str;
    str = (char *) malloc(100 * sizeof(char));
    if (str == NULL)
    {
        printf( "Not enough memory to allocate buffer\n");
        exit(1);
    }
    printf( "String was allocated!\n" );
    return 0;
}
```
Note that `void *malloc()` is typecast so that its return value is the proper type - a pointer to a `char` variable. Further details about `malloc()` are under section [Memory](#memory).

# Pointer

- The address of a variable is actually the address of the first (lowest) byte it occupies
- Each pointer is equal to the address of the first byte of the pointed-to variable

## Size of pointers

- The size of a pointer in C/C++ depends upon different issues like Operating system, CPU architecture etc. 
- Usually it depends upon the **word size of underlying processor**, for example
    - for a **32 bit computer** the pointer size can be **4 bytes** 
    - for a **64 bit computer** the pointer size can be **8 bytes**. 
- So, **for a specific architecture** pointer size **will be fixed**.
- It is **common to all data types** like `int *`, `float *` etc.

## Data type of pointers 

From [stackoverflow](https://stackoverflow.com/a/26976670):
- But really, what is a type? The gist of it is that a type is a way to determine how data in memory is supposed to be interpreted. A variable of the type `char` represents a character. A variable of the type `int` represents an integer. Same applies to pointers: `char *x` is not of the type `char`, it's of the type `char *` (pointer to `char`). This means that `char *x` itself is a location in memory we can use to read one or more `char` values.
- TL;TR: Yes, a pointer is a data type (`void *` in its purest form). The pure form is quite unusable (because you can't dereference it). Instead of having to cast the pointer every time you decide to use it, C offers the convenience of derived pointer types (like `char *`, `int *` and so on). But really, they're pointers, and therefore a data-type in their own right.

## Where is a pointer stored?

- a pointer can be stored **anywhere** in the process' **virtual memory** (aka address space) which is typically organized in **6 sections**:
    - environment section - used to store environment variables and command line arguments; 
    - the stack, used to store memory for function arguments, return values, and **automatic** variables; 
    - the heap (free store) used for dynamic allocation, 
    - data section for uninitialized **static** and global variables 
    - data section for initialized **static** and global variables 
    - a text section where the actual code is kept
- **more precisely**: from [cprogramming.com](https://www.cprogramming.com/tutorial/virtual_memory_and_heaps.html):
    - The size of the **virtual memory** is the maximum size of the maximum size your computer can address using **pointers** (usually on a 32-bit processor each process can address 4 GB of memory). 
    - Typically, in each process, the virtual memory available to that process is called its **address space**.
    - Even though every application has its own 4 GB (on 32-bit systems) of virtual memory, that does not necessarily mean that your program can actually use all of that memory. 
        - On **Windows**, the upper 2 GB of that memory are allocated to the operating system kernel, and are unavailable to the process. 
            - (Therefore, any pointer starting with 0x8xxxxxxx is unavailable in user space.) 
        - On **Linux**, the upper 1 GB is kernel address space
- [stackoverflow](https://stackoverflow.com/a/24381621):
    - a pointer can be created in any of these [storage classes](https://devdocs.io/c/language/storage_duration); and objects being pointed to can also be in any of these storage classes
    - Roughly, `dynamic` corresponds to "heap", and `automatic` corresponds to "stack".
        - e.g. `malloc()` dynamically allocates memory from the heap

## void pointer

### In C++

[source](https://www.learncpp.com/cpp-tutorial/void-pointers/)

A void pointer can point to objects of any data type:
```cpp
int nValue;
float fValue;

struct Something
{
    int n;
    float f;
};

Something sValue;

void* ptr;
ptr = &nValue; // valid
ptr = &fValue; // valid
ptr = &sValue; // valid
```
However, because the void pointer does not know what type of object it is pointing to, dereferencing a void pointer is illegal. Instead, the void pointer must first be cast to another pointer type before the dereference can be performed.
```cpp
int value{ 5 };
void* voidPtr{ &value };

// std::cout << *voidPtr << '\n'; // illegal: dereference of void pointer

int* intPtr{ static_cast<int*>(voidPtr) }; // however, if we cast our void pointer to an int pointer...

std::cout << *intPtr << '\n'; // then we can dereference the result
```

## NULL pointer

Definition:
```cpp
#define NULL ( (void *) 0)
```

**C11 standard** definition: 
- An integer constant expression with the value `0`, or such an expression cast to type `void *`, is called a **null pointer constant**.
- If a null pointer constant is converted to a pointer type, the resulting pointer, called a **null pointer**, is guaranteed to compare unequal to a pointer to any object or function.

### Usage

1. To initialize a pointer variable when that pointer variable hasn't been assigned any valid memory address yet. 
```c
int * pInt = NULL;
```
2. To check for a null pointer before accessing any pointer variable. By doing so, we can perform error handling in pointer related code, e.g., dereference a pointer variable only if it's not `NULL`. 
```c
if(pInt != NULL) /* We could use if(pInt) as well */
{ 
    /* Some code */ 
}
else
{ 
    /* Some code */ 
}
```
3. To pass a null pointer to a function argument when we don't want to pass any valid memory address.
```c
int fun(int *ptr)
{
    /*Fun specific stuff is done with ptr here*/
    return 10;
}
fun(NULL);
```

### Difference between a void pointer and a NULL pointer?

From [stackoverflow](https://stackoverflow.com/a/4116332):

In C, there is `void`, `void` pointer and `NULL` pointer.
- `void` is absence of type. I.E. a function returning a `void` type is a function that returns nothing.
- `void` pointer: is a pointer to a memory location whose type can be anything: a structure, an int, a float, you name it.
- A `NULL` pointer is a pointer to location `0x00`, that is, no location. Pointing to nothing.

Examples:

`void` function:
```cpp
void printHello()
{
   printf("Hello");
}
```
`void` pointer:
```cpp
void *malloc(size_t si)
{
    // malloc is a function that could return a pointer to anything
}
```
`NULL` pointer:
```cpp
char *s = NULL;
// s pointer points to nowhere (nothing)
```

## Pointer arithmetic

If you have a pointer `ptr` that points to a data object of type `obj`,
```c
ptr++
```
has the same effect as
```c
ptr += sizeof(obj);
```

## Address of a pointer / multiple indirection

- **multiple indirection**: You can use the address-of operator to find the address of a pointer, so you can have **pointers to pointers**.
    - The most common use involves **arrays of pointers**.
        - The most common use of an array of pointers is with **strings**.

## Passing Function arguments

Using "passing by reference" (coll.) we can overcome two limitations of functions: 
- Arguments are passed by value, and 
- the return statement can return only one value

# Structs

## 3 ways to access a structure member

- Using the structure name
- Using a pointer to the structure with the indirection operator (`*`)
- Using a pointer to the structure with the indirect membership operator (`->`)
    - sometimes called "structure pointer operator"

Therefore, if `p_str` is a pointer to the structure `str`,
```c
str.memb
(*p_str).memb
p_str->memb
```
are equivalent.

## typedef

Whether you use `typedef` or a structure tag to declare structures makes little difference
```c
typedef struct {
    int x;
    int y;
} coord;
```
or using a structure tag
```c
struct coord {
    int x;
    int y;
};
```

# Type Conversions

## Type Promotion (implicit conversion, automatic conversion)

If the components of an expression have different types, an expression has the same type as its **most comprehensive component**. From least-comprehensive to most-comprehensive, the numerical data types are
- char
- short
- int
- long
- long long
- float
- double
- long double

**Note**: Promotion means that a copy of the variable is created and used in the expression evaluation. The type of the variable is **not** changed!

**Promotion by Assignment**: expression on the right side of an assignment statement is always promoted to the type of the data object on the left side of the assignment operator
- may cause **demotion** 
    - e.g. `float` to `int` (**Caution**: fractional part is lost!)

## Cast / Typecast (explicit conversion)

- e.g. `(float)i` when `i` is an integer
- can be performed on **arithmetic expressions** and **pointers**
- makes an internal **copy** of the variable using the new type (similar to promotion)
- most common use: `f1 = (float)i1/i2;` to avoid using the fractional part in an integer division
    - casting one of the `int` variables is sufficient
- casting **pointers**:
    - Before you can use a `void` pointer, you **must cast** it to the proper type 
    - **don't** need to cast **any** pointer
        - in order to assign a value to it
        - to compare it with `NULL`
    - **must** cast a pointer
        - before dereferencing
        - before performing pointer arithmetic with it

# Memory

## Monitoring of memory

Read [How do I see how much free ram I really have?](https://www.linuxatemyram.com/#when-should-i-start-to-worry) first! Also read section "When should I start to worry?"!
```bash
watch free -m
```

### Bad signs

```bash
dmesg -T | grep oom-killer
# same as
dmesg --ctime | grep oom-killer
```
should not show any output! If it does, it is a bad sign!
- the `-T` (same as `--ctime`) flag is used to print human-readable timestamps 
    - Be aware that the timestamp could be inaccurate! (see `man dmesg`)

## Areas of memory

When a program begins the operating system sets up following areas of memory (depending on the requirements of the compiler):
- registers,
- code space,
- stack,
- global namespace, and
- free store (heap)

### Registers

- area of memory built right into the CPU
- important registers:
    - instruction pointer
        - set of registers responsible for pointing, at any given moment, to the next line of code
    - stack pointer (see [section "stack"](#stack))
    - frame pointer (see [section "stack"](#stack))

### Code space

- memory set aside to hold the binary form of the instructions you created in your program

### Stack

- area of memory allocated for your program to hold the data required by each of the functions in your program
- last-in, first-out
    - data is **pushed** onto the stack and **popped** off the stack
- `setrlimit()`: use `RLIMIT_STACK` [resource limit]({% post_url 2022-09-22-notes-OS %}#resource-limits) to limit the stack size
    - If you exceed the `RLIMIT_STACK` limit (call stack too deep, or allocate too many variables on the stack), your program will receive a `SIGSEGV`.
- stack pointer
    - analogy: series of cubbyholes
        - **the top of the stack**: whatever cubby the stack pointer (which is another register) happens to be pointing to
        - **sequential address**: Each of the cubbies has a sequential address
        - one of those sequential addresses is kept in the stack pointer register (i.e. the top of the stack)
        - Everything **below that magic address**, known as the top of the stack, is considered to be **on the stack**. 
        - Everything **above the top of the stack** is considered to be **off the stack and invalid**.
    - when data is popped off the stack the stack pointer is moved down the stack
        - the data above the stack pointer is called **garbage** and is **not reliable** (it might or might not be changed at any time!)

#### Function Calls: Stack Pointer (ESP) and Frame Pointer (EBP)

[source](https://www.uninformativ.de/blog/postings/2011-04-02/0/POSTING-de.html)

Der Knackpunkt ist das Register **ESP** (SP = **Stack Pointer**). Dieses enthält die Speicheradresse, die auf das letzte Element auf dem Stack zeigt.

(...), aber schöner wäre es, wenn ich mir irgendwo diejenige Speicheradresse merken könnte, die den "Anfang" des Stacks kennzeichnet.

Das ist die Idee des "**Frame Pointers**" oder "Base Pointers". Dafür wird normalerweise das Register **EBP** (BP = Base Pointer) verwendet. Ich muss mich allerdings selbst darum kümmern. Die gängige Vorgehensweise ist, beim Betritt einer "Funktion" 
- den alten Wert von EBP auf dem Stack zu speichern und dann 
- den aktuellen Wert von ESP nach EBP zu kopieren. 
- Danach kann ich ESP "beliebig" verändern und habe dennoch mit EBP immer einen festen Referenzpunkt.

Verlasse ich die Funktion wieder, muss ich natürlich aufräumen. Dies erreicht man, indem man 
- EBP zurück nach ESP kopiert und dann 
- den ehemals gespeicherten EBP-Wert vom Stack zurück nach EBP holt.

Genaueres weiter unten in [source](https://www.uninformativ.de/blog/postings/2011-04-02/0/POSTING-de.html) ab "Richtig interessant wird der Frame Pointer, wenn man Funktionen aufrufen möchte. (...)".

Other references:
- [What are the ESP and the EBP registers?](https://stackoverflow.com/questions/21718397/what-are-the-esp-and-the-ebp-registers)

Definitions (from [cs.rutgers.edu](https://people.cs.rutgers.edu/~pxk/419/notes/frames.html)):
- **stack frame**: Each **function** has local memory associated with it to hold incoming parameters, local variables, and (in some cases) temporary variables. This region of memory is called a **stack frame** and is allocated on the process' stack. 
- **frame pointer**: A **frame pointer** (the **ebp register** on intel x86 architectures, **rbp** on 64-bit architectures) contains the base address of the function's frame. The code to access local variables within a function is generated in terms of offsets to the frame pointer. 
    - **Note**: The **stack pointer** (the **esp register** on intel x86 architectures or **rsp** on 64-bit architectures) may change during the execution of a function as values are pushed or popped off the stack (such as pushing parameters in preparation to calling another function). The frame pointer doesn't change throughout the function.

#### Stack Overflow

[Wikipedia](https://en.wikipedia.org/wiki/Stack_overflow):
- A stack overflow occurs if the **call stack pointer** (ESP, see above) exceeds the stack bound.  

**Causes**:

**Infinite recursion** (most common cause of stack overflows):
```bash
int foo() 
{
    return foo();
}
```
- space needed to store the variables and information associated with each call
- `foo()` invokes itself until the stack overflows resulting in a [segmentation fault](#segmentation-fault) (`SIGSEGV` in UNIX, `STATUS_ACCESS_VIOLATION` exception in Windows)

**Very Deep Recursion**:
- a recursive function that terminates in theory but causes a call stack buffer overflow in practice
    - fix by transforming the recursion into a loop

**Very large stack variables**:
- attempt to allocate more memory on the stack than will fit, e.g. by creating local array variables that are too large
```c
int foo() 
{
     double x[1048576];
}
```

### Global namespace

- global variables

### Free store (Heap)

- read: [virtual memory vs. heap](https://www.cprogramming.com/tutorial/virtual_memory_and_heaps.html)
- **in C++**: You allocate memory on the free store in C++ by using the `new` keyword.

#### Limiting the heap size

**Method 1**: In the source code:
- `setrlimit()`: use `RLIMIT_DATA` [resource limit]({% post_url 2022-09-22-notes-OS %}#resource-limits) to limit the **data segment** (i.e. initialized data, uninitialized data, and **heap**)
    -  If you try to extend the **data segment** past the `RLIMIT_DATA` limit (e.g. using `brk`, `sbrk` or some intermediary like `malloc`), the attempt will fail. `brk` or `sbrk` will return `< 0` and `malloc` will return a null pointer.
- **Note** on `malloc`: 
    - usually `malloc` allocates memory from the **heap** (calling `sbrk()` to adjust heap size, if necessary):
        > [malloc doc](https://man7.org/linux/man-pages/man3/malloc.3.html): Normally, `malloc()` allocates memory from the heap, and adjusts the size of the heap as required, using `sbrk(2)`.
    - **only if** memory blocks larger than `MMAP_THRESHOLD` are allocated, `malloc` will use the `mmap()` system call (which creates mappings in **virtual memory**):
        > [malloc doc](https://man7.org/linux/man-pages/man3/malloc.3.html): When allocating blocks of memory larger than `MMAP_THRESHOLD` bytes, the glibc `malloc()` implementation allocates the memory as a private anonymous mapping using `mmap(2)`.
    - in order to limit the available memory for `malloc` use `RLIMIT_DATA`:
        > [malloc doc](https://man7.org/linux/man-pages/man3/malloc.3.html): Prior to Linux 4.7 allocations performed using `mmap(2)` were unaffected by the `RLIMIT_DATA` resource limit; since Linux 4.7, this limit is also enforced for allocations performed using `mmap(2)`.

**Method 2**: In the `bash` session, where the program will be executed:
- use `ulimit -Sd kiloBytes` to limit the program's data segment! (Note: `kiloBytes` must be sufficiently large, i.e. approx. $\gt 3000$ kiloBytes!)
- use `ulimit -Sv kiloBytes` to limit the program's virtual memory (address space)! (Note: `kiloBytes` must be sufficiently large, i.e. approx. $\gt 3000$ kiloBytes!)
    - limiting the entire virtual memory also limits the heap!

## RAM available for allocation

When you run a C program, the program is loaded from disk into the computer's memory. The memory space the program occupies includes the **program code**, as well as space for all the program's **static data** - that is, data items that are declared in the source code. **The memory left over is what's available for allocation.** 

## Static vs. Dynamic Memory Allocation

[source](https://techdifferences.com/difference-between-static-and-dynamic-memory-allocation.html)

### Static Memory Allocation

- Static memory allocation is a technique where the computer assigns memory to the program **during its compilation**. 
- Memory once assigned **cannot vary in size**, i.e. you can not increase or decrease the allocated memory size.
- Once assigned to the program, the static memory remains throughout the program, i.e. from the moment the program is compiled upto the moment the program completes its execution. After the program executes completely, the memory is deallocated, and it can be allocated to some other entity. 
- This technique allocates the memory to the program **from the stack** storage.
- In static memory allocation, the program **executes faster** because the memory is assigned to the program before its execution. 
    - But it is quite difficult to determine how much memory would be required to run the program, and hence most of the time, memory allocation decisions are to be taken at the run time (see [Dynamic Memory Allocation](#dynamic-memory-allocation)).

### Dynamic Memory Allocation

- In dynamic memory allocation, the memory is allocated **at the run time**, i.e. when the programmer executes the program 
- this technique assigns the memory **from the heap** storage.
- The memory allocated dynamically can be deallocated at any moment during the program execution. 
- Even the memory allocated **can be resized**, i.e. you can increase or decrease the memory size. 
    - This method is more efficient as it provides the memory space according to the program's needs.
- As the memory is allocated at the run time, this makes an **execution a little slower** when compared to static memory allocation. 
- The functions used to allocate and deallocate the memory dynamically are `calloc()`, `realloc()`, and `free()`.

## Allocation Functions

- all allocation functions return a type `void` pointer 
    - a type `void` pointer must be cast to the appropriate type before being used (see section "Cast")
- When a memory allocation function is called, you **must check its return value** to ensure that the memory was allocated successfully.
- In addition, your programs must be able to **gracefully handle the situation when a memory allocation request fails**

### malloc (stdlib.h)

- allocates a group of bytes
- prototype: `void *malloc(size_t num);` 
- returns a pointer to the first byte
- returns `NULL` 
    - if the requested storage space couldn't be allocated or 
    - if `num == 0`.

### calloc (stdlib.h)

- allocates a group of objects
- prototype: `void *calloc(size_t num, size_t size);`
- returns a pointer to the first byte
- clears all the allocated memory (set to `0`)
- returns `NULL` 
    - if the requested storage space couldn't be allocated or 
    - if `num == 0`.
    - if `size == 0`.

### realloc (stdlib.h)

- changes the size of a block of memory that was previously allocated with or `calloc()`, `malloc()`
- prototype: `void *realloc(void *ptr, size_t size);`
- expand block:
    - if sufficient space exists: expand **old** block, return `ptr`
    - if sufficient space **does not** exist: allocate a **new** block, copy data to **new** block, free **old** block, return a pointer to the new block
- if `ptr == NULL`: like `malloc()`
- if `size == 0`: `free(ptr)`
- if memory is insufficient: leave **old** block unchanged
- returns `NULL` 
    - if memory is insufficient (either for expanding the **old** block or for allocating a **new** one)
    - if `size == 0`.

## Deallocation

### free (stdlib.h)

- releases the memory pointed to by `ptr`
- prototype: `void free(void *ptr);`
- must have been allocated with `malloc()`, `calloc()`, or `realloc()`
- If `ptr` is `NULL`, `free()` does nothing

### realloc (stdlib.h)

- If the argument size is `0`, the memory that `ptr` points to is freed, and the function returns `NULL`.

## Manipulation

- `void *memset(void *dest, int c, size_t count);`
    - while `c` is a type `int`, it is treated as a type `char`. 
    - `count` is the number of bytes, starting at `dest`, to be set
    - set all the bytes in a block of memory to a particular value
    - you can specify values of `c` only in the range `0` through `255`
        - therefore, 
            - **do** use `memset` to initialize an array of type `char`, 
            - **do not** use `memset` to initialize arrays of type `int`, `float` or `double`, 
                - you **can** initialize these arrays' elements to `0`, though
- `void *memcpy(void *dest, void *src, size_t count);`
    - copies bytes of data between memory blocks, sometimes called **buffers**
    - successive byte-for-byte copy
    - The return value is `dest`
    - **Problem**: If the two blocks of memory overlap, the function might not operate properly: some of the data in `src` might be overwritten before being copied. Use `memmove()` instead. You rarely, have a reason to use `memcpy()`.
- `void *memmove(void *dest, void *src, size_t count);`
    - like `memcpy()`, copying a specified number of bytes from one memory block to another, but **can** handle overlapping memory blocks properly

## Heap Overflow

from [Wikipedia](https://en.wikipedia.org/wiki/Heap_overflow):
- An accidental overflow may result in data corruption or unexpected behavior by any process that accesses the affected memory area. 
    - On operating systems **without** memory protection, this could be any process on the system.

### Exploitation, Vulnerability

from [Wikipedia](https://en.wikipedia.org/wiki/Heap_overflow):
- Memory on the heap is dynamically allocated at runtime and typically **contains program data**. 
- Exploitation is performed by corrupting this data in specific ways to cause the application to overwrite internal structures such as **linked list pointers**. 
- The canonical **heap overflow technique** overwrites dynamic memory allocation linkage (such as `malloc` metadata) and uses the resulting pointer exchange to overwrite a program function pointer.
- **iOS jailbreaking** often uses heap overflows to gain arbitrary code execution. 
- **UAF**: see [Use-After-Free Vulnerability](https://encyclopedia.kaspersky.com/glossary/use-after-free/)

## Segmentation Fault

- [from Wikipedia](https://en.wikipedia.org/wiki/Segmentation_fault): 
    - On standard x86 computers, this is a form of **general protection fault**. 
    - The **operating system kernel** will, in response, usually perform some **corrective action**, generally passing the fault on to the offending process by sending the process a signal. 
    - Processes can in some cases install **a custom signal handler**, allowing them to recover on their own, but otherwise **the OS default signal handler** is used, generally causing **abnormal termination** of the process (a **program crash**), and sometimes a **core dump**.
- [from stackoverflow](https://stackoverflow.com/a/14367598):
    - Segmentation faults don't directly have anything to do with the heap. The term segmentation fault comes from older operating systems (Unix-style) that used "segments" of memory for different usages, and "Segmentation fault" was when the program went outside it's allocated segment. In modern systems, the memory is split into "pages" - typically 4KB each, but some processors have larger pages, and many modern processors support "large pages" of, for examble, 2MB or 1GB, which is used for large chunks of memory.
    - Now, if you use an address that points to a page that isn't there (or isn't "yours"), you get a segmentation fault. This, typically will end the application then and there. You can "trap" segmentation fault, but in all operating systems I'm aware of, it's not valid to try to continue from this "trap" - but you could for example store away some files to explain what happened and help troubleshoot the problem later, etc. 

# Linked List

- method of **data storage**
- types of linked lists (each type is suited for certain types of data storage)
    - single-linked list
    - double-linked list
    - binary tree

## Array vs Linked List

from [thegeekstuff](https://www.thegeekstuff.com/2012/08/c-linked-list-example/):
- a linked list is a **dynamic** data structure whose length can be increased or decreased **at run time**, whereas an array is a **static** data structure, i.e. the length of array **cannot** be altered at run time.
- In an array, all the elements are kept at **consecutive** memory locations, whereas in a linked list the elements (or nodes) may be kept at **any** location but still connected to each other.

## Single-linked list

- **last element/node**: has a pointer `next` being assigned the value of `NULL` 
- **head pointer**:
    - always points to the first element/node
    - if the entire list is empty (contains no links), the head pointer is set to `NULL`
