---
title: "C Notes"
read_time: false
excerpt: "For learning C"
header:
    teaser: /assets/images/C_logo.png
    overlay_image: /assets/images/C_logo.png
    overlay_filter: 0.5 
toc: true
toc_label: "Contents"
toc_sticky: true
categories:
    - Notes
tags:
    - c
    - notes

---

# Concepts

- [RWTH Grundgebiete der Informatik 1](https://online.rwth-aachen.de/RWTHonline/ee/ui/ca2/app/desktop/#/slc.tm.cp/student/courses/458361?$ctx=design=ca;lang=de&$scrollTo=toc_overview)
    - Gegenstand der Vorlesung ist die Einführung in Programmiertechniken, Datenstrukturen und Algorithmen anhand von C. 
    - Grundlegende Programmelemente: 
        - Skalare und zusammengesetzte Datentypen, Anweisungen, Kontrollfluß, Funktionen, Klassen, C-Programmstruktur und Programmierumgebung;
    - Programmanalyse: 
        - Wachstumsordnungen, Komplexitätsklassen, best/worst case Analyse; 
    - Lineare Datenstrukturen: 
        - Listen, Stacks, Queues, Iteration und Rekursion; 
    - Nichtlineare Datenstrukturen und Suchverfahren: 
        - Bäume, Graphen, Suchbäume, Hashtabellen; 
    - Algorithmenentwurf: 
        - Sortierverfahren, Heuristiken, Greedy-Algorithmen, grundlegende Optimierungsverfahren

# Documentation

- On Unix-like systems, the authoritative documentation of the actually implemented API is provided in the form of man pages. 
- On most systems, man pages on standard library functions are in section 3 (e.g. `man 3 malloc`, `man 3 puts`, etc.) 
- Section 7 may contain some more generic pages on underlying concepts (e.g. `man 7 math_error` in Linux).

# Build

## Source Code

- TODO

## Object Code

- With the help of an adequate **compiler**, for example GCC, your source code is translated into **object code**, first. 

## Binary files (ELF files)

- [What is an ELF file](https://linuxhint.com/understanding_elf_file_format/)
- Eventually, the **linker** translates the object code into a **binary file** that links the object code with the referenced **libraries**. 
- This binary file contains the single instructions as machine code that are understood by the CPU, and are executed as soon the compiled program is run.
- The binary file follows a specific **structure**, and one of the most common ones is named **ELF** that abbreviates **Executable and Linkable Format**. 
- ELF is widely used for 
    - executable files
    - relocatable object files
    - shared libraries
    - core dumps
- The specification does **not** clarify the **filename extension** for ELF files. In use is a variety of letter combinations, such as 
    - .axf, 
    - .bin, 
    - .elf, 
    - .o, 
    - .prx, 
    - .puff, 
    - .ko, 
    - .so, and 
    - .mod, 
    - or none.
- `man elf` gives you a handy summary about the structure of an ELF file

### ELF Header

- reading the ELF header:
    - `readelf -h elf_file`
        - read more about `readelf` in [[What is an ELF file](https://linuxhint.com/understanding_elf_file_format/)]
    - `objdump -h elf_file`
- The ELF header is 32 bytes long, and identifies the format of the file. 
- It starts with a sequence of four unique bytes that are 0x7F followed by 0x45, 0x4c, and 0x46 which translates into the three letters E, L, and F. 
- Among other values, the header also indicates 
    - whether it is an ELF file for 32 or 64-bit format, 
    - uses little or big endianness, 
    - shows the ELF version 
    - as well as for which operating system the file was compiled for in order to interoperate with the right application binary interface (ABI) and cpu instruction set.

# Operator Precedence, Associativity

- When multiple operators of the same precedence level are used in an expression, they are evaluated according to their **associativity** [[source](https://www.programiz.com/cpp-programming/operators-precedence-associativity)]

# Int

- don't convert `int` to `float`
    - when an integer type is converted to a floating-point type, the resulting floating-point value might not exactly match the integer value (e.g. `2.999995` instead of `3`)
    - keep integer values in type `short`, `int`, `long`, or variables `long long`

## Low-order byte and High-order byte

- In C, the size of an `int` is implementation defined, but is usually 2, or 4 bytes in size. The **high-order byte** would be the byte that contains the largest portion of the value. The **low-order byte** would be the byte that contains the smallest portion of the value. 
    - For example, if you have a 16-bit `int`, and the value is 5,243, you'd write that in hex as 0x147B. The high order byte is the 0x14 (1 byte = 8 bit, sodass 256 Werte möglich sind, was in hex **2 Ziffern** sind! Daher die 14 und nicht nur die 1 hinter dem 0x.), and the low-order byte is the 0x7B. A `char` is only 1 byte, so it is always contained within the lowest order byte. When written in hex (in left-to-right fashion) the low-order byte will always be the right-most 2 digits, and the high-order byte will be the left-most 2 digits (assuming they write all the bytes out, including leading 0s). [[stackoverflow](https://stackoverflow.com/questions/47117509/high-order-and-low-order-byte)]

# Arrays

- **problem 1**: The only way you can pass an array to a function is by using a pointer to an array.
- **problem 2**: function that can handle arrays of different sizes (e.g. a function that finds the largest element in an array of integers)
    - How does the function know the size of the array whose address it was passed?
        - **method 1**: identify the last array element by storing a **special value** there
        - **method 2**: Pass the function the array size as an argument

# Program Input/Output, Devices

- input
    - Data moved from an external location into RAM, where the program can access it
- output
    - Data sent to a location external to the program (common destinations: screen, printer, disk files)
- devices
    - collective term for input sources and output destinations

# Streams

- C carries out all input and output operations by means of streams
- **stream**: a sequence of bytes of data (e.g. a sequence of characters)
    - **input stream**: sequence of bytes flowing into a program
    - **output stream**: sequence of bytes flowing out of a program
- **advantage**: streams make input/output programming **device independent**
- **file**: every C stream is connected to a **file**, which is an intermediate step between the stream that your program deals with and the actual physical device being used for input or output
    - the details of interactions between streams, files, and devices are taken care of automatically by the C library functions and the operating system
- **2 modes of C streams**
    - **text stream**: consists only of characters (e.g. text data)
    - **binary stream**: consists of any sort of data

## Five Standard Streams

(the first 3 are C ANSI standard, the last 2 are only under Windows and DOS)

| Format Specifier | Type | Device |
| :---: | :---: | :---: |
stdin | Standard input | Keyboard
stdout | Standard output | Screen
stderr | Standard error | Screen
stdprn* | Standard printer | Printer (LPT1:)
stdaux* | Standard auxiliary | Serial port (COM1:)

# Stream Functions

- functions that deal with stream input and output

## Input Functions

- hierarchy of 3 levels
    - character input (`getchar`, `getch`, `getche`, `getc`, `fgetc`, `ungetc`)
    - line input (`gets`, `fgets`)
    - formatted input (`scanf`, `fflush`)

## Output Functions

- 3 categories
    - character output (`putchar`, `putc`, `fputc`)
    - line output (`puts`, `fputs`)
    - formatted output (`printf`, `fprintf`)

# printf

## Escape sequences

- see [Table of escape sequences](https://en.wikipedia.org/wiki/Escape_sequences_in_C#Table_of_escape_sequences)

## Format specifiers

| Format Specifier | Type |
| :---: | :---: |
`%c`	| Character
`%d`	| Signed integer
`%e` or `%E` |	Scientific notation of floats
`%f`	 | Float values
`%g` or `%G` |	Similar as `%e` or `%E`
`%hi` |	Signed integer (short)
`%hu` |	Unsigned Integer (short)
`%i` |	Unsigned integer
`%l` or `%ld` or `%li` |	Long
`%lf` |	Double
`%Lf` |	Long double
`%lu` |	Unsigned int or unsigned long
`%lli` or `%lld` |	Long long
`%llu` |	Unsigned long long
`%o` |	Octal representation
`%p` |	Pointer
`%s` |	String
`%u` |	Unsigned int
`%x` or `%X` |	Hexadecimal representation
`%n` |	Prints nothing
`%%` |	Prints `%` character

These are the basic format specifiers. We can add some other parts with the format specifiers. These are like below −
- A minus symbol (-) sign tells left alignment
- A number after `%` specifies the minimum field width. If string is less than the width, it will be filled with spaces
- A period (.) is used to separate field width and precision

# scanf, gets, fgets

Read all characters up to the next newline character (`'\n'`, must use **single** quotes else it is a string literal).

## Control Characters

- **EOF**: If you're typing at the terminal and you want to provoke an end-of-file, use CTRL-D (unix-style systems) or CTRL-Z (Windows).

## scanf

- limitations:
    - `scanf()` cannot take strings with **spaces** in between characters as input, `gets()` and `fgets()` can

## gets

- prototype: `char *gets(char *str);`
- input stream is read from `stdin` until 
    - a newline (`'\n'`) or 
    - end-of-**file** (see [Control Characters](#control-characters)) is encountered 
- the newline (`'\n'`) is **replaced** with a null character (`'\0'`)
- return value: 
    - a pointer to the string (the same as `str`)
    - if `gets()` encounters an error or reads end-of-file: a null pointer
- the string is stored at the location indicated by `str`
- **important**: allocate sufficient memory space to store the string before calling `gets()`

## fgets

- prototype: `char *fgets(char *str, int n, FILE *fp);`
    - `FILE *fp` is used to specify the input stream (e.g. `stdin`)
    - `str` indicates where the input string is stored 
    - `n` specifies the maximum number of characters to be input
- input stream is read until 
    - a newline (`'\n'`) or 
    - end-of-line is encountered or 
    - `n - 1` characters have been read
- the newline (`'\n'`) is **included** in the string (different from `gets()`!) and a `'\0'` is appended before it is stored (i.e. strings are stored with trailing `'\n\0'`)
- the return values are the same as for `gets()`
- the string is stored at the location indicated by `str`

# Char

- use **single quotations** when initializing a variable
- char constants:
    - literal:	
        - enclose a single character in **single quotation marks**
          ```C
          char code = 'x';
          ```
    - symbolic:
        - using `#define`
          ```C
          #define EX 'x'
          char code = EX; /* Sets code equal to 'x' */
          ```
        - using `const`
          ```C
          const char A = 'Z';
          ```
- When you store the character `a` in a type `char` variable, the compiler is really storing the ASCII value `97` 
- if you want to print the extended ASCII (aka CP437) characters, you must use an `unsigned char` 
    - not good practice, use UTF-8 instead (see [mapping from extended ASCII to UTF-8](https://en.wikipedia.org/wiki/Code_page_437#Character_set))

# Strings

- a string is a sequence of characters delineated by 
    - a pointer that points to the string's first character and 
    - a null character `\0` that indicates the end of the string ("null-terminated" string)
- From [C18 6.4.5](https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf):
    - A **character string literal** is a sequence of zero or more multibyte characters enclosed in double-quotes, as in `"xyz"`. 
    - A **UTF–8 string literal** is the same, except prefixed by `u8`. 
    - A **wide string literal** is the same, except prefixed by the letter `L`,`u`, or `U`.

## String Literals

From the [C89 Rationale, 3.1.4 String literals](http://port70.net/~nsz/c/c89/rationale/c1.html#3-1-4):
- String literals are specified to be **unmodifiable**. 
- This specification allows implementations to share copies of strings with identical text, to place string literals in read-only memory, and perform certain optimizations. 
- However, string literals **do not** have the type array of `const char`, in order to avoid the problems of pointer type checking, particularly with library functions, since assigning a pointer to `const char` to a plain pointer to `char` is not valid. 
- Those members of the Committee who insisted that string literals should be modifiable were content to have this practice designated a common extension (see F.5.5).

## Create Strings as char arrays

element-by-element:
```C
char string[10] = { 'A', 'l', 'a', 'b', 'a', 'm', 'a', '\0' };
```

literal string:
```C
char string[10] = "Alabama";
char message[] = "Great Caesar\'s Ghost!";
```
- use **double quotes**
- a literal string evaluates as a pointer to a string
- The array's name is a type `char` pointer to the beginning of the string
- the compiler calculates the size of the array for you, if no subscript is provided
    - **Note**: The expression within the brackets `[]` is referred to as a **subscript**
- the compiler **automatically** adds the terminating null character at the end of the string

## Create Strings without arrays

### Allocate string space at compilation

**static memory allocation**: explicitly allocating memory in the program source code by declaring variables, structures, and arrays
```C
char *message = "Great Caesar\'s Ghost!";
```
i.e. `*message` and `message[]` are equivalent!

**Note**:
- The pointer `*message` itself is stored at a different location than the literal string `"Great Caesar\'s Ghost!"` (see section [Pointer](#pointer)).
- the literal string `"Great Caesar\'s Ghost!"` evaluates as a pointer to a string
- The array's name is a type `char` pointer to the beginning of the string

### Allocate string space at runtime (malloc)

**dynamic memory allocation**:
```C
#include <stdlib.h>
#include <stdio.h>
int main( void )
{
    /* allocate memory for a 100-character string */
    char *str;
    str = (char *) malloc(100 * sizeof(char));
    if (str == NULL)
    {
        printf( "Not enough memory to allocate buffer\n");
        exit(1);
    }
    printf( "String was allocated!\n" );
    return 0;
}
```
Note that `malloc()` is typecast so that its return value is the proper type - a pointer to a `char` variable.

# Pointer

- The address of a variable is actually the address of the first (lowest) byte it occupies
- Each pointer is equal to the address of the first byte of the pointed-to variable

## Size of pointers

- The size of a pointer in C/C++ depends upon different issues like Operating system, CPU architecture etc. 
- Usually it depends upon the **word size of underlying processor**, for example
    - for a **32 bit computer** the pointer size can be **4 bytes** 
    - for a **64 bit computer** the pointer size can be **8 bytes**. 
- So, **for a specific architecture** pointer size **will be fixed**.
- It is **common to all data types** like `int *`, `float *` etc.

## Data type of pointers 

From [stackoverflow](https://stackoverflow.com/a/26976670):
- But really, what is a type? The gist of it is that a type is a way to determine how data in memory is supposed to be interpreted. A variable of the type `char` represents a character. A variable of the type `int` represents an integer. Same applies to pointers: `char *x` is not of the type `char`, it's of the type `char *` (pointer to `char`). This means that `char *x` itself is a location in memory we can use to read one or more `char` values.
- TL;TR: Yes, a pointer is a data type (`void *` in its purest form). The pure form is quite unusable (because you can't dereference it). Instead of having to cast the pointer every time you decide to use it, C offers the convenience of derived pointer types (like `char *`, `int *` and so on). But really, they're pointers, and therefore a data-type in their own right.

## NULL pointer

Definition:
```cpp
#define NULL ( (void *) 0)
```

**C11 standard** definition: 
- An integer constant expression with the value `0`, or such an expression cast to type `void *`, is called a **null pointer constant**.
- If a null pointer constant is converted to a pointer type, the resulting pointer, called a **null pointer**, is guaranteed to compare unequal to a pointer to any object or function.

### Usage

1. To initialize a pointer variable when that pointer variable hasn't been assigned any valid memory address yet. 
```C
int * pInt = NULL;
```
2. To check for a null pointer before accessing any pointer variable. By doing so, we can perform error handling in pointer related code, e.g., dereference a pointer variable only if it's not `NULL`. 
```C
if(pInt != NULL) /* We could use if(pInt) as well */
{ 
	/* Some code */ 
}
else
{ 
	/* Some code */ 
}
```
3. To pass a null pointer to a function argument when we don't want to pass any valid memory address.
```C
int fun(int *ptr)
{
	/*Fun specific stuff is done with ptr here*/
	return 10;
}
fun(NULL);
```

### Difference between a void pointer and a NULL pointer?

From [stackoverflow](https://stackoverflow.com/a/4116332):

In C, there is `void`, `void` pointer and `NULL` pointer.
- `void` is absence of type. I.E. a function returning a `void` type is a function that returns nothing.
- `void` pointer: is a pointer to a memory location whose type can be anything: a structure, an int, a float, you name it.
- A `NULL` pointer is a pointer to location `0x00`, that is, no location. Pointing to nothing.

Examples:

`void` function:
```cpp
void printHello()
{
   printf("Hello");
}
```
`void` pointer:
```cpp
void *malloc(size_t si)
{
    // malloc is a function that could return a pointer to anything
}
```
`NULL` pointer:
```cpp
char *s = NULL;
// s pointer points to nowhere (nothing)
```

## Pointer arithmetic

If you have a pointer `ptr` that points to a data object of type `obj`,
```C
ptr++
```
has the same effect as
```C
ptr += sizeof(obj);
```

## Address of a pointer / multiple indirection

- **multiple indirection**: You can use the address-of operator to find the address of a pointer, so you can have **pointers to pointers**.
    - The most common use involves **arrays of pointers**.
        - The most common use of an array of pointers is with **strings**.

## Passing Function arguments

Using "passing by reference" (coll.) we can overcome two limitations of functions: 
- Arguments are passed by value, and 
- the return statement can return only one value

# Structs

## 3 ways to access a structure member

- Using the structure name
- Using a pointer to the structure with the indirection operator (`*`)
- Using a pointer to the structure with the indirect membership operator (`->`)
    - sometimes called "structure pointer operator"

Therefore, if `p_str` is a pointer to the structure `str`,
```C
str.memb
(*p_str).memb
p_str->memb
```
are equivalent.

## typedef

Whether you use `typedef` or a structure tag to declare structures makes little difference
```C
typedef struct {
	int x;
	int y;
} coord;
```
or using a structure tag
```C
struct coord {
	int x;
	int y;
};
```

# Type Conversions

## Type Promotion (implicit conversion, automatic conversion)

If the components of an expression have different types, an expression has the same type as its **most comprehensive component**. From least-comprehensive to most-comprehensive, the numerical data types are
- char
- short
- int
- long
- long long
- float
- double
- long double

**Note**: Promotion means that a copy of the variable is created and used in the expression evaluation. The type of the variable is **not** changed!

**Promotion by Assignment**: expression on the right side of an assignment statement is always promoted to the type of the data object on the left side of the assignment operator
- may cause **demotion** 
    - e.g. `float` to `int` (**Caution**: fractional part is lost!)

## Cast / Typecast (explicit conversion)

- e.g. `(float)i` when `i` is an integer
- can be performed on **arithmetic expressions** and **pointers**
- makes an internal **copy** of the variable using the new type (similar to promotion)
- most common use: `f1 = (float)i1/i2;` to avoid using the fractional part in an integer division
    - casting one of the `int` variables is sufficient
- casting **pointers**:
    - Before you can use a `void` pointer, you **must cast** it to the proper type 
    - **don't** need to cast a pointer
        - in order to assign a value to it
        - to compare it with `NULL`
    - **must** cast a pointer
        - before dereferencing
        - before performing pointer arithmetic with it

# Memory

## RAM available for allocation

When you run a C program, the program is loaded from disk into the computer's memory. The memory space the program occupies includes the **program code**, as well as space for all the program's **static data** - that is, data items that are declared in the source code. **The memory left over is what's available for allocation.** 

## Allocation Functions

- all allocation functions return a type `void` pointer 
    - a type `void` pointer must be cast to the appropriate type before being used (see section "Cast")
- When a memory allocation function is called, you **must check its return value** to ensure that the memory was allocated successfully.
- In addition, your programs must be able to **gracefully handle the situation when a memory allocation request fails**

### malloc (stdlib.h)

- allocates a group of bytes
- prototype: `void *malloc(size_t num);` 
- returns a pointer to the first byte
- returns `NULL` 
    - if the requested storage space couldn't be allocated or 
    - if `num == 0`.

### calloc (stdlib.h)

- allocates a group of objects
- prototype: `void *calloc(size_t num, size_t size);`
- returns a pointer to the first byte
- clears all the allocated memory (set to `0`)
- returns `NULL` 
    - if the requested storage space couldn't be allocated or 
    - if `num == 0`.
    - if `size == 0`.

### realloc (stdlib.h)

- changes the size of a block of memory that was previously allocated with or `calloc()`, `malloc()`
- prototype: `void *realloc(void *ptr, size_t size);`
- expand block:
    - if sufficient space exists: expand **old** block, return `ptr`
    - if sufficient space **does not** exist: allocate a **new** block, copy data to **new** block, free **old** block, return a pointer to the new block
- if `ptr == NULL`: like `malloc()`
- if `size == 0`: `free(ptr)`
- if memory is insufficient: leave **old** block unchanged
- returns `NULL` 
    - if memory is insufficient (either for expanding the **old** block or for allocating a **new** one)
    - if `size == 0`.

## Deallocation

### free (stdlib.h)

- releases the memory pointed to by `ptr`
- prototype: `void free(void *ptr);`
- must have been allocated with `malloc()`, `calloc()`, or `realloc()`
- If `ptr` is `NULL`, `free()` does nothing

## Manipulation

- `memset()`
- `memcpy()`
- `memmove()`

# Linked List

- TODO
