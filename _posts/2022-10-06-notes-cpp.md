---
title: "C++ Notes"
read_time: false
excerpt: "For learning C++"
header:
    teaser: /assets/images/Cpp_logo.png
    overlay_image: /assets/images/Cpp_logo.png
    overlay_filter: 0.5 
toc: true
toc_label: "Contents"
toc_sticky: true
categories:
    - Notes
tags:
    - c++
    - notes

---

# Standards

## C++11

- see p. xix "New Features in C++11"

# Definitions

## Deep Copy vs Shallow Copy

see [stackoverflow](https://stackoverflow.com/a/184780)

## Areas of Memory

- **stack** - Local variables, function parameters 
- **code space** - Code
- **global namespace** - global variables 
- **registers** - used for internal housekeeping functions, such as keeping track of the top of the stack and the instruction pointer
- **free store = heap = dynamic memory** - Just about all of the remaining memory 

## Value Categories

[learn.microsoft.com](https://learn.microsoft.com/en-us/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-170):
- Every C++ expression has a **type**, and belongs to a **value category**.
- The **value categories** are the basis for rules that compilers must follow when creating, copying, and moving **temporary objects** during expression evaluation.
- C++17:
  - A **glvalue** is an expression whose evaluation determines the identity of an object, bit-field, or function.
  - A **prvalue** is an expression whose evaluation initializes an object or a bit-field, or computes the value of the operand of an operator, as specified by the context in which it appears.
    - has no address that is accessible by your program
    - examples
      - literals, 
      - function calls that return a nonreference type, and 
      - temporary objects that are created during expression evaluation but accessible only by the compiler
  - An **xvalue** is a glvalue that denotes an object or bit-field whose resources can be reused (usually because it is near the end of its lifetime). 
    - has an address that no longer accessible by your program but can be used to initialize an rvalue reference, which provides access to the expression
    - examples
      - Certain kinds of expressions involving **rvalue references** (8.3.2) yield xvalues, such as a call to a function whose return type is an rvalue reference or a cast to an rvalue reference type.
      - function calls that return an **rvalue reference**, and 
      - the array subscript expressions where the array is an **rvalue reference**
      - member and pointer to member expressions where the object is an **rvalue reference**
  - An **lvalue** is a glvalue that isn't an xvalue.
    - has an address that your program can access
    - examples
      - variable names, including `const` variables, 
      - array elements, 
      - function calls that return an lvalue reference, 
      - bit-fields, 
      - unions, and 
      - class members
  - An **rvalue** is a prvalue or an xvalue.

![value-categories](/assets/images/cpp/value_categories.png)

[stackoverflow](https://stackoverflow.com/a/3601661):
- "The whole massacre began with the move semantics."

### lvalue and rvalue (informal)

- **every expression in C++** is either an **lvalue** or an **rvalue**
- inherited from C 
  - in C: simple mnemonic purpose: lvalues could stand on the left-hand side of an assignment whereas rvalues could not
- in C++: Roughly speaking, 
  - when we use an object as an **rvalue**, we use the **object's value** (its contents). 
  - when we use an object as an **lvalue**, we use the **object's identity** (its **location** in memory).
- we can use an lvalue when an rvalue is required, but we cannot use an rvalue when an lvalue (i.e., a location) is required

## POD Types, Layout Dependent Operations

phth:
- Some programs and compilers use **operations that depend on** a particular memory **layout**.
- Therefore, C++14 introduced three categories of simple classes and structs, **trivial**, **standard-layout**, and **POD**, so that programs can check the suitability of any given type for operations that depend on a particular memory layout.

[learn.microsoft.com](https://learn.microsoft.com/en-us/cpp/cpp/trivial-standard-layout-and-pod-types?view=msvc-170&source=recommendations):
- **layout:** refers to how the members of an object of class, struct or union type are arranged in memory. 
  - In some cases, the layout is well-defined by the language specification. 
  - But when a class or struct contains certain C++ language features such as virtual base classes, virtual functions, members with different access control, then the compiler is free to choose a layout. 
    - That layout may vary depending on what optimizations are being performed and in many cases the object might not even occupy a contiguous area of memory.
- **POD type:** When a class or struct is both trivial and standard-layout, it is a POD (Plain Old Data) type. 
  - The **memory layout** of POD types is therefore **contiguous** and each member has a higher address than the member that was declared before it, so that byte for byte copies and binary I/O can be performed on these types. 
  - Scalar types such as int are also POD types. 
  - POD types that are classes can have only POD types as non-static data members.

- PODType
  - detailed:
    - [C++98/03](https://stackoverflow.com/a/4178176/734069)
    - [C++11](https://stackoverflow.com/a/7189821/734069)
  - informal:
    - [types that are POD](https://stackoverflow.com/a/146589)
  - "POD (Plain Old Data) types, compatible with C `struct`"
  - "This means the type is compatible with the types used in the C programming language, that is, can be exchanged with C libraries directly, in its binary form."
    - scalar types
      - "object types that are not array types or class types"
        - arithmetic types
        - enumeration types
        - pointer types
        - pointer-to-member types
        - `std::nullptr_t`
        - cv-qualified versions of these types
    - POD classes
    - arrays of such types
    - cv-qualified versions of these types

## Operators

- the **scope** operator "`::`"
- the **output** operator "`<<`"
  - returns its left-hand operand
- the **input** operator "`>>`"
  - returns its left-hand operand
- [assignment operators](https://en.cppreference.com/w/cpp/language/operator_assignment) (`=`)
  - requires a (non`const`, ie. modifiable) lvalue as its left-hand operand 
  - yields its left-hand operand as an lvalue
  - sub-categories:
    - copy assignment operator
    - move assignment operator
    - compound assignment operator (`+=`)
- arithmetic operators
  - addition operator (`+`)
- logical and relational operators
  - logical AND (`&&`)
  - less than (`<`)
- the call operator (`()`)
- increment operator "`++`"
- decrement operator "`--`"
- complement operator (`~`)
- [member access operators](https://en.cppreference.com/w/cpp/language/operator_member_access)
  - subscript operator (`a[b]`)
    - "provides access to an object pointed-to by the pointer or array operand"
  - dereference/indirection operator (`*a`)
    - "provides access to an object or function pointed-to by the pointer operand"
  - address-of operator (`&a`)
    - "creates a pointer pointing to the object or function operand"
    - requires an lvalue operand
    - returns a pointer to its operand as an rvalue
  - member of object/dot operator (`a.b`)
    - "provide access to a data member or member function of the object operand"
    - returns the member named by the right-hand operand
  - member of pointer (`a->b`, equivalent to `(*a).b`)
    - "provide access to a data member or member function of the class pointed-to by the pointer operand"

### Lvalues vs Rvalues and Operators

- Operators differ as to whether they 
  - require lvalue or rvalue **operands**
  - **return** lvalues or rvalues
- Examples of operators that involve lvalues:
  - **Assignment** 
    - requires a (non`const`) lvalue as its left-hand operand
    - yields its left-hand operand as an lvalue.
  - **address-of** operator 
    - requires an lvalue operand
    - returns a pointer to its operand as an rvalue.
  - built-in **dereference** and **subscript** operators and the **iterator dereference** and **string and vector subscript** operators 
    - all yield lvalues.
  - built-in and iterator **increment** and **decrement** operators 
    - require lvalue operands 
    - the prefix versions (which are the ones used so far) also yield lvalues.

## Expressions, literals

source: [https://en.cppreference.com/w/cpp/language/expressions](https://en.cppreference.com/w/cpp/language/expressions)

- **expression** := sequence of **operators** and their **operands**, that specifies a computation.
- **primary expression** := literals, [id-expressions](https://www.ibm.com/docs/en/i/7.4?topic=expressions-identifier-c-only), lambda-expressions, fold-expressions, requires-expressions
  - **literals** := the tokens of a C++ program that represent **constant** values ( = Konstanten ) (dh alle Zeichen, die man "nicht ändern kann") 
    - **integer literals** (eg `1`, `2`, `3`, ...)
    - **character literals** (eg einzelne Buchstaben)
    - **boolean literals** (`true` und `false`)
    - **nullptr** (Merke: `nullptr` ist ein **literal**!)
- C++ expression **properties**: "*each C++ expression is characterized by two independent properties*"
  - **1. type**
  - **2. value category:**
    - **Primary categories:**
      - **prvalue expression** (eg literals (s.o.), arithmetic expressions [`+`,`-`,`%`,...], ...)
      - **xvalue expression**
      - **lvalue expression**
    - **Mixed categories:**
      - **glvalue expression**
      - **rvalue expression**

## Statements

- "fragments of the C program that are executed in sequence"
- 5 types
  - 1) compound statements (aka **block**)
    - "a brace-enclosed sequence of statements and declarations."
    - "Each compound statement introduces its own **block scope**."
  - 2) expression statements
    - "An expression followed by a semicolon is a statement."
  - 3) selection statements
  - 4) iteration statements
  - 5) jump statements

## CV Type Qualifiers

- "Appear in any type specifier, including decl-specifier-seq of declaration grammar, to specify constness or volatility of the object being declared or of the type being named."
  - `const` - defines that the type is constant.
  - `volatile` - defines that the type is volatile. 

[Wikipedia](https://en.wikipedia.org/wiki/Type_qualifier):

As of 2014 and C11, there are four type qualifiers **in standard C**: `const` (C89), `volatile` (C89), `restrict` (C99) and `_Atomic` (C11) – the latter has a private name to avoid clashing with user-defined names. The first two of these, `const` and `volatile`, are also present **in C++**, and are the only type qualifiers in C++. Thus **in C++** the term "cv-qualified type" (for `const` and `volatile`) is often used for "qualified type", while the terms "c-qualified type" and "v-qualified type" are used when only one of the qualifiers is relevant.

Of these, `const` is by far the best-known and most used, appearing in the C and C++ standard libraries and encountered in any significant use of these languages, which must satisfy const-correctness. The other qualifiers are used for low-level programming, and while widely used there, are rarely used by typical programmers. For a time however `volatile` was used by some C++ programmers for synchronization during threading, though this was discouraged and is now broken in most compilers. 

## Factory

Wikipedia:
- In object-oriented programming, a **factory** is an object for creating other objects; 
- formally, it is a function or method that returns objects of a varying prototype or class from some method call, which is assumed to be "new". 
- More broadly, a *subroutine* that returns a "new" object may be referred to as a "factory", as in **factory method** or **factory function**. ("even if functions are not objects")
- The factory pattern is the basis for a number of related software design patterns. 

# Header Files

## Using C Headers in C++

- use the **C++ versions** of C library headers
  - Headers **in C** have names of the form `name.h`. The **C++ versions** of these headers are named `cname`.
  - **Warning:** names defined in the `cname` headers are defined inside the `std` namespace, whereas those defined in the `.h` versions are not

## Newline at EOF

It is good style to always put a newline at the end of text files (POSIX Standard), [stackoverflow](https://stackoverflow.com/questions/729692/why-should-text-files-end-with-a-newline)
- this is part of language standards:
  - in `C`: newline required at the end of header files
  - in `C++`: before `C++11`: newline required at the end of header files
  - "*No newline at end of file*" compiler warning, [stackoverflow](https://stackoverflow.com/questions/72271/no-newline-at-end-of-file-compiler-warning)
- in `git`: [stackoverflow](https://stackoverflow.com/questions/5813311/whats-the-significance-of-the-no-newline-at-end-of-file-log)

# Include Syntax

Usual practice is to use the `#include "local.h"` form for headers inside a `library/package/module`, and the `#include <external.h>` form for headers from `external/3rd-party` or system libraries.

Lippman, Lajoie, Moo: Headers from the **standard library** are enclosed in angle brackets (`< >`). Those that are not part of the library are enclosed in double quotes (`" "`).

# Keywords

- see Table 2.3

## using

Using the namespace designation is **good form** because, if you use `using namespace some_namespace`, you run the risk of inadvertently using objects from the wrong library. This takes some **effort to fix**, whereas using the namespace designation cannot lead to such conflicts (see [example](https://stackoverflow.com/a/1452738)). I.e. from a **maintenance** perspective using the namespace designation is **best practice**.

## = default

- `= default` can be used only on member functions that have a synthesized version
- **defaulted functions**:
  - explicitly-*defaulted* function definition: as an explicit instruction to the compiler to generate a [special member function](#special-member-function)
- to explicitly ask the compiler to generate the **synthesized** versions of the **copy-control members**
- the synthesized function is **implicitly inline** (just as is any other member function defined in the body of the class)
  - if we do **not** want the synthesized member to be an inline function, we can specify `= default` on the member's **definition** (outside the class)

## = delete

- Motivation: how to prevent copies?
  - simply not defining the copy-control members does not work because the compiler will synthesize them, if we do not define them
- **deleted functions**:
  - one that is declared but may not be used in any other way
- signals to the compiler (and to readers of our code) that we are **intentionally not defining** these members
- A `=delete` makes an attempted use of the deleted function a compile-time error (BS6.1.1)
- Unlike `= default`, `= delete` 
  - must appear on the first declaration of a deleted function
  - we can specify `= delete` on **any** function
    - sometimes also useful to guide the **function-matching** process
- use cases:
  - "A base class in a class hierarchy is the classic example where we don't want to allow a memberwise copy" (BS6.1.1)
- **Warning:** You can `delete` a destructor. However, it is not possible to
  - define an object of a type with a deleted destructor
  - `delete` a pointer to a dynamically allocated object of a type with a deleted destructor
    - ie you **can** dynamically allocate such objects, but you cannot free them
- "synthesized as deleted"
  - in essence, if a class has a **data member** that **cannot** be default constructed, copied, assigned, or destroyed, then the corresponding copy-control member will be a deleted function
- prior to the new standard: 
  - prevent copying by declaring the copy constructor and copy-assignment operator as `private`
    - not best practice! Use `= default` instead.

## auto

- tells the compiler to deduce the type from the initializer
  - thus, a variable that uses `auto` must have an initializer
- type that the compiler infers for `auto` is not always exactly the same as the initializer's type
  - eg. for 
    - references
      - compiler uses the referred object's type, and not the reference type
    - top-level `const`s
      - ignored
- "in the type specifier sequence of a variable: `auto x = expr;` as a type specifier. The type is deduced from the initializer."
- "If the placeholder type specifier is used **to declare multiple variables**, the deduced types must match."
  - "For example, the declaration `auto i = 0, d = 0.0;` is ill-formed, while the declaration `auto i = 0, *p = &i;` is well-formed and the `auto` is deduced as `int`."
- "In **direct-list-initialization** (but not in copy-list-initialization), when deducing the meaning of the `auto` from a **braced-init-list**, the braced-init-list must contain **only one element**, and the type of `auto` will be the type of that element:"
```cpp
// C++17

// from: https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts
auto x1 = {3}; // x1 is std::initializer_list<int>
auto x2{1, 2}; // error: not a single element
auto x3{3};    // x3 is int
               // (before N3922 x2 and x3 were both std::initializer_list<int>)

// from: https://mariusbancila.ro/blog/2017/04/13/cpp17-new-rules-for-auto-deduction-from-braced-init-list/
auto a = {42};   // std::initializer_list<int>
auto b {42};     // int
auto c = {1, 2}; // std::initializer_list<int>   // therefore, quote: "but not in copy-list-initialization"
auto d {1, 2};   // error, too many 
```

## decltype

- returns the type of its operand (like `auto`)
- result is a reference type if the expression yields an lvalue, eg. if `p` is an `int*`
  - `decltype(*p)` is `int&` (because dereference yields an lvalue)
  - `decltype(&p)` is `int**` (because address-of operator yields an rvalue)

```cpp
decltype(f()) sum = x; // sum has whatever type f returns
```

- does not call `f`
- uses the type that such a call **would** return as the type for `sum`
- unlike `auto`, `decltype` returns the type of references and top-level `const`s
- `decltype((variable))` is always a reference type, whereas `decltype(variable)` is a reference type only if `variable` is a reference

## Print Type

`typeid(a).name()`
- **Problem with this approach**: see [stackoverflow](https://stackoverflow.com/a/20170989)
  - throws away cv-qualifiers (ie. `const`, `volatile`), references, and lvalue/rvalue-ness (because the standard mandates this behavior)

# Types

- primitive types (aka **"built-in types"**)
  - arithmetic types
    - integral types (`char`, `int`, `bool`)
    - floating-point types (`float`, `double`)
  - `void`
- non-primitive types
  - **class types**
    - library types (e.g. `string`, `istream`, `ostream`)
  - compound types (2.3 "a type that is defined in terms of another type")
    - pointer types
    - reference types (2.3.1)
    - array types
    - container types (9)
      - sequential (full list, see table 9.1) ("element order corresponds to the position at which elements are put into the container")
        - `string` (see "C Notes")
        - `array`
        - `vector`
        - linked lists
          - `list` (doubly linked)
          - `forward_list` (singly linked)
      - associative ("store elements based on the value of a key")
      - unordered

## Incomplete Types

- **after a declaration** and before a definition is seen, a type is an **incomplete type**

### Forward Declarations

```cpp
// forward declaration:
// declare a class without defining it
class Screen; // declaration of the Screen class
```

- We can 
  - define pointers or references to such types
  - declare (but not define) functions that use an incomplete type as a parameter or return type
- we cannot
  - create objects of that type
  - use a reference or pointer to access a member of the type

Examples:
- data members of the class' own type:
  - Because a class is not **defined** until its class body is complete, a class cannot have data members of its own type
  - However, a class is considered **declared** (but not yet defined) as soon as its class name has been seen. Therefore, a class can have data members that are pointers or references to its own type

# Variables, Objects

"A region of memory that can contain data and has a type."

C++ programmers use the terms "variable" and "object" interchangeably.

- Variable expressions are **lvalues**
- a variable is an expression with one operand and no operator

## Initialization

- in C++: initialization != assignment
  - **Initialization** happens when a variable is given a value **when it is created**. 
  - **Assignment** obliterates an object's current value and replaces that value with a new one.
- sources
  - [learn.microsoft.com](https://learn.microsoft.com/en-us/cpp/cpp/initializers?view=msvc-170)

### Default Initialization

- "the initialization performed when an object is constructed with **no** initializer", i.e. `T object;` or `new T`
- "performed in three situations"
  - 1) when a variable (...) is declared with no initializer `T object;`
  - 2) when an object (...) is created by a `new`-expression with no initializer `new T`
  - 3) when a (...) data member is **not mentioned** in a **constructor initializer list** and that constructor is called
- if `T` is a **class type**, 
  - the constructors are considered and subjected to overload resolution against the empty argument list. 
  - The constructor selected (which is **one of** the **default constructors**) is called to provide the initial value for the new object; 
- if `T` is an **array type**, 
  - every element of the array is default-initialized; 
- otherwise, eg. **built-in type**, no initialization is performed

Examples:
- object of **built-in type**, **compound type** (eg. pointer to built-in type)
  - outside a block (global scope): **0**, **nullptr**
  - inside a block (local scope): **uninitialized/undefined** 
    - best practice: 
      - (in-class) initialize every built-in type object, compound type object
      - provide a default constructor
- object of **class type**
  - value defined by the class
    - some classes **require** that every object be explicitly initialized

### Value Initialization

- "the initialization performed when an object is constructed with an **empty** initializer", i.e. `T()` or `T{}` or `T object {};`
- performed in these situations
  - 1) when a nameless **temporary** object is created with the initializer consisting of an empty pair of parentheses `T()` or braces `T {}`;
  - 2) when an object with dynamic storage duration is created by a **new-expression** with the initializer consisting of an empty pair of parentheses `new T ()` or braces `new T {}`;
  - 3) when a non-static data member or a base class is initialized using a **member initializer** with an empty pair of parentheses `Class::Class(...) : member () { ... }` or braces `Class::Class(...) : member {} { ... }`;
  - 4) when a named object (automatic, static, or thread-local) is declared with the initializer consisting of a pair of braces. (since C++ 11)
- if `T` is a **class type** with a ...
  - "user-provided default constructor" **or** "no default constructor": the object is [default-initialized](#default-initialization);
  - "implicitly-defined" **or** "defaulted default constructor": all of the following 3 steps are performed in the following order:
    - 1) the object is [zero-initialized](#zero-initialization),
    - 2) the semantic constraints for default-initialization are checked, and 
    - 3) if `T` has a non-trivial default constructor, the object is default-initialized;
- if `T` is an **array type**, 
  - each element of the array is value-initialized;
- otherwise, eg. **built-in type**, the object is [zero-initialized](#zero-initialization).
- "References cannot be value-initialized"
- "All standard containers (`std::vector`, `std::list`, etc.) value-initialize their elements when constructed with a single `size_type` argument"
- Lippman p.132: "Initialization in which **built-in types** are initialized to zero and **class types** are initialized by the class's default constructor."
  - "Objects of a **class type** can be value initialized *only if* the class has a default constructor."
  - "Used to initialize a **container**'s elements when a size, but not an element initializer, is specified. Elements are initialized as **a copy of** this compiler-generated value."

### Zero-initialization

- "Sets the initial value of an object to zero."
- zero-initialization "does not have a dedicated syntax in the language", but other types of initialization perform zero-initialization
- "If `T` is a scalar type, the object is initialized to the value obtained by explicitly converting the integer literal `0` (zero) to `T`"

### Copy Initialization

- "Initializes an object **from another object**.", i.e. `T object = other;`
- we can supply only a **single initializer**
- happens when using `=`

```cpp
string s1;            // default initialization; s1 is the empty string
string s2 = s1;       // s2 is a copy of s1
string s3 = "hiya";   // s3 is a copy of the string literal
int units_sold = 0;
// not "Copy Initialization"
int units_sold = {0}; // since C++11 this is classified as "list initialization"
```

- copy initialization usually uses the **copy constructor**, but sometimes it uses the **move constructor**
- happens when
  - when we define variables using an `=`
  - functions
    - (Syntax 3) **pass** an object as **an argument to a parameter** of nonreference type ("pass by value")
    - (Syntax 4) **return** an object **from a function** that has a nonreference return type ("return by value")
  - brace initialization of
    - arrays
    - members of an aggregate class
  - container 
    - initialization
    - when we `insert` or `push` a container member

### Direct Initialization

- **Warning:** not to be confused with **direct-list-initialization** (see "list initialization")
  - the difference is well explained here: [stackoverflow](https://stackoverflow.com/a/71994272)

- "Initializes an object from explicit set of constructor arguments."

- uses the [Copy Constructor](#copy-constructor) 
  - proof: see [Copy Constructor](#copy-constructor) &rarr; "called whenever an object is initialized (by **direct-initialization** ... ) ..."
  - for members of class type, not for built-in types (which do not have constructors)

Difference: Direct vs Copy Initialization:
- **direct initialization**: asks the compiler to "use ordinary function matching to **select the constructor** that best matches the arguments we provide"
- **copy initialization**: asks the compiler to "copy the right-hand operand into the object being created, converting that operand if necessary"

#### Case 1

Happens when we omit the `=`

```cpp
// Examples
string s4(10, 'c');   // s4 is cccccccccc
int units_sold(0);
int units_sold{0};    // "direct initialization" according to Case 4
```

#### Case 2

Happens when initializing with a nonempty **parenthesized** list:
- "1) Initialization with a nonempty **parenthesized** list of expressions or braced-init-lists" (ie. `arg` can be a braced-init-list, but it must be enclosed by parentheses `()`!).

```cpp
T object ( arg );               // (1)

T object ( arg1, arg2, ... );   // (1)
```

#### Case 3

Happens in **constructor initializer lists**:
- "6) Initialization of a base or a non-static member by constructor initializer list."
  - better explanation: [learn.microsoft.com](https://learn.microsoft.com/en-us/cpp/cpp/initializers?view=msvc-170#direct-initialization)
  - here, **"base"** refers to the `BaseClass` when using inheritance (see **Example 2**)
    - because when using inheritance `BaseClass(initializer)` is in the constructor initializer list (like a member that is initialized)

```cpp
// "member" is direct initialized
Class::Class() : member( args, ... ) { ... } 	// (6)
```

**Example 2**:

```cpp
class DerivedClass : public BaseClass{
public:
    // BaseClass and m_char are direct initialized
    DerivedClass(int n, char c) : BaseClass(n), m_char(c) {}

    ...
}
```

#### Case 4

**Single** brace-enclosed initializer for **built-in** objects:
- "2) Initialization of an object of non-class type with a single brace-enclosed initializer"
  - **Note:** if the object is of class type, this would be **list-initialization**, or more precisely **direct-list-initialization**

```cpp
T object { arg };
```

### In-class Initialization

When we create objects, the in-class initializers will be used to initialize the data members. 

- "Initializer provided as part of the declaration of a class data member."
- C++11
- **Members without an initializer** are default initialized
- When we provide an in-class initializer, we must do so 
  - following an `=` sign (copy initialization) **or**
  - inside curly braces `{}` (direct initialization)
  - **not:** initializer in parentheses

### List Initialization

- C++11
- "Initializes an object from **braced-init-list**.", "that is, a possibly empty brace-enclosed list of expressions or nested braced-init-lists"
- 2 syntaxes:
  - **Direct-list-initialization**
    - 1) `T object { arg1, arg2, ... };`, "initialization of a named variable with a braced-init-list (that is, a possibly empty brace-enclosed list of expressions or nested braced-init-lists)"
      - thus, "Direct Initialization" &rarr; "Case 4" is a special case of "Direct-list-initialization"
  - **Copy-list-initialization**
    - 6) `T object = { arg1, arg2, ... };`, "initialization of a named variable with a braced-init-list after an equals sign"

ADVANTAGES:
- The compiler will not let us list initialize variables of **built-in type** if the initializer might lead to the loss of information

```cpp
long double ld = 3.1415926536;

// a: both "direct-list-initialization" and "direct initialization -> Case 4"
// b: both "copy-list-initialization" and "copy initialization"
int a{ld}, b = {ld}; // error: narrowing conversion required
// c: direct initialization
// d: copy initialization
int c(ld), d = ld;   // ok: but value will be truncated
```

VECTORS:
- when we **supply a list of (vector) element values** we can only do this by using list initialization
  - We cannot supply a list of initializers using parentheses:
```cpp
vector<string> v1{"a", "an", "the"}; // list initialization
vector<string> v2("a", "an", "the"); // error
```

### Aggregate Initialization

C++11:
- a form of **list initialization** (since C++11)
- "Initializes an aggregate from an initializer list."
  - `T object = { arg1, arg2, ... };`,
  - `T object{ arg1, arg2, ... };` (since C++11)
- An **aggregate** is one of the following types:
  - array type
  - class type (typically, `struct` or `union`), that has
    - no user-provided, inherited, or explicit constructors
    - no private or protected non-static data members
    - no base classes
    - no virtual member function
    - no default member initializers

### Reference Initialization

- "Binds a reference to an object."
- "A reference to T can be initialized with an object of type T, a function of type T, or an object implicitly convertible to T."
- "Once initialized, a reference cannot be reseated (changed) to refer to another object."
- "If the initializer is a braced-init-list, rules of **list initialization** are followed."
- "Otherwise, if the reference is an lvalue reference: ..." (see [cppreference](https://en.cppreference.com/w/cpp/language/reference_initialization))

1) When a named **lvalue reference** variable is declared with an initializer
```cpp
T & ref = target ;
T & ref = { arg1, arg2, ... }; 
T & ref ( target );
T & ref { arg1, arg2, ... }; 
```

2) When a named **rvalue reference** variable is declared with an initializer
```cpp
T && ref = target ;
T && ref = { arg1, arg2, ... }; 
T && ref ( target );
T && ref { arg1, arg2, ... }; 
```

3) In a function call expression, when the function parameter has reference type
4) In the `return` statement, when the function returns a reference type
5) When a non-static data member of reference type is initialized using a member initializer

## Declaration vs Definition
 
- **"separate compilation"**: split programs into several files, each of which can be compiled independently.
- To support separate compilation, C++ distinguishes between declarations and definitions. 
  - A **declaration** makes a name known to the program. A file that wants to use a name defined elsewhere includes a declaration for that name. 
  - A **definition** creates the associated entity.
- A **variable declaration** specifies the type and name of a variable. 
- A **variable definition** is a declaration. 
  - In addition to specifying the name and type, a definition also **allocates storage** and may provide the variable with an **initial value**.
- Variables must be **defined exactly once** but can be **declared many times**.
- To use the same variable in multiple files, we must define that variable in one - and only one - file. Other files that use that variable must declare - but not define - that variable

### extern

- `extern`: To obtain a declaration that is **not** also a definition, we add the `extern` keyword and must not provide an explicit initializer.
- inside a function
  - It is an error to provide an initializer on an `extern` 
- outside a function 
  - we can initialize an `extern`, however, this overrides the `extern`. The `extern` becomes a definition in this case.

## Static typing

- C++ is a statically typed language, which means that **types are checked at compile time**. 
- The process by which types are checked is referred to as **type checking**.
- consequence of static typing: must declare the type of a variable before we can use that variable

## this

like `self` in Python:
- [stackoverflow](https://stackoverflow.com/questions/22526153/self-of-python-vs-this-of-cpp-c), inside the class block `self` must be written **explicitly** each time, whereas `this` can be dropped
- [stackoverflow](https://stackoverflow.com/a/61240703), `this->member = 4;` equals `(*this).member = 4;` equals `member = 4;`

p.257-258: "Defining Member Functions", "Introducing this", "Introducing `const` Member Functions"
- member functions access the object on which they were called through an implicit parameter `this`
  - when a member function is called (eg. `total.isbn()`), `this` is initialized with the address of the object on which the function was invoked (like `Sales_data::isbn(&total)`, where `isbn()` is defined as `Sales_data::isbn(Sales_data *const this)`)
- the `this` parameter is defined implicitly. Thus, it is legal, although unnecessary, to define

```cpp
struct Sales_data {
  ...
  std::string isbn() const { return bookNo; }
  ...
}
```

as

```cpp
struct Sales_data {
  ...
  std::string isbn() const { return this->bookNo; }
  ...
}
```

Type of `this`:
- default:
  - "`this` is a `const` pointer to the non`const` version of the class type" 
    - **phth**: eg. `this` is the "const pointer" `Sales_data *const` (it is not a "pointer to const" `const Sales_data *const`)
- in `const` member function blocks:
  - the keyword `const` that follows the parameter list modifies the type of the implicit `this` pointer:
    - A `const` following the parameter list indicates that `this` is a pointer to `const` (see [pointer to const](#pointer-to-const)).

## const objects

- may call only `const` member functions
- a `const` object does not assume its "constness" until after the constructor completes the object's initialization

## pointer to const

```cpp
const double pi = 3.14;
double *ptr = &pi;          // error: ptr is a plain pointer (see (2))
const double *cptr = &pi;
*cptr = 42;                 // error: cannot assign to *cptr (see (1))
```

- (1) a pointer to `const` may not be used to change the object to which the pointer points
- (2) we may store the address of a `const` object **only** in a pointer to `const`
- we can use a pointer to `const` to point to a non`const` object (exception to rule: "types of a pointer and the object to which it points must match")
- a pointer to `const` says nothing about whether the object to which the pointer points is `const` (like a [reference to const](#reference-to-const))
  - think of them as pointers or references "that *think* they point or refer to `const`"

## const pointer

```cpp
int errNumb = 0;
int *const curErr = &errNumb;   // curErr will always point to errNumb
```

- its value (i.e., the address that it holds) may not be changed
- The fact that a pointer is itself `const` says nothing about whether we can use the pointer to change the underlying object
- "unlike references, pointers are objects" &rarr; pointers can be `const`, references cannot

## static

- [stackoverflow](https://stackoverflow.com/a/15235626)

### static members

- members that are associated with the class, rather than with individual objects of the class type
- basically, like any other member
  - can be `public` or `private`
  - type of a `static` data member can be `const`, reference, array, class type
  - etc
- unlike other members
  - exist outside any object
    - objects do **not** contain data associated with static data members
  - static members are **shared by all** the objects of the class type
  - they do not have a this pointer
    - they may not be declared as `const`
    - we may not refer to `this` in the body of a static member
- declaration

```cpp
class Account {
  public:
    void calculate() { amount += amount * interestRate; }
    static double rate() { return interestRate; }
    static void rate(double);
  private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate();
};
```

- definition

```cpp
// static member functions:
// - do not repeat the "static" keyword outside the class body
void Account::rate(double newRate)
{
  interestRate = newRate;
}

// static data members:
// - not defined when we create objects
// - not initialized by the class' constructors
// - must define and initialize OUTSIDE the class body
//   - must declare, but NOT initialize inside the class body!
//   - define outside ANY function (like global variables)
double Account::interestRate = initRate();   // define and initialize a static class member
// Once the class name is seen, the remainder of the definition is in the scope of the class
// -> we can use "initRate" without qualification (even though it is private)
```

**best practice:**
- put the definition of `static` data members in the same file that contains the definitions of the class noninline member functions (avoids double definitions)

**in-class initialization:**
- usually you do **not** do this for static members, but
  - we can provide in-class initializers for static members that have `const` integral type
  - must do so for static members that are `constexpr`s of literal type
    - the initializers must be constant expressions
    - such members are themselves constant expressions
  - **important:** if an initializer is provided inside the class, the member's definition must not specify an initial value:

```cpp
// definition of a static member with no initializer
constexpr int Account::period; // initializer provided in the class definition
```

**best practice:**
- Even if a `const` static data member is initialized in the class body, that member ordinarily should be defined outside the class definition.

### Usage

```cpp
double r;
r = Account::rate();  // access a static member using the scope operator

Account ac1;
Account *ac2 = &ac1; 
// equivalent ways to call the static member rate function
r = ac1.rate();       // through an Account object or reference
r = ac2->rate();      // through a pointer to an Account object

class Account {
  public:
    // Member functions can use static members directly, without the scope operator
    void calculate() { amount += amount * interestRate; }
  private:
    static double interestRate;
    // remaining members as before
};
```

Can be used in ways that would be illegal for nonstatic members:
```cpp
// static members can have incomplete types
class Bar {
  public:
    // ...
  private:
    static Bar mem1;  // ok: static member can have incomplete type
    Bar *mem2;        // ok: pointer member can have incomplete type
    // error:
    Bar mem3;         // error: data members must have complete type
 };

// static members can be used as a default argument
class Screen {
  public:
    // bkground refers to the static member
    // declared LATER in the class definition
    Screen& clear(char = bkground);
  private:
    static const char bkground;
};
```

## Temporaries

- **"temporary"** aka **"temporary object"**

Examples when temporaries are **created** automatically by the compiler:

```cpp
double dval = 3.14;
const int &ri = dval;
```

is translated by the compiler like

```cpp
double dval = 3.14;
const int temp = dval;
const int &ri = temp;   // bind "ri" to the temporary "temp"
```

- This happens not only for type `int` temporaries but also for **class type** temporaries (given the class has a corresponding [converting constructor](#converting-constructor))
  - see `Sales_data::combine(const Sales_data &rhs)` call on p.295, 7.5.4
    - a temporary of type `const Sales_data &rhs` is created from a `string`

## Lifetimes

- object lifetimes are generally controlled using [RAII](#raii)
  - "RAII is a C++ programming technique which **binds** the **life cycle** of a **resource** that must be acquired before use to the **lifetime** of an object."

- **Global objects:** allocated at program start-up and destroyed when the program ends
- **Local, automatic objects:** created and destroyed when the block in which they are defined is entered and exited
- **Local static objects:**
  - [cppreference](https://en.cppreference.com/w/cpp/language/storage_duration#Static_local_variables)
  - allocated before their first use ("are initialized the first time control passes through their declaration")
  - and are destroyed when the program ends ("The destructor for a block-scope static variable is called at program exit, but only if the initialization took place successfully.")
- **Dynamically allocated objects:** allocated at run time, ie. the program controls their lifetimes (they exist until they are explicitly freed); lifetime is independent of where they are created

# Functions

## inline functions

- A function specified as `inline` (usually) is expanded "in line" at each call. 
  - the word "usually" means that this expansion does not happen sometimes because the compiler can choose to ignore the `inline`! (see point below)
- inline functions may be defined multiple times in the program (unlike ordinary functions), but all definitions must match
  - therefore, inline functions normally are **defined in headers**
- `inline` removes the **run-time overhead** of using a normal function.
  - Explanation: **Calling** a function is likely to be slower than **evaluating** the equivalent expression.
    - On most machines, a **function call** does a lot of work:
      - Registers are saved before the call and restored after the return;
      - arguments may be copied; and
      - the program branches to a new location.
- The `inline` specification is only a **request** to the compiler.
  - The compiler may choose to ignore this request.
- In general, the inline mechanism is meant to optimize **small, straight-line functions that are called frequently**.
  - Many compilers will not inline a recursive function.
  - A 75-line function will almost surely not be expanded inline.
- 7.3.2: In practice, well-designed C++ programs tend to have lots of small (inline) functions such as `do_display`

## Default Arguments

- 6.5.1
- "A default argument is specified as an initializer for a parameter in the parameter list"
- Arguments in the call are resolved by position. The default arguments are used for the trailing (right-most) arguments of a call.
  - "if a parameter has a default argument, all the parameters that follow it must also have default arguments"
  - **general rule**: order the parameters so that those least likely to use a default value appear first!
- when re-declaring functions (recall, re-declaring functions is legal):
  - each parameter can have its default specified **only once**
  - defaults can be specified only if all parameters **to the right** already have defaults
  - **best practice**: Default arguments ordinarily should be specified with the function declaration in an appropriate header.
- changing the value of a default argument
  - you can **assign** a new default value to a default argument
  - do not try to change a default argument by "hiding" its name in a new scope (see the example in p. 237 and the corresponding explanation on p.238)

## return values

ignoring return values:
- "calling a function and ignoring the return result is *very* common", [stackoverflow](https://stackoverflow.com/a/38919156)
- `printf("hello\n");` ignores the return value, [stackoverflow](https://stackoverflow.com/a/38919103)

## static functions

- [stackoverflow](https://stackoverflow.com/a/15235626)

## member functions

- "member function bodies may use other members of their class regardless of where in the class those members appear" (see "compile order" in [Classes](#classes))
- "code is interpreted as being inside the scope of the class" (ie. eg. no need to use `this` to access members)

### implicit "this" parameter

- a `total.isbn()` call is translated like a `Sales_data::isbn(&total)` call
  - "the compiler passes the address of `total` to the implicit `this` parameter" (as if `Sales_data::isbn(Sales_data *const this)` were the function definition, see "passing_by_reference.c" - Listing 9.6)

### const member functions

"`const` member functions cannot change the object on which they are called."
- "The purpose of that `const` is to **modify the type of** the implicit `this` pointer." (see [this](#this))
  - **phth**: `this` is a `const` pointer, but the `const` following the parameter list makes it a pointer to `const` (see [pointer to const](#pointer-to-const))
  - "A `const` following the parameter list indicates that `this` is a pointer to `const`"

We can think of the `const` member 
```cpp
std::string isbn() const { return bookNo; }
```

as if it were written as
```cpp
// this code is illegal: we may not explicitly define the this pointer ourselves
std::string Sales_data::isbn(const Sales_data *const this) { return this->bookNo; }
```

[stackoverflow](https://stackoverflow.com/a/3141107)
- A "`const` function", denoted with the keyword `const` after a function declaration, makes it a compiler error for this class function to change a member variable of the class. However, reading of a class variables is okay inside of the function, but writing inside of this function will generate a compiler error.

### inline member functions

- member functions ...
  - defined inside the class: automatically inline
  - defined outside the class: need to specify as `inline`
  - declared inside the class: need to specify as `inline`
- inline member functions should be defined in the same header as the corresponding class definition (for the same reason as described for inline functions)
- it is legal to specify `inline` on both the declaration and the definition. 
  - **Best practice**: specifying `inline` only on the definition outside the class can make the class easier to read.

## Lambdas

From [learn.microsoft](https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170):
- In C++11 and later, a **lambda expression** - often called **a lambda** - is a convenient way of defining an anonymous function object (a closure) right at the location where it's invoked or passed as an argument to a function. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous functions.

## Return Value Optimization, RVO

### Return using Move instead of Copy

### Copy Elision

- for `return` statements: copy elision happens **in addition to** the "Move instead of Copy Trick" mentioned above

Initialization:
- a **copy** or **move constructor invocation** is often optimized away by constructing the object used to initialize right in the target object
  - among other things, this happens when copy or move constructors are invoked when functions `return` values (see [Copy Constructor](#copy-constructor), "called whenever ...")
- in the following example a compiler will typically construct the `X` from `make()` directly in `x`; thus eliminating ("eliding") a copy:

```cpp
X make(Sometype);   // create an "X" object named "make", calls the "X(Sometype)" constructor (defined in BS6.1.1)
X x = make(value);  // direct initialize "make" AND 
                    // copy initialize "x" (copying is not necessary because "make" was already created in "x")
```

Avoids Move Constructor Invocations:
- compiler is obliged (by the C++ standard) to eliminate most copies associated with initialization, so **move constructors** are not invoked
- eliminates (even) the very minor overhead of a move
- cppreference: "When the initializer is a prvalue, the move constructor call is often optimized out (...), see copy elision."

Does **not** avoid Move-Assignment Operator Invocations:
- The same is usually not possible for **assignments**.
  - ie. it is usually not possible to implicitly eliminate copy or move operations from assignments

# Classes

- "Classes are user-defined types, defined by class-specifier"
- The **class specifier** has the following syntax: 
  - `class-key attr(optional) class-head-name final(optional) base-clause(optional) { member-specification } 	`
- `class-key`
  - one of `class`, `struct` and `union`. 
    - The keywords `class` and `struct` are identical except for 
      - the default member access and
      - the default base class access.
    - If it is `union`, the declaration introduces a union type. 
- declaration of **objects**:
  - `class ClassName item1;` (inherited from C) is equivalent to `ClassName item1;`
- **forward declaration:** declare a class without defining it
  - **incomplete type:** After a declaration and before a definition is seen, the class type is an **incomplete type** - it's known that the type is a class type but not known what members that type contains
  - A class must be **defined** - not just declared - before
    - we can write code that **creates objects** of that type
    - a reference or pointer is used to **access a member** of the type
- a class 
  - **cannot** have data members of its own type
  - **can** have data members that are pointers or references to its own type

## Compile Order

compile order: **two steps** 

1) **member declarations**,
2) **member function bodies**, if any

## Class Types

### struct

- `struct` is a `class-key` (see above)
- when we define a class intending for all of its members to be `public`, we use `struct`. 
  - If we intend to have `private` members, then we use `class`.

From [stackoverflow](https://stackoverflow.com/a/1127406):
- In C++ the only difference between a `class` and a `struct` is that members and base classes are `private` by default in classes, whereas they are `public` by default in structs.
- So structs can have **constructors**, and the syntax is the same as for classes.

Why use `typedef struct`?

From [Why should we typedef a struct so often in C? - Stack Overflow](https://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c):
- no longer have to write `struct` all over the place
- can make the code cleaner since it provides a smidgen **more abstraction**

### union

- `union` is a `class-key` (see above)
- "A `union` is a special **class type** that can hold only one of its non-static data members at a time."
- like a "room in a hotel", [stackoverflow](https://stackoverflow.com/a/2313676)

## Constructors

- "Constructors do not have names" (`[class.ctor]`, N3337)
- "Classes control object **initialization** by defining one or more **special member functions** known as **constructors**."
- order:
  - 1) members are initialized in the [constructor initializer list](#constructor-initializer-list)
    - members **omitted** in the constructor initializer list are **default initialized** 
      - proofs: cppreference: 
        - in "Default Initialization": "3) when a base class or a non-static data member is not mentioned in a constructor initializer list and that constructor is called."
        - in "Constructors and member initializer lists": "The **member initializer list** is the place where **non-default initialization** of these (data member) objects can be specified.", implies that default initialization is the default behavior (for omitted data members)
  - 2) the constructor body is executed
    - members can be **assigned** in the constructor body, but they cannot be **initialized** there!
- Constructors 
  - have the same **name** as the class.
  - control 
    - object **initialization**
    - what happens when we **copy**, **assign**, or **destroy** objects of the class type
      - **copy**: 
        - when we initialize a variable or 
        - when we pass or return an object by value
      - **assign**: when we use the assignment operator
      - **destroy**: 
        - local object: destroyed on exit from the block in which it was created
        - Objects stored in a `vector` (or an array): destroyed when that `vector` (or array) is destroyed
      - If we do **not** define these operations, the compiler will **synthesize** them for us. 
        - the versions that the compiler generates for us execute by copying, assigning, or destroying **each member** of the object
        - **Warning:** "classes that manage dynamic memory, generally **cannot** rely on the synthesized versions of these operations"
          - but if you use `vector` and `string` to manage dynamic memory the synthesized versions for copy, assignment and destruction will work
  - are special member functions, but
    - have no return type
    - must not be declared as `const`
- a class may have multiple constructors (&rarr; overloading)
- can write to `const` objects during their construction

### Default Constructor

- "a constructor which can be called with no arguments" (cppreference)
- "called during 
  - **default initializations** and 
  - **value initializations**"
- 1) **explicitly defined default constructor**
- 2) **synthesized default constructor** (implicitly defined default constructor)
  - the compiler **implicitly** defines this constructor, if we do not explicitly define one
    - but **only if** a class declares **NO** constructors
  - member initialization
    - if there is an **in-class initializer**, use it to initialize the member
    - else **default initialize** the member
- situations in which we **must** explicitly define a default constructor:
  - 1. we have defined at least one constructor, and therefore, the compiler will not generate a default constructor
  - 2. to make sure that **class members** of **built-in types** or **compound types** cannot end up **uninitialized**
    - **in blocks**: objects of built-in or compound type that are defined inside a block have **undefined value** when they are default initialized (see ["Default Initialization"](#default-initialization))
  - 3. when the compiler cannot synthesize a default constructor
- `= default` keyword
  - C++11
  - we can ask the compiler to generate the constructor for us by writing `= default` after the parameter list
    - this constructor does exactly the same work as the synthesized default constructor
- best practice
  - "it is almost always right to provide a default constructor if other constructors are being defined."
- [default arguments](#default-arguments):
  - "A constructor that supplies default arguments **for all its parameters** also defines the default constructor." (7.5.1 "Default Arguments and Constructors")

### Constructor Initializer List

In cppreference: **"member initializer list"**
- "The body of a function definition of any constructor, before the opening brace of the compound statement (see [statements](#statements)), may include the **member initializer list**, whose syntax is the colon character `:`, followed by the comma-separated list of one or more member-initializers, each of which has the following syntax ..."
- "Before the compound statement that forms the function body of the constructor begins executing, initialization of all direct bases, virtual bases, and non-static data members is finished. The **member initializer list** is the place where **non-default initialization** of these objects can be specified."
  - thus, all members omitted in the member initializer list are **default initialized**

Omitted Members:
- When a member is omitted from the constructor initializer list, it is implicitly initialized **using the same process as is used by the synthesized default constructor** (7.1.4 "Constructors" &rarr; "Constructor Initializer List")
  - **best practice:** 
    - constructors should "use an in-class initializer if one exists and gives the member the correct value", i.e. "constructors should not override in-class initializers"
    - **phth**: if there are no in-class initializers for a class **or** your compiler does not support in-class initializers, then **built-in types** must be explicitly initialized in the constructor initializer list (because otherwise they will be uninitialized, see "synthesized default constructor")
- "If we do not explicitly initialize a member in the constructor initializer list, that member is **default initialized** before the constructor body starts executing" (7.5.1 "Constructors Revisited" &rarr; "Constructor Initializer List")

Initialization vs Assignment:
- if you do not use constructor initializers, you do not **"initialize"** the members, but you **"assign"** values to the members (recall, in C++: assign != initialize) (7.5.1 "Constructors Revisited" &rarr; "Constructor Initializer List")

When constructor initializer is **required**:
- "We **must** use the constructor initializer list to provide values for members that are ...
  - `const`, 
  - reference, or 
  - of a `class` type that does not have a default constructor."
- **best practice**: By routinely using constructor initializers, you can avoid being surprised by compile-time errors when you have a class with a member that **requires** a constructor initializer

**best practice**:
- order of member initialization
  - write constructor initializers in the same order as the members are declared. 
  - when possible, avoid using members to initialize other members.
  - write member initializers to use the constructor's parameters rather than another data member from the same object (see example in 7.5.1)

### Delegating Constructor

- "In a delegating constructor, the **member initializer list** has a single entry that is **the name of the class itself**. Like other member initializers, the name of the class is followed by a parenthesized list of arguments. The argument list must match another constructor in the class."

### Converting Constructor

- **Implicit Class-Type Conversion**
- "A constructor that can be called with a **single argument** defines an implicit conversion **from** the constructor's parameter type **to** the class type."
- **only one** implicit class type conversion is allowed (p.295)

#### explicit

- **disable** the implicit conversion by declaring the converting constructor as `explicit`
  - you can use `explicit` on constructors with **a single argument** only
  - use `explicit` only on the constructor declaration inside the class
  - `explicit` constructors can be used only with **direct initialization** (see Example 1)
    - because copy initialization triggers an implicit class type conversion which the `explicit` does not allow
- "use `explicit` for constructors that take a single argument unless there is a good reason not to" (BS6.1.2)

**Example 1**:

```cpp
Sales_data item1(null_book); // ok: direct initialization
// error: cannot use the copy form of initialization with an explicit constructor
Sales_data item2 = null_book;
```

**Example 2**:
- the `vector` constructor that takes a single size parameter is `explicit`

```cpp
void f(vector<int>); // f’s parameter is copy initialized
f(10); // error: can’t use an explicit constructor to copy an argument
f(vector<int>(10)); // ok: directly construct a temporary vector from an int
```

## Copy Control

- controlled by 5 **special member functions** ("copy-control members"):
  - copy constructor, 
  - copy-assignment operator, 
  - move constructor, 
  - move-assignment operator, and 
  - destructor
- "If a class does not define all of the copy-control members, the compiler **automatically defines** the missing operations"
  - **member-wise**: "the versions that the compiler generates for us execute by copying, assigning, or destroying **each member** of the object."

### Copy Constructor

- used for **initialization** (direct and copy forms), whereas the Copy-Assignment Operator is used for **assignment**

Lippman, 13.1.1 "The Copy Constructor"
- "A constructor is the copy constructor if 
  - its **first parameter** is a **reference to the class type** (eg. `T&`, `const T&`) and 
  - any **additional parameters** have default values"
- "almost always a reference to `const`" (although it can be a reference to nonconst)
- "the copy constructor usually should **not** be `explicit`" 
  - because it is often used for **implicit conversion** (see [converting constructor](#converting-constructor))

```cpp
class Foo {
public:
  Foo();             // default constructor
  Foo(const Foo&);   // copy constructor
  // ...
};
```

- "called whenever an object is initialized (by **direct-initialization** or **copy-initialization**) from another object of the same type, which includes"
  - **initialization**: `T a = b;` or `T a(b);`, where `b` is of type `T`;
  - **function argument passing**: `f(a);`, where `a` is of type `T` and `f` is `void f(T t);`
  - **function return**: `return a;` inside a function such as `T f()`, where `a` is of type `T`, which has no move constructor. 
- "the compiler is permitted (but not obligated) to skip the copy/move constructor and create the object directly" (see Example 1)

Example 1:

```cpp
string null_book = "9-999-99999-9"; // copy initialization
// may be rewritten to
string null_book("9-999-99999-9"); // compiler omits the copy constructor
```

#### Synthesized Copy Constructor

- for some classes disallows copying objects of that class type
- copies the members of its argument into the object being created **memberwise**
- unlike the synthesized default constructor, it is synthesized **even if** we define other constructors
- the synthesized constructor is **equivalent to** using a **constructor initializer list**, see example on p.497
- **always** uses **direct initialization**
  - if the synthesized copy constructor belongs to a `class` or `struct`, but not if it belongs to a `union`
  - **cppreference**: "For non-union class types (`class` and `struct`), the constructor performs full member-wise copy of the object's bases and non-static members, in their initialization order, using **direct initialization**."
- type of member determines how the member is copied
  - **class type**: copied by the class' copy constructor (using direct initialization)
  - **built-in type**: copied directly (direct initialization)
  - **array**: copied elementwise (using direct initialization)
- problem with pointer members:
  - see [Memberwise Assignment Example](https://www.cs.mtsu.edu/~xyang/2170/copyconstructor.html)
    - In class `StudentTestScores` the member `testScores` is a pointer. In `StudentTestScores student2 = student1;` `student2`'s `testScroes` member simply gets a **copy of the address** stored in `student1`'s `testScores` member. Both pointers will point to the same address.

### Copy-Assignment Operator

- "a (...) member function with the name `operator=` that takes **exactly one parameter** of type `T`, `T&`, `const T&`"

```cpp
class-name & class-name ::operator= ( const class-name & )   // (2)
```

- used for **assignment**, whereas the Copy Constructor is used for **initialization**
- "called whenever selected by overload resolution, e.g. when an object appears on the left side of an assignment expression"

#### Synthesized Copy-Assignment Operator

```cpp
T& T::operator=(const T&)
// or:
T& T::operator=(T&)
```

- for some classes disallows assignment
- analogue to synthesized copy constructor
- memberwise: **assign** each member of rhs object to lhs object (using copy-assignment operator for the type of that member)
  - arrays: elementwise
- returns a **reference to** its lhs object (via `return *this`)

### Valuelike Copy-Assignment Operator

- **combine** the actions of the **destructor** and the **copy constructor**
- must handle self-assignment
- must be exception safe
- a good pattern to use:

```cpp
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);  // copy the underlying string
  delete ps;                        // free the old memory
  ps = newp;                        // copy data from rhs into this object
  i = rhs.i;
  return *this;                     // return this object
}
```

### Destructor

```cpp
~ class-name ();
```

- "is the complement of a constructor" (BS5.2.2)
- "called when the lifetime of an object ends."
- "The purpose of the destructor is to free the resources that the object may have acquired during its lifetime."
- no return value
- takes no parameters
- order:
  - 1) function body is executed
    - typically, frees resources an object allocated during its lifetime
  - 2) (nonstatic) members are destroyed
    - in reverse order from the order in which they were initialized
- destruction part is **implicit**
  - cannot control how members are destroyed
    - whereas **for constructors** constructor initializer lists **can** control how members are initialized
- what happens when a member is destroyed:
  - **class type**: 
    - running the member's own destructor
  - **built-in types**:
    - do not have destructors, so nothing is done
  - **built-in pointer type**: 
    - does not `delete` the object to which that pointer points
      - **Note:** if you want to `delete` the object use **smart pointers** (which are class types)
- called when
  - **variables**: when they go out of scope
  - **members** of an object: when the object is destroyed
  - **elements of a container**: when a container is destroyed
  - **dynamically allocated objects**: `delete` is applied to a pointer to the object
  - **temporaries**: at the end of the creating expression
- not called when 
  - a **reference** to an object goes out of scope
  - a **pointer** to an object goes out of scope

#### Synthesized Destructor

- is automatically defined for any class that does not define its own destructor
- for some classes disallows destruction
- otherwise, the synthesized destructor has an empty function body
- members are automatically destroyed **AFTER** the (empty) destructor body is run
  - **Important**: Members are destroyed as part of the implicit destruction phase **that follows** the destructor body
- example
```cpp
// no work to do other than destroying the members, which happens automatically AFTER the destructor body
~Sales_data() { }   // equivalent to the synthesized `Sales_data` destructor
```

### Rule of Zero/Three/Five

- **Rule of Zero/Three/Five:** define all of the copy-control members or none (using the default for all)
  - it is unusual to need one without needing to define them all
- **rule 1**: "Classes That Need Destructors Need Copy and Assignment"
  - decide first whether the class needs a destructor (often more obvious than the need for copy constructor or assignment operator)
  - if the class needs a destructor, it almost surely needs a copy constructor and copy-assignment operator as well
- **rule 2**: "Classes That Need Copy Need Assignment, and Vice Versa"
- why these rules? &rarr; read examples in the book
- **rule 3**: "When a class has a pointer member, it is usually a good idea to be explicit about copy and move operations" (BS6.1.1)

### Moving Objects

- useful if
  - an object is immediately destroyed after it is copied
    - here, moving can provide a significant performance boost compared to copying
  - for classes that have a **resource** that may not be shared
    - Hence, objects of these types **cannot** be copied but can be moved
    - examples 
      - the IO classes (resource: an IO buffer)
      - `unique_ptr` class (resource: a pointer)
- copying is expensive if the objects
  - are large
  - themselves require memory allocation (e.g., `strings`)
- examples of classes that support 
  - move as well as copy: `string`, `shared_ptr`
  - move, but not copy: IO classes, `unique_ptr`
- [Rvalue References](#rvalue-references) were introduced by the new standard to support move operations

### Move Constructor

- "a non-template constructor whose first parameter is `T&&`, `const T&&`, (...) and either there are no other parameters, or the rest of the parameters all have default values"
- "The move constructor is typically called when an object is initialized (by **direct-initialization** or **copy-initialization**) from rvalue (xvalue or prvalue) (...) of the same type, including
  - **initialization**: `T a = std::move(b);` or `T a(std::move(b));`, where `b` is of type `T`;
  - **function argument passing**: `f(std::move(a));`, where a is of type `T` and `f` is `void f(T t);`
  - **function return**: `return a;` inside a function such as `T f()`, where a is of type `T` which has a move constructor."
- "Move constructors typically "steal" the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc.) rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state."

- 1st parameter is an **rvalue reference** to the class type
- additional parameters must all have default arguments (like for the copy constructor)
- must ensure that the moved-from object is left in a state such that destroying that object will be harmless
  - original object must no longer point to those moved resources
  - **phth:** eg. by resetting pointer members of the **moved-from** object (= the original object) to `nullptr`, otherwise, when the **moved-from** object gets destroyed, the destructor of the **moved-from** object will `delete` the memory to which the **moved-to** object's (= the copied object's) pointer members point
- unlike a copy constructor, the move constructor **does not** itself **allocate** any resources, it **takes over** resources
  - will not throw any exceptions

```cpp
StrVec::StrVec(StrVec &&s) noexcept // move won't throw any exceptions
  // member initializers take over the resources in s
  : elements(s.elements), first_free(s.first_free), cap(s.cap)
{
  // leave s in a state in which it is safe to run the destructor
  s.elements = s.first_free = s.cap = nullptr;
}
```

BS
- a move constructor is supposed to remove ("steal") the value from its argument.
- Examples
  - an integer returned by a function call is never used again, so you can safely "steal" its value/resources/state
- After a move, the moved-from object should be in a state that allows a **destructor** to be run

#### std::move

- explicitly casts an lvalue to its corresponding rvalue reference type
- in the `utility` header
- returns an rvalue reference to its given object
- **problem:** we cannot directly bind `rr1` to `&&rr2`
  - **solution:** we can explicitly cast `rr1` using `std::move`:

```cpp
int &&rr1 = 42;             // ok: literals are rvalues
int &&rr2 = rr1;            // error: the expression rr1 is an lvalue!
int &&rr3 = std::move(rr1); // ok
```

- after a call to `std::move` 
  - we **cannot** use 
    - `rr1`
    - the value of a moved-from object
  - we **can** 
    - assign to it
    - destroy it
- **best practice:** 
  - always call `std::move` not `move`
  - do not use `std::move` casually:
    - Casually used in ordinary user code (as opposed to class implementation code), moving an object is more likely to lead to mysterious and hard-to-find bugs than to any improvement in the performance of the application.
  - Outside of class implementation code such as **move constructors** or **move-assignment operators**, use `std::move` only when you are certain 
    - that you need to do a move and 
    - that the move is guaranteed to be safe
      - we must be absolutely certain that there can be no other users of the moved-from object

BS
- `std::move`
- doesn't actually move anything
- returns an **rvalue reference** (a reference to its argument from which we may move)
- it is a kind of cast

### Move-Assignment Operator

- A move assignment is defined similarly
  - it is supposed to remove the value from its argument

## Access Control and Encapsulation

- "encapsulate" the implementation = "hide" the implementation

### Access Specifiers

access Specifiers (to enforce encapsulation, i.e. hiding of implementation details)
- `public` members: defines the interface
- `private` members: encapsulate (i.e., hide) the implementation

The only difference between `struct` and `class` is the **default access level**:
- If we use the `struct` keyword, the members defined before the first access specifier are `public`
- if we use `class`, then the members are `private`

Best practice:
- When we define a class intending for all of its members to be `public`, we use `struct`. 
- If we intend to have `private` members, then we use `class`.

Benefits of Encapsulation:
- User code cannot inadvertently corrupt the state of an encapsulated object.
- The implementation of an encapsulated class can change over time without requiring changes in user-level code.

### Friends

- A class can allow another class or function to **access its nonpublic members** by making that class or function a `friend`
  - `friend` declarations 
    - may appear only inside a class definition
    - may appear anywhere in the class
  - `friend` function definitions
    - `friend` function can be **defined** inside the class body (7.3.4)
      - such functions are implicitly `inline`
- friends
  - are not members
  - are not affected by the access control of the section in which they are declared
- A friend declaration **is not a general declaration** of the function. 
  - we must also declare the function **separately** from the friend declaration (some compilers do not require this, but this is best practice)
  - **best practice**:
    - group `friend` declarations together at the beginning or end of the class definition
    - in addition to the `friend` declaration, declare each friend (outside the class) in the same header as the class
- friendship is not transitive

## Member Function

### Special Member Function

source: cppreference

**special member function:** Some member functions are **"special"**: under certain circumstances they are defined by the compiler even if not defined by the user. They are:
- Default constructor
- Copy constructor 
- Move constructor 
- Copy assignment operator 
- Move assignment operator 
- Destructor 

**defaulted function:** Special member functions are the only functions that can be **"defaulted"**, that is, defined using `= default` instead of the function body. 

### Functions that return *this

Such functions 
- return a **reference** to the object on which they are called
- are **lvalues**, which means that they return the object itself, **not a copy** of the object.

**Motivation**: Without such functions we cannot execute a **sequence** of operations **on the same object**, such as

```cpp
// move the cursor to a given position, and set that character
myScreen.move(4,0).set('#');
```

- you can also call a member function based on whether 

## Data Member

## Type Member

- a class can define its own (local) types
  - this type names may be either `public` or `private`
- unlike ordinary members, members that define types **must appear before they are used**
  - **best practice**: as a result, type members usually appear **at the beginning of the class**

## ::ClassName

[stackoverflow](https://stackoverflow.com/questions/4269034/what-is-the-meaning-of-prepended-double-colon)

This ensures that resolution occurs from the global namespace, instead of starting at the namespace you're currently in. For instance, if you had two different classes called `Configuration` as such:

```cpp
class Configuration; // class 1, in global namespace
namespace MyApp
{
    class Configuration; // class 2, different from class 1
    function blah()
    {
        // resolves to MyApp::Configuration, class 2
        Configuration::doStuff(...) 
        // resolves to top-level Configuration, class 1
        ::Configuration::doStuff(...)
    }
}
```

Basically, it allows you to traverse up to the global namespace since your name might get clobbered by a new definition inside another namespace, in this case `MyApp`.

# References

## Lvalue References

- aka **lvalue references**
- idea
  - Normally, when you use a reference, you do not use the address-of operator. You simply use the reference as you would use the target variable.
    - references are **aliases** for their target
  - enables the function to change the object being referred to

```cpp
int intOne;
int &rSomeRef = intOne;
intOne = 5;

// intOne: 5
// rSomeRef: 5
// &intOne: 0x3500
// &rSomeRef: 0x3500
```

- references (unlike other variables)
  - must be initialized when they are declared
  - cannot be reassigned
- space **before** the address-of operator is **required**
- usually "the type of a reference must match the type of the object to which it refers"
  - 2 exceptions:
    - 1) "we can initialize a reference to const from any expression that can be converted to the type of the reference" (see [reference to const](#reference-to-const))

### reference to const 

- aka "`const` reference", "lvalue reference to a `const` value"
- Unlike an ordinary reference, a reference to `const` cannot be used to change the object to which the reference is bound
- "we can **initialize** a reference to `const` from any expression that can be converted to the type of the reference"
  - we can bind a reference to `const` to 
    - a nonconst object, 
    - a literal, or 
    - a more general expression
    - an object of a different type (in this case, the reference is bound to a [temporary](#temporaries) object, see p.62)
- "Binding a reference to `const` to an object says nothing about whether the underlying object itself is `const`."
  - ie. the underlying object cannot be changed by using the reference to `const`, but it might be changed by other means
- binding a **non-const** reference to a [temporary](#temporaries) is illegal in C++, only **const** references may be bound to a temporary (see p.62)

## Rvalue References

- introduced by the new standard to support move operations
- a reference that must be bound to an rvalue
- obtained by using `&&`
- may be bound only to an object that is about to be destroyed
  - so that we are free to "move" resources from an rvalue reference to another object
- rvalue and lvalue references have the opposite **binding properties**:

```cpp
int i = 42;
int &r = i;             // ok: r refers to i
int &&rr = i;           // error: cannot bind an rvalue reference to an lvalue
int &r2 = i * 42;       // error: i * 42 is an rvalue
const int &r3 = i * 42; // ok: we can bind a reference to const to an rvalue
int &&rr2 = i * 42;     // ok: bind rr2 to the result of the multiplication
```

Examples of expressions that return
- lvalues
  - Functions that return lvalue references
  - operators
    - assignment
    - subscript
    - dereference
    - prefix increment/decrement (`++i`)
  - Variable expressions
- rvalues
  - Functions that return a nonreference type
  - operators
    - arithmetic
    - relational
    - bitwise
    - postfix increment/decrement (`i++`)
  - literals

- rvalue references refer to objects that are about to be destroyed
- **ephemeral** vs **persistent**: 
  - lvalues have persistent state, whereas **rvalues** are either **literals** or **temporary objects**
- code that uses an rvalue reference is free to take over value/resources/state from the object to which the reference refers
  - "steal" value/resources/state from the object (rhs) bound to an rvalue reference (lhs)
- you **cannot** directly bind an rvalue reference **to a variable**, even if that variable was defined as an rvalue reference type

```cpp
int &&rr1 = 42;         // ok: literals are rvalues
// Error:
int &&rr2 = rr1;        // error: the expression rr1 is an lvalue!
```

# Pointer

- A pointer is a **compound type** that "points to" another type. 
- Like references, 
  - pointers are used for **indirect access to other objects**. 
- Unlike a reference, 
  - a pointer is an object in its own right. 
  - a pointer need not be initialized at the time it is defined.
- Pointers can be **assigned** and **copied**
  - a single pointer can point to several different objects over its lifetime.
- pointers defined at **block scope** have **undefined value** if they are not initialized (like other built-in types)
- Each **pointer** is equal to the **address of the first byte** of the pointed-to variable (JA201)
  - The **address of a variable** is actually the address of the first (lowest) byte it occupies (JA201)
- **best practice:**
  - always initialize pointers

```cpp
double dval;
double *pd = &dval; // ok: initializer is the address of a double
// copy initialization of a pointer (more examples, see JA)
double *pd2 = pd;   // ok: initializer is a pointer to double
```

## delete

- Delete an array: `delete[] arrayName`
- Deleting a `nullptr` does not cause any change and no error.
- You cannot delete a pointer to a local stack allocated variable:
```cpp
int x;
int* ptr1 = &x;

// x is present on stack frame as
// local variable, only dynamically
// allocated variables can be destroyed
// using the delete operator
delete ptr1;

return 0;

// Output: Runtime error
```

## Nullpointer

- [Bjarne Stroustrup comment](https://www.stroustrup.com/bs_faq2.html#null)
- ([g++ doc](https://gcc.gnu.org/onlinedocs/libstdc++/manual/support.html#std.support.types.null))
- `NULL` ist definiert als [macro](https://gcc.gnu.org/onlinedocs/cpp/Macros.html) (i.e. a piece of code in a program that is replaced by the value of the macro; a macro is defined by `#define` directive; whenever a macro name is encountered by the [preprocessor](https://en.wikipedia.org/wiki/Preprocessor), it replaces the name with the definition of the macro): 
  - From [cppreference](https://en.cppreference.com/w/cpp/types/NULL):
    ```cpp
    #define NULL 0
    //since C++11
    #define NULL nullptr
    ```
  - dh `NULL` und `0` waren früher **dasselbe** [bis C++11] und jetzt sind `NULL` und `nullptr` **dasselbe** (aber how come [implicit cast difference](#implicit-cast-of-null-and-nullptr)?)
- "Unless you need to be compatible with C++98/C++03 or C you should prefer to use `nullptr` instead of `NULL`." ([g++ doc](https://gcc.gnu.org/onlinedocs/libstdc++/manual/support.html#std.support.types.null))

### Implicit Cast of NULL and nullptr

#### To Pointer Types

- `NULL` und `nullptr` beide implicitly convertible to any **pointer** type
  - A **null pointer** constant (see `NULL`), can be converted to any **pointer** type [i.e. type with asterisk `*`], and the result is the null pointer value of that type. ([cppreference](https://en.cppreference.com/w/cpp/language/implicit_conversion))

#### To Integral Types

- Unlike `NULL`, `nullptr` is **not** implicitly convertible or comparable to integral types [e.g. `int`, `char`] ([geeksforgeeks](https://www.geeksforgeeks.org/understanding-nullptr-c/))
  - `int x = NULL` geht; 
  - `int x = nullptr` geht **nicht**!
- `nullptr` is of type `nullptr_t`, which is implicitly convertible and comparable to any pointer type or pointer-to-member type. **It is not implicitly convertible or comparable to integral types** [e.g. `int`, `char`], **except for** `bool`. ([C++11](https://en.wikipedia.org/wiki/C%2B%2B11#Null_pointer_constant))

### Type of NULL and nullptr

In C++11 hat `NULL` den type `nullptr_t` 
- `nullptr_t` "is a distinct type that is not itself a pointer type or a pointer to member type." ([doc](https://en.cppreference.com/w/cpp/types/nullptr_t))

"In C, the macro `NULL` may have the type `void*`, but that is not allowed in C++." ([cppreference](https://en.cppreference.com/w/cpp/types/NULL))
- how come?: [stackoverflow](https://stackoverflow.com/a/69057243)
- soll heißen: `NULL` hat in C++ **absichtlich nicht (wie in C)** den Type `void*`, weil there is no **implicit cast** from `void*` to any other type in C++ (in C wäre das aber möglich!). Bis C++11 war `NULL` das [integer literal](https://en.cppreference.com/w/cpp/language/integer_literal) "`0`", konnte damit also einen der integer literal types (s. Tabelle in [integer literal](https://en.cppreference.com/w/cpp/language/integer_literal)) haben. Seit C++11 hat `NULL` den type `nullptr_t` ([doc](https://en.cppreference.com/w/cpp/types/nullptr_t)).

dh zB
```cpp
void* ptr = nullptr; 
int foo = *ptr;    // this implicit cast is not allowed in C++
```
gibt einen Compiler Error `error: ‘void*’ is not a pointer-to-object type` (**fix**: use a different type (a "pointer-to-object" type) instead of `void*` -  `void*` is a "pointer-to-nothing")

Aber 
```cpp
char* ptr = nullptr; 
int foo = *ptr;
```
gibt keinen Compiler Error, weil `char*` ein pointer-to-object type ist.

# Polymorphism

1. function **overloading**
2. templates
3. virtual functions ( **overriding** )

[source](https://www.geeksforgeeks.org/templates-cpp/)
- "Both function overloading and templates are examples of **polymorphism** features of OOP."
- function templates vs overloading: 
  - "Function overloading is used when multiple functions do quite similar (not identical) operations, templates are used when multiple functions do identical operations."

# Templates

- **instantiation**: The process that the compiler uses to create classes or functions from templates
- templates are **not** functions or classes
- templates "can be thought of as instructions to the compiler for generating classes or functions"
- templates can make the code shorter and more manageable

## Function Templates

**Function Template**:

[stackoverflow](https://www.cplusplus.com/doc/oldtutorial/templates/)

```cpp
// function template
#include <iostream>
using namespace std;

template <class T>
T GetMax (T a, T b) {
  T result;
  result = (a>b)? a : b;
  return (result);
}

int main () {
  int i=5, j=6, k;
  long l=10, m=5, n;
  k=GetMax<int>(i,j);
  n=GetMax<long>(l,m);
  cout << k << endl;
  cout << n << endl;
  return 0;
}
```

**Generic Type**: Function templates are special functions that can operate with **generic types**. This allows us to create a function template whose functionality can be adapted to more than one type or class without repeating the entire code for each type.

**Template Parameter**: In C++ this can be achieved using **template parameters**. A template parameter is a special kind of parameter that can be used to pass a type as argument: just like regular function parameters can be used to pass values to a function, template parameters allow to pass also types to a function. These function templates can use these parameters as if they were any other regular type.

## Class Templates

[source](https://www.geeksforgeeks.org/templates-cpp/):
- to create a single class to work with different data types
- useful when a class defines something that is independent of the data type. 
  - Can be useful for classes like LinkedList, BinaryTree, Stack, Queue, Array, etc.

```cpp
// C++ Program to implement
// template Array class
#include <iostream>
using namespace std;

template <typename T> class Array {
private:
    T* ptr;
    int size;

public:
    Array(T arr[], int s);
    void print();
};

template <typename T> Array<T>::Array(T arr[], int s)
{
    ptr = new T[s];
    size = s;
    for (int i = 0; i < size; i++)
        ptr[i] = arr[i];
}

template <typename T> void Array<T>::print()
{
    for (int i = 0; i < size; i++)
        cout << " " << *(ptr + i);
    cout << endl;
}

int main()
{
    int arr[5] = { 1, 2, 3, 4, 5 };
    Array<int> a(arr, 5);
    a.print();
    return 0;
}
```

### Containers

- each container is defined in a header file with the same name as the type
- containers are class templates (3.3)
- container types: see ["Types"](#types)

#### std::array

- "a container that encapsulates **fixed size** arrays"
- "an aggregate type"
- "same semantics as a `struct` holding a **C-style array** `T[N]` as its only non-static data member."
  - **But**: "Unlike a C-style array, it doesn't decay to `T*` automatically."

#### std::vector

- **flexible-size** array (as opposed to the **fixed-size** array `std::array`)
- `std::vector` is a template, not a type

#### std::string

- A specialized container that contains characters.
- similar to `vector`
- Convert to C-style string (null-terminated string)
  - `.c_str()` converts a string to a null-terminated string (C-style string), [stackoverflow](https://stackoverflow.com/questions/7416445/what-is-use-of-c-str-function-in-c) (s. Antwort von hkBattousai)

# Overloading vs Overriding

- overloading: the same function name, but with a different signature (i.e. name of the function, the parameter list, and the keyword `const`, if used)
- overriding: the same function name and the same signature

# Overloading

[stackoverflow](https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm)

**Function Overloading**, **Operator Overloading**: C++ allows you to specify more than one definition for a **function** name or an **operator** in the same scope, which is called **function overloading** and **operator overloading** respectively. 

**overloaded declaration**, **overload resolution**: An overloaded declaration is a declaration that is declared with the same name as a previously declared declaration in the same scope, except that both declarations have different arguments and obviously different definition (implementation). When you call an overloaded **function** or **operator**, the compiler determines the most appropriate definition to use, by comparing the argument types you have used to call the function or operator with the parameter types specified in the definitions. The process of selecting the most appropriate overloaded function or operator is called **overload resolution**.

# Overriding

- "**Overriding** a function means changing the implementation of a base class function in a derived class." (Day 12, J Liberty)

## "Normal" Overriding

- "When a derived class creates a function with the same return type and signature as a member function in the base class, but with a new implementation, it is said to be **overriding** that function. When you make an object of the derived class, the correct function is called." (Day 12, J Liberty)

## virtual

- C++ allows **pointers to base classes** to be assigned to derived class objects `BaseClass* pBase = new DerivedClass;` (Day 12, J Liberty)
  - `pBase` can invoke any method on `BaseClass`, but what we would like is for those methods that are overridden in `DerivedClass()` to call the correct function
- phth: "normal" overriding (cf. above) is possible **without** the `virtual` (see Day 12, J Liberty), but, if a pointer to the base class is assigned to the derived class object, and we use this pointer to call an overridden function, the overriding will not work

[source](https://www.programiz.com/cpp-programming/virtual-functions):
- A **virtual function** is a member function in the base class that we *expect* to redefine in derived classes.
- Basically, a virtual function is used in the base class in order to ensure that the function is **overridden**. This especially applies to cases where a pointer of base class points to an object of a derived class.

```cpp
// source: https://www.geeksforgeeks.org/virtual-functions-in-derived-classes-in-cpp/
// C++ Program to demonstrate Virtual
// functions in derived classes
#include <iostream>
using namespace std;

class A {
public:
	virtual void fun() { cout << "\n A::fun() called "; } 
};

class B : public A {
public:
	void fun() { cout << "\n B::fun() called "; }
};

class C : public B {
public:
	void fun() { cout << "\n C::fun() called "; }
};

int main()
{
	// An object of class C
	C c;

	// A pointer of class B pointing
	// to memory location of c
	B* b = &c;

	// this line prints "C::fun() called"
    // (Note: without the "virtual" in "class A" this line prints "\n A::fun() called ")
	b->fun();

	getchar(); // to get the next character
	return 0;
}
```

# Streams

A **stream** is a sequence of characters read from or written to an IO device. The term stream is intended to suggest that the characters are generated, or consumed, sequentially over time.

## iostream library

Defines the **types**: `istream` and `ostream`
Objects of type `istream`:
- `cin`
Objects of type `ostream`:
- `cout`
- `cerr`
- `clog`

## Buffer, Print Statements

**buffer**: A region of storage used to hold data. IO facilities often store input (or output) in a buffer and read or write the buffer independently from actions in the program. Output buffers can be explicitly flushed to force the buffer to be written. By default, reading cin flushes cout; cout is also flushed when the program ends normally.

```cpp
std::cout << "string" << std::endl
```

Writing `endl` has the effect of ending the current line and **flushing the buffer** associated with that device. Flushing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.
- **Best practice**: Programmers often add **print statements** during debugging. Such statements should **always flush the stream**. Otherwise, if the program crashes, output may be left in the buffer, leading to incorrect inferences about where the program crashed.

# Arrays

- An **array name without brackets** is a pointer to the array's first element (JA202)
  - You can also use the expression `&data[0]` to obtain the address of the array's first element (JA202)
  - The name of an array is a **pointer constant**; it can't be changed and remains fixed for the entire time the program executes (JA202)
    - You can, however, declare a pointer variable and initialize it to point at the array:

```cpp
int array[100], *p_array;
/* additional code goes here */
p_array = array;
```

# Vectors

- elements are stored contiguously
- how a `vector` grows
  - Vectors typically allocate capacity beyond what is immediately needed.
  - The container holds this **storage in reserve** and uses it to allocate new elements **as they are added**.
    - Thus, there is **no need to reallocate** ("`vector` zu einem Ort umlagern wo mehr Platz ist") the container each time an element is added
  - dramatically more efficient than reallocating the container each time an element is added
- container size management:
  - container size management functions, see Table 9.10
    - `c.shrink_to_fit()`: Request to reduce `capacity()` to equal `size()`
    - `c.capacity()`: Number of elements `c` can have before reallocation is necessary.
    - `c.reserve(n)`: Allocate space for at least `n` elements.
  - vector `size`: number of elements the vector already holds
  - vector `capacity`: how many elements it can hold before more space must be allocated

## Element Access

`front`
- "Returns a **reference to** the first element in the container."
- "Calling front on an empty container causes undefined behavior."

`back`
- "Returns a **reference to** the last element in the container."
- "Calling back on an empty container causes undefined behavior."

`push_back`
- "Appends the given element value to the end of the container"
- "If the new `size()` is greater than `capacity()` then all iterators and references (including the `end()` iterator) are invalidated. Otherwise only the end() iterator is invalidated."

`pop_back`
- "Removes the last element of the container."
- "Calling `pop_back` on an empty container results in undefined behavior."
- "Iterators and references to the last element, as well as the end() iterator, are invalidated."

# Strings

- **string literals** are not standard library `strings`
- elements are stored contiguously
- how a `string` grows
  - Strings typically allocate capacity beyond what is immediately needed. (like `vector`)

`string::size_type`
- a **companion type**
  - companion types make it possible to use the library types in a machine-independent manner
- an unsigned type
- big enough to hold the size of any `string`
- tedious to type `string::size_type` &rarr; use `auto` or `decltype`

# Iterators

Generic programming:
- **Best practice:** C++ programmers
  - use `!=` rather than `<`
    - because only a few library types have the `<` operator
  - use `!=` as a matter of habit
  - use iterators rather than subscripts
    - because only a few library types have the subscript operator

# Dynamic Memory

- managed through
  - `new`: 
    - allocates, and optionally initializes, an object in dynamic memory 
    - returns a pointer to that object
  - `delete`
    - takes a pointer to a dynamic object,
    - destroys that object,
    - frees the associated memory
- by default, dynamically allocated objects are **default initialized**
  - built-in or compound type: undefined value
  - class type: default constructor
- we can also use
  - direct initialization
  - value initialization
- **Best practice:** always initialize dynamically allocated objects
```cpp
// default initialization
string *ps = new string; // initialized to empty string
int *pi = new int; // pi points to an uninitialized int

// (forms of) direct initialization:
// traditional:
int *pi = new int(1024); // object to which pi points has value 1024
string *ps = new string(10, '9'); // *ps is "9999999999"
// list initialization (direct-list-initialization)
vector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9}; // vector with ten elements with values from 0 to 9

// value initialization:
string *ps1 = new string; // default initialized to the empty string
string *ps = new string(); // value initialized to the empty string
int *pi1 = new int; // default initialized; *pi1 is undefined
int *pi2 = new int(); // value initialized to 0; *pi2 is 0

// const objects:
const int *pci = new const int(1024);   // allocate and initialize a const int
const string *pcs = new const string;   // allocate a default-initialized const empty string
// - recall, const objects MUST be initialized
// - pci and pcs are "pointers to const"
```

## Memory Exhaustion and Exceptions

Memory Exhaustion:
- by default, if `new` is unable to allocate the requested storage, it throws an **exception** of type `bad_alloc` (defined in the `new` header)

Prevent throwing an exception:
- **placement new:** a placement new lets us pass additional arguments to `new`
- to prevent `new` from throwing an exception pass an object named `nothrow` (defined in the `new` header):
  - if unable to allocate the requested storage, this form of `new` will return a null pointer

```cpp
// if allocation fails, new returns a null pointer
int *p1 = new int;              // if allocation fails, new throws std::bad_alloc
int *p2 = new (nothrow) int;    // if allocation fails, new returns a null pointer
```

## Smart Pointers

- "Smart pointers enable automatic, exception-safe, object lifetime management."
- a smart pointer acts **like a regular pointer** with the important exception that it **automatically deletes** the object to which it points
- defined in `memory` header
- `shared_ptr`: allows multiple pointers to refer to the same object
  - `weak_ptr`: companion class, a weak reference to an object managed by a `shared_ptr`
- `unique_ptr`: "owns" the object to which it points

### `shared_ptr` class

- smart pointers are **templates** (ie must supply type in angle brackets)
- **default initialized** smart pointer hold a **null pointer**
- examples
```cpp
shared_ptr<string> p1;  // shared_ptr that can point at a string
shared_ptr<list<int>> p2; // shared_ptr that can point at a list of ints
// if p1 is not null, check whether it's the empty string
if (p1 && p1->empty())
  *p1 = "hi"; // if so, dereference p1 to assign a new value to that string
```

#### `make_shared`

- `make_shared<type>(args)` (non-member function template of `std::shared_ptr`)
  - allocates and initializes an object in dynamic memory
  - returns a `shared_ptr` that points to that object
  - if we do not pass any arguments, then the object is **value initialized**

1) Constructs an object of type `T` and wraps it in a `std::shared_ptr` using `args` as the parameter list for the constructor of `T`.
```cpp
template< class T, class... Args >
shared_ptr<T> make_shared( Args&&... args );
```

- examples
```cpp
// shared_ptr that points to an int with value 42
shared_ptr<int> p3 = make_shared<int>(42);
// p4 points to a string with value 9999999999
shared_ptr<string> p4 = make_shared<string>(10, '9');
// p5 points to an int that is value initialized (§ 3.3.1 (p. 98)) to 0
shared_ptr<int> p5 = make_shared<int>();

// ordinarily we use auto:
// p6 points to a dynamically allocated, empty vector<string>
auto p6 = make_shared<vector<string>>();
```

- keeps track of how many other `shared_ptrs` point to the same object
- **reference count** (aka "use count"):
  - is **incremented** when we
    - copy a `shared_ptr`
    - use a `shared_ptr` to initialize another `shared_ptr`, 
    - use a `shared_ptr` as the right-hand operand of an assignment, 
    - pass it to a function
    - return it from a function by value
  - is **decremented** when
    - we assign a new value to the `shared_ptr`
    - the `shared_ptr` itself is destroyed
      - such as when a local `shared_ptr` goes out of scope
  - Once a `shared_ptr`'s counter goes to zero, the `shared_ptr` automatically frees the object that it manages
  - Note: The reference count does not have to be a counter. Some other data structure may be used. This is up to the implementation.
```cpp
auto p = make_shared<int>(42); // object to which p points has one user
auto q(p); // p and q point to the same object
// object to which p and q point has two users
auto r = make_shared<int>(42); // int to which r points has one user
r = q; // assign to r, making it point to a different address
// increase the use count for the object to which q points
// reduce the use count of the object to which r had pointed
// the object r had pointed to has no users; that object is automatically freed
```

- automatically destroys the object to which that `shared_ptr` points via the `shared_ptr` **destructor** (the destructor of the `shared_ptr` class)
- the destructor of the `shared_ptr` class
  - frees the resources that an object has allocated (all destructors do this)
  - decrements the reference count of the object to which that `shared_ptr` points

### `unique_ptr` class

### `weak_ptr` class

## RAII

- [cppreference: raii](https://en.cppreference.com/w/cpp/language/raii)
- "Resource Acquisition Is Initialization"
  - resources ("anything that exists in limited supply")
    - allocated heap memory (here: acquisition = allocation)
    - thread of execution
    - open socket
    - open file
    - locked mutex
    - disk space
    - database connection
- aka
  - Constructor Acquires, Destructor Releases (CADRe)
  - Scope-Bound Resource Management (SBRM) (for the special case of automatic variables)
    - name because of "the basic use case where the lifetime of an RAII object ends due to scope exit"
- RAII guarantees that 
  - the resource is available to any function that may access the object (resource availability is a **class invariant**, eliminating redundant runtime tests). 
  - all resources are released when the lifetime of their controlling object ends, in reverse order of acquisition. 
  - Likewise, **if resource acquisition fails** (the constructor exits with an exception), all resources acquired by every fully-constructed member and base subobject are released in reverse order of initialization.

BS5.2.2
- The technique of 
  - acquiring resources in a constructor and 
  - releasing them in a destructor
- basis for most C++ general resource management techniques
  - very commonly used to manage **data that can vary in size** during the lifetime of an object
- allows us to eliminate 
  - "naked `new` operations"
    - that is, to avoid allocations in general code and keep them buried inside the implementation of well-behaved abstractions
  - "naked `delete` operations"
  - Avoiding naked `new` and naked `delete` makes code 
    - far less error-prone and 
    - far easier to keep free of resource leaks

Wikipedia
- In RAII
  - holding a resource is a class [invariant](#invariants), and is tied to object [lifetime](#lifetimes)
  - resource **allocation** (or acquisition) is done during object creation (specifically **initialization**), by the **constructor**
  - resource **deallocation** (release) is done during object destruction (specifically finalization), by the **destructor**
  - In other words, resource acquisition must succeed for initialization to succeed.

# Error Handling

## Invariants

BS4.3
- "invariant" aka "class invariant"
- "a statement of what is assumed to be true for a class"
  - eg. for `Vector`, the statement "`elem` points to an array of `sz` doubles" is an invariant 
    - nothing `Vector` does makes any sense unless the members of `Vector` have reasonable values
- job of a **constructor**: establish the invariant for its class (so that the member functions can rely on it)
- job of the **member functions**: make sure that the invariant holds when the member functions exit

# argc, argv

[stackoverflow](https://stackoverflow.com/questions/3024197/what-does-int-argc-char-argv-mean)

# Debugging

see "C notes"

tools:
- gdb
- valgrind

# Unit Testing

## Best Practices

- [Unit Testing Basics](https://www.jetbrains.com/help/clion/unit-testing-tutorial.html#basics)

## Test Runners

### ctest

`ctest` doesn't provide any testing macros/functions/classes on its own. It's just a **test runner**.

[Why useful?](https://www.reddit.com/r/cpp/comments/iwbdx7/is_ctest_worth_the_effort/):
- "**CTest** is useful for running multiple types of tests. You might have unit tests for C++ in **Catch2**, unit tests for python bindings in **pytest**, and you might have application-level testing that runs you program with specified arguments in a short **shell script**. CTest is the place to wire all these frameworks together so you can run all your testing in one shot. It works well for that."
- "And since I haven't seen it mentioned, the big C++ unit testing frameworks can integrate with CTest so you can see the pass/fail status of each test run by the framework"

## Test Frameworks

### Catch2

catch2 vs gtest:
- [snorristurluson.github.io](https://snorristurluson.github.io/Catch2/)
- [anteru.net](https://anteru.net/blog/2017/from-google-test-to-catch/)

### GoogleTest, gtest

- based on the **xUnit** architecture

#### Build

To see some **gtest samples**:
- build as [Standalone CMake Project](https://github.com/google/googletest/tree/main/googletest#standalone-cmake-project)

Build method used in AdvCpp course: 
- build by [Incorporating Into An Existing CMake Project](https://github.com/google/googletest/tree/main/googletest#incorporating-into-an-existing-cmake-project)
  - "Use CMake to download GoogleTest as part of the build's configure step. This approach doesn't have the limitations of the other methods." 

Just add to your `CMakeLists.txt` (CMake 3.14 or later):
```cmake
include(FetchContent)
FetchContent_Declare(
  googletest
  # Specify the commit you depend on and update it regularly.
  URL https://github.com/google/googletest/archive/5376968f6948923e2411081fd9372e71a59d8e77.zip
)
# For Windows: Prevent overriding the parent project's compiler/linker settings
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(googletest)

# Now simply link against gtest or gtest_main as needed. Eg
add_executable(example example.cpp)
target_link_libraries(example gtest_main)
add_test(NAME example_test COMMAND example)
```
