---
title: "C++ Notes"
read_time: false
excerpt: "For learning C++"
header:
    teaser: /assets/images/Cpp_logo.png
    overlay_image: /assets/images/Cpp_logo.png
    overlay_filter: 0.5 
toc: true
toc_label: "Contents"
toc_sticky: true
categories:
    - Notes
tags:
    - c++
    - notes

---

# DEFINITIONS

## areas of memory

- **stack** - Local variables, function parameters 
- **code space** - Code
- **global namespace** - global variables 
- **registers** - used for internal housekeeping functions, such as keeping track of the top of the stack and the instruction pointer
- **free store = heap** - Just about all of the remaining memory 

## Expressions, literals

[https://en.cppreference.com/w/cpp/language/expressions](https://en.cppreference.com/w/cpp/language/expressions)

- **expression** := sequence of **operators** and their **operands**, that specifies a computation.

- **primary expression** := literals, Id-expressions, lambda-expressions, fold-expressions, requires-expressions
  - **literals** := the tokens of a C++ program that represent **constant** values ( = Konstanten ) (dh alle Zeichen, die man "nicht ändern kann") 
    - **integer literals** (eg `1`, `2`, `3`, ...)
    - **character literals** (eg einzelne Buchstaben)
    - **boolean literals** (`true` und `false`)
    - **nullptr** (Merke: `nullptr` ist ein **literal**!)

- C++ **expression properties**: "*each C++ expression is characterized by two independent properties*"
  - **type**
  - **Value categories:**
    - **Primary categories:**
      - **prvalue expression** (eg literals (s.o.), arithmetic expressions [`+`,`-`,`%`,...], ...)
      - **xvalue expression**
      - **lvalue expression**
    - **Mixed categories:**
      - **glvalue expression**
      - **rvalue expression**

# Include Syntax

Usual practice is to use the `#include "local.h"` form for headers inside a `library/package/module`, and the `#include <external.h>` form for headers from `external/3rd-party` or system libraries.

# The "using" keyword

Using the namespace designation is **good form** because, if you use `using namespace some_namespace`, you run the risk of inadvertently using objects from the wrong library. This takes some **effort to fix**, whereas using the namespace designation cannot lead to such conflicts (see [example](https://stackoverflow.com/a/1452738)). I.e. from a **maintenance** perspective using the namespace designation is **best practice**.

# Variables/Objects

"A region of memory that can contain data and has a type."

C++ programmers use the terms "variable" and "object" interchangeably.

## Types

- primitive types (aka "built-in types")
  - arithmetic types
    - integral types (`char`, `int`, `bool`)
    - floating-point types (`float`, `double`)
  - `void`
- non-primitive types
  - class types
  - library types (e.g. `string`, `istream`, `ostream`)
  - compound types (2.3 "a type that is defined in terms of another type")
    - pointer types
    - reference types
    - array types
    - container types (9)
      - sequential (full list, see table 9.1) ("element order corresponds to the position at which elements are put into the container")
        - `string`
        - `array`
        - `vector`
        - linked lists
          - `list` (doubly linked)
          - `forward_list` (singly linked)
      - associative ("store elements based on the value of a key")
      - unordered

## Initialization

- in C++: initialization != assignment
  - Initialization happens when a variable is given a value **when it is created**. 
  - Assignment obliterates an object's current value and replaces that value with a new one.

### List Initialization

- C++11
- initialization using **curly braces**
- The compiler will not let us list initialize variables of **built-in type** if the initializer might lead to the loss of information
```cpp
long double ld = 3.1415926536;

int a{ld}, b = {ld}; // error: narrowing conversion required
int c(ld), d = ld;   // ok: but value will be truncated
```

#### Where the form of initialization matters

examples 
- when we use the **copy initialization** form (i.e., when we use "="), we can supply only a single initializer; 
- when we supply an **in-class initializer**, we must either use copy initialization or use curly braces. 
- when we **supply a list of (vector) element values** we can only do this by using list initialization in which the initializers are enclosed in curly braces.
  - We cannot supply a list of initializers using parentheses:
```cpp
vector<string> v1{"a", "an", "the"}; // list initialization
vector<string> v2("a", "an", "the"); // error
```
 
### Default Initialization

When we do not initialize an object/variable.

Controlled by the **default constructor** (see ["Default Constructor"](#default-constructor)).

Default values:
- object of **built-in type**
  - outside a function (global scope): **0**
  - inside a function/block (local scope): **uninitialized/undefined** 
    - best practice: 
      - (in-class) initialize every built-in type object
      - provide a default constructor
- object of **class type**
  - value defined by the class
    - most classes supply a default value
    - some classes require that every object be explicitly initialized
- object of **compound type**
  - inside a function/block (local scope): **uninitialized/undefined**
    - best practice: 
      - (in-class) initialize every compound type object
      - provide a default constructor
 
### Copy Initialization

- using `=`
```cpp
string s1;            // default initialization; s1 is the empty string
string s2 = s1;       // s2 is a copy of s1
string s3 = "hiya";   // s3 is a copy of the string literal
```

### Direct Initialization

- when we omit the `=`
```cpp
string s4(10, ’c’);   // s4 is cccccccccc
```

### In-class Initialization

When we create objects, the in-class initializers will be used to initialize the data members. 

- "Initializer provided as part of the declaration of a class data member."
- C++11
- **Members without an initializer** are default initialized
- form: 
  - initializer in curly braces
  - initializer after a `=` sign 
  - **not:** initializer in parentheses

## Declaration vs Definition
 
- **"separate compilation"**: split programs into several files, each of which can be compiled independently.
- To support separate compilation, C++ distinguishes between declarations and definitions. 
  - A **declaration** makes a name known to the program. A file that wants to use a name defined elsewhere includes a declaration for that name. 
  - A **definition** creates the associated entity.
- A **variable declaration** specifies the type and name of a variable. 
- A **variable definition** is a declaration. 
  - In addition to specifying the name and type, a definition also **allocates storage** and may provide the variable with an **initial value**.
- Variables must be **defined exactly once** but can be **declared many times**.
- To use the same variable in multiple files, we must define that variable in one - and only one - file. Other files that use that variable must declare - but not define - that variable

### extern

- `extern`: To obtain a declaration that is **not** also a definition, we add the `extern` keyword and must not provide an explicit initializer.
- inside a function
  - It is an error to provide an initializer on an `extern` 
- outside a function 
  - we can initialize an `extern`, however, this overrides the `extern`. The `extern` becomes a definition in this case.

## Static typing

- C++ is a statically typed language, which means that **types are checked at compile time**. 
- The process by which types are checked is referred to as **type checking**.
- consequence of static typing: must declare the type of a variable before we can use that variable

## const objects

- may call only const member functions
- a `const` object does not assume its "constness" until after the constructor completes the object's initialization

# Classes

## Constructors

- special member functions, but
  - have no return type
  - must not be declared as `const`
- a class may have multiple constructors (overloading)
- can write to const objects during their construction

### Default Constructor

- takes no arguments
- either: **explicitly defined default constructor**
- or: **synthesized default constructor**
  - the compiler **implicitly** defines this constructor, if we do not explicitly define one
    - but **only if** a class declares **NO** constructors
  - member initialization
    - if there is an **in-class initializer**, use it to initialize the member
    - else **default initialize** the member
- when we **have to** explicitly define a default constructor
  - 1. we have defined at least one constructor, and therefore, the compiler will not generate a default constructor
  - 2. to make sure that **class members of built-in types** or compound types cannot end up uninitialized
    - **in function blocks**: objects of built-in or compound type that are defined inside a block have **undefined value** when they are default initialized (see ["Default Initialization"](#default-initialization))
    - **in class blocks**: the same problem arises for default initialized **members** of built-in type
  - 3. sometimes the compiler cannot synthesize a default constructor
- `= default` keyword
  - C++11
  - we can ask the compiler to generate the constructor for us by writing `= default` after the parameter list
    - this constructor does exactly the same work as the synthesized default constructor

### Constructor Initializer List

- When a member is omitted from the constructor initializer list, it is implicitly initialized **using the same process as is used by the synthesized default constructor**

## Access Control and Encapsulation

access Specifiers (to enforce encapsulation, i.e. hiding of implementation details)
- `public` members: defines the interface
- `private` members: encapsulate (i.e., hide) the implementation

The only difference between `struct` and `class` is the **default access level**:
- If we use the `struct` keyword, the members defined before the first access specifier are `public`
- if we use `class`, then the members are `private`

Best practice:
- When we define a class intending for all of its members to be `public`, we use `struct`. 
- If we intend to have `private` members, then we use `class`.

Benefits of Encapsulation:
- User code cannot inadvertently corrupt the state of an encapsulated object.
- The implementation of an encapsulated class can change over time without requiring changes in user-level code.

## Friends

- A class can allow another class or function to **access its nonpublic members** by making that class or function a `friend`
  - `friend` declarations 
    - may appear only inside a class definition
    - may appear anywhere in the class
  - friends
    - are not members
    - are not affected by the access control of the section in which they are declared
  - A friend declaration **is not a general declaration** of the function. 
    - we must also declare the function **separately** from the friend declaration (some compilers do not require this, but this is best practice)
- best practice: 
  - group friend declarations together at the beginning or end of the class definition
  - declare each friend (outside the class) in the same header as the class

# Containers

- each container is defined in a header file with the same name as the type
- containers are class templates (3.3)
- container types: see ["Types"](#types)

# Nullpointer: nullptr, NULL

## Definition

- [Bjarne Stroustrup comment](https://www.stroustrup.com/bs_faq2.html#null)
- ([g++ doc](https://gcc.gnu.org/onlinedocs/libstdc++/manual/support.html#std.support.types.null))
- `NULL` ist definiert als [macro](https://gcc.gnu.org/onlinedocs/cpp/Macros.html) (i.e. a piece of code in a program that is replaced by the value of the macro; a macro is defined by `#define` directive; whenever a macro name is encountered by the [preprocessor](https://en.wikipedia.org/wiki/Preprocessor), it replaces the name with the definition of the macro): 
  - From [cppreference](https://en.cppreference.com/w/cpp/types/NULL):
    ```cpp
    #define NULL 0
    //since C++11
    #define NULL nullptr
    ```
  - dh `NULL` und `0` waren früher **dasselbe** [bis C++11] und jetzt sind `NULL` und `nullptr` **dasselbe** (aber how come [implicit cast difference](#implicit-cast-of-null-and-nullptr)?)
- "Unless you need to be compatible with C++98/C++03 or C you should prefer to use `nullptr` instead of `NULL`." ([g++ doc](https://gcc.gnu.org/onlinedocs/libstdc++/manual/support.html#std.support.types.null))

## Implicit Cast of NULL and nullptr

### To Pointer Types

- `NULL` und `nullptr` beide implicitly convertible to any **pointer** type
    - A **null pointer** constant (see `NULL`), can be converted to any **pointer** type [i.e. type with asterisk `*`], and the result is the null pointer value of that type. ([cppreference](https://en.cppreference.com/w/cpp/language/implicit_conversion))

### To Integral Types

- Unlike `NULL`, `nullptr` is **not** implicitly convertible or comparable to integral types [e.g. `int`, `char`] ([geeksforgeeks](https://www.geeksforgeeks.org/understanding-nullptr-c/))
    - `int x = NULL` geht; 
    - `int x = nullptr` geht **nicht**!
- `nullptr` is of type `nullptr_t`, which is implicitly convertible and comparable to any pointer type or pointer-to-member type. **It is not implicitly convertible or comparable to integral types** [e.g. `int`, `char`], **except for** `bool`. ([C++11](https://en.wikipedia.org/wiki/C%2B%2B11#Null_pointer_constant))

## Type of NULL and nullptr

- "In C, the macro `NULL` may have the type `void*`, but that is not allowed in C++." ([cppreference](https://en.cppreference.com/w/cpp/types/NULL))
    - how come?: [stackoverflow](https://stackoverflow.com/a/69057243)
    - soll heißen: `NULL` hat in C++ **absichtlich nicht (wie in C)** den Type `void*`, weil there is no **implicit cast** from `void*` to any other type in C++ (in C wäre das aber möglich!). Bis C++11 war `NULL` das [integer literal](https://en.cppreference.com/w/cpp/language/integer_literal) "`0`", konnte damit also einen der integer literal types (s. Tabelle in [integer literal](https://en.cppreference.com/w/cpp/language/integer_literal)) haben. Seit C++11 hat `NULL` den type `nullptr_t` ([doc](https://en.cppreference.com/w/cpp/types/nullptr_t)).  
      (dh zB
      ```cpp
      void* ptr = nullptr; 
      int foo = *ptr;    // this implicit cast is not allowed in C++
      ```
      gibt einen Compiler Error `error: ‘void*’ is not a pointer-to-object type`   
      (**fix**: use a different type (a "pointer-to-object" type) instead of `void*` -  `void*` is a "pointer-to-nothing")   
      Aber 
      ```cpp
      char* ptr = nullptr; 
      int foo = *ptr;
      ```
      gibt keinen Compiler Error, weil `char*` ein pointer-to-object type ist.)

# Templates

## SYNTAX

**Function Template**:	(phth: besser als overloading, weil man nicht x mal dieselbe Funktion definieren muss)

[stackoverflow](https://www.cplusplus.com/doc/oldtutorial/templates/)
```cpp
// function template
#include <iostream>
using namespace std;

template <class T>
T GetMax (T a, T b) {
  T result;
  result = (a>b)? a : b;
  return (result);
}

int main () {
  int i=5, j=6, k;
  long l=10, m=5, n;
  k=GetMax<int>(i,j);
  n=GetMax<long>(l,m);
  cout << k << endl;
  cout << n << endl;
  return 0;
}
```
Function templates are special functions that can operate with **generic types**. This allows us to create a function 
template whose functionality can be adapted to more than one type or class without repeating the entire code for each type.

In C++ this can be achieved using **template parameters**. A template parameter is a special kind of parameter that 
can be used to pass a type as argument: just like regular function parameters can be used to pass values to a function, 
template parameters allow to pass also types to a function. These function templates can use these parameters as if 
they were any other regular type.

# Overloading

[stackoverflow](https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm)

C++ allows you to specify more than one definition for a **function** name or an **operator** in the same scope, which is called **function overloading** and **operator overloading** respectively. 

An overloaded declaration is a declaration that is declared with the same name as a previously declared declaration in the same scope, except that both declarations have different arguments and obviously different definition (implementation). When you call an overloaded **function** or **operator**, the compiler determines the most appropriate definition to use, by comparing the argument types you have used to call the function or operator with the parameter types specified in the definitions. The process of selecting the most appropriate overloaded function or operator is called **overload resolution**.

# Double Colon prepended to the class name

[stackoverflow](https://stackoverflow.com/questions/4269034/what-is-the-meaning-of-prepended-double-colon)
This ensures that resolution occurs from the global namespace, instead of starting at the namespace you're currently in. For instance, if you had two different classes called "**Configuration**" as such:
```cpp
class Configuration; // class 1, in global namespace
namespace MyApp
{
    class Configuration; // class 2, different from class 1
    function blah()
    {
        // resolves to MyApp::Configuration, class 2
        Configuration::doStuff(...) 
        // resolves to top-level Configuration, class 1
        ::Configuration::doStuff(...)
    }
}
```
Basically, it allows you to traverse up to the global namespace since your name might get clobbered by a new definition inside another namespace, in this case "**MyApp**".

# argc, argv

[stackoverflow](https://stackoverflow.com/questions/3024197/what-does-int-argc-char-argv-mean)

# Strings

## Convert to null-terminated string

`.c_str()` converts a string to a null-terminated string (C-style string)

[stackoverflow](https://stackoverflow.com/questions/7416445/what-is-use-of-c-str-function-in-c) (s. Antwort von hkBattousai)

## Format Specifiers

e.g. `%d`, `%f`, `%.3f`

[stackoverflow](https://www.cprogramming.com/tutorial/printf-format-strings.html)

# typedef struct

[Why should we typedef a struct so often in C? - Stack Overflow](https://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c)

# Lambdas

From [learn.microsoft](https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170):
- In C++11 and later, a **lambda expression** - often called **a lambda** - is a convenient way of defining an anonymous function object (a closure) right at the location where it's invoked or passed as an argument to a function. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous functions.

# Functions

## const member functions

A "const function", denoted with the keyword `const` after a function declaration, makes it a compiler error for this class function to change a member variable of the class. However, reading of a class variables is okay inside of the function, but writing inside of this function will generate a compiler error. [stackoverflow](https://stackoverflow.com/a/3141107)

"const member functions cannot change the object on which they are called."
- The purpose of that `const` is to modify the type of the implicit `this` pointer.

## inline functions

- A function specified as `inline` (usually) is expanded "in line" at each call. 
  - "usually" because the compiler can choose to ignore the `inline`! (see point below)
- inline functions may be defined multiple times in the program (unlike ordinary functions), but all definitions must match
  - therefore, inline functions normally are **defined in headers**
- `inline` removes the **run-time overhead** of using a normal function 
  - **Calling** a function is likely to be slower than **evaluating** the equivalent expression. 
    - On most machines, a **function call** does a lot of work: 
      - Registers are saved before the call and restored after the return; 
      - arguments may be copied; and 
      - the program branches to a new location.
- The inline specification is only a **request** to the compiler. 
  - The compiler may choose to ignore this request. 
- In general, the inline mechanism is meant to optimize **small, straight-line functions that are called frequently**. 
  - Many compilers will not inline a recursive function.
  - A 75-line function will almost surely not be expanded inline.

### inline member functions

- member functions ...
  - defined inside the class: automatically inline
  - defined outside the class: need to specify as `inline`
  - declared inside the class: need to specify as `inline`
- inline member functions should be defined in the same header as the corresponding class definition (for the same reason as described for inline functions)
- it is legal to specify `inline` on both the declaration and the definition. 
  - Best practice: specifying `inline` only on the definition outside the class can make the class easier to read.

# Debugging

see "C notes"

tools:
- gdb
- valgrind

# Unit Testing

## Best Practices

- [Unit Testing Basics](https://www.jetbrains.com/help/clion/unit-testing-tutorial.html#basics)

## GoogleTest, gtest

- based on the **xUnit** architecture

### Build

To see some **gtest samples**:
- build as [Standalone CMake Project](https://github.com/google/googletest/tree/main/googletest#standalone-cmake-project)

Build method used in AdvCpp course: 
- build by [Incorporating Into An Existing CMake Project](https://github.com/google/googletest/tree/main/googletest#incorporating-into-an-existing-cmake-project)
  - "Use CMake to download GoogleTest as part of the build's configure step. This approach doesn't have the limitations of the other methods." 

Just add to your `CMakeLists.txt` (CMake 3.14 or later):
```cmake
include(FetchContent)
FetchContent_Declare(
  googletest
  # Specify the commit you depend on and update it regularly.
  URL https://github.com/google/googletest/archive/5376968f6948923e2411081fd9372e71a59d8e77.zip
)
# For Windows: Prevent overriding the parent project's compiler/linker settings
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(googletest)

# Now simply link against gtest or gtest_main as needed. Eg
add_executable(example example.cpp)
target_link_libraries(example gtest_main)
add_test(NAME example_test COMMAND example)
```
