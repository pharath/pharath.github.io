---
title: "C++ Notes"
read_time: false
excerpt: "For learning C++"
header:
    teaser: /assets/images/Cpp_logo.png
    overlay_image: /assets/images/Cpp_logo.png
    overlay_filter: 0.5 
toc: true
toc_label: "Contents"
toc_sticky: true
categories:
    - Notes
tags:
    - c++
    - notes

---

# Standards

## C++11

- see p. xix "New Features in C++11"

# Definitions

## areas of memory

- **stack** - Local variables, function parameters 
- **code space** - Code
- **global namespace** - global variables 
- **registers** - used for internal housekeeping functions, such as keeping track of the top of the stack and the instruction pointer
- **free store = heap** - Just about all of the remaining memory 

## lvalue and rvalue

- **every expression in C++** is either an **lvalue** or an **rvalue**
- inherited from C 
  - in C: simple mnemonic purpose: lvalues could stand on the left-hand side of an assignment whereas rvalues could not
- in C++: Roughly speaking, 
  - when we use an object as an **rvalue**, we use the object's value (its contents). 
  - when we use an object as an **lvalue**, we use the object's identity (its location in memory).
- we can use an lvalue when an rvalue is required, but we cannot use an rvalue when an lvalue (i.e., a location) is required

## Type Properties

- ScalarType
  - "object types that are not array types or class types"
    - arithmetic types
    - enumeration types
    - pointer types
    - pointer-to-member types
    - `std::nullptr_t`
    - cv-qualified versions of these types
- PODType
  - detailed:
    - [C++98/03](https://stackoverflow.com/a/4178176/734069)
    - [C++11](https://stackoverflow.com/a/7189821/734069)
  - informal:
    - [types that are POD](https://stackoverflow.com/a/146589)
  - "POD (Plain Old Data) types, compatible with C `struct`"
  - "This means the type is compatible with the types used in the C programming language, that is, can be exchanged with C libraries directly, in its binary form."
    - scalar types
    - POD classes
    - arrays of such types
    - cv-qualified versions of these types

## Operators

- Operators differ as to whether they 
  - require lvalue or rvalue **operands**
  - **return** lvalues or rvalues

- the **scope** operator "`::`"
- the **output** operator "`<<`"
  - returns its left-hand operand
- the **input** operator "`>>`"
  - returns its left-hand operand
- [assignment operators](https://en.cppreference.com/w/cpp/language/operator_assignment) (`=`)
  - requires a (non`const`, ie. modifiable) lvalue as its left-hand operand 
  - yields its left-hand operand as an lvalue
  - sub-categories:
    - copy assignment operator
    - move assignment operator
    - compound assignment operator (`+=`)
- arithmetic operators
  - addition operator (`+`)
- logical and relational operators
  - logical AND (`&&`)
  - less than (`<`)
- the call operator (`()`)
- increment operator "`++`"
- decrement operator "`--`"
- [member access operators](https://en.cppreference.com/w/cpp/language/operator_member_access)
  - subscript operator (`a[b]`)
    - "provides access to an object pointed-to by the pointer or array operand"
  - dereference/indirection operator (`*a`)
    - "provides access to an object or function pointed-to by the pointer operand"
  - address-of operator (`&a`)
    - "creates a pointer pointing to the object or function operand"
    - requires an lvalue operand
    - returns a pointer to its operand as an rvalue
  - member of object/dot operator (`a.b`)
    - "provide access to a data member or member function of the object operand"
    - returns the member named by the right-hand operand
  - member of pointer (`a->b`)
    - "provide access to a data member or member function of the class pointed-to by the pointer operand"

## Expressions, literals

source: [https://en.cppreference.com/w/cpp/language/expressions](https://en.cppreference.com/w/cpp/language/expressions)

- **expression** := sequence of **operators** and their **operands**, that specifies a computation.
- **primary expression** := literals, [id-expressions](https://www.ibm.com/docs/en/i/7.4?topic=expressions-identifier-c-only), lambda-expressions, fold-expressions, requires-expressions
  - **literals** := the tokens of a C++ program that represent **constant** values ( = Konstanten ) (dh alle Zeichen, die man "nicht ändern kann") 
    - **integer literals** (eg `1`, `2`, `3`, ...)
    - **character literals** (eg einzelne Buchstaben)
    - **boolean literals** (`true` und `false`)
    - **nullptr** (Merke: `nullptr` ist ein **literal**!)
- C++ expression **properties**: "*each C++ expression is characterized by two independent properties*"
  - **1. type**
  - **2. value category:**
    - **Primary categories:**
      - **prvalue expression** (eg literals (s.o.), arithmetic expressions [`+`,`-`,`%`,...], ...)
      - **xvalue expression**
      - **lvalue expression**
    - **Mixed categories:**
      - **glvalue expression**
      - **rvalue expression**

## Statements

- "fragments of the C program that are executed in sequence"
- 5 types
  - 1) compound statements (aka **block**)
    - "a brace-enclosed sequence of statements and declarations."
    - "Each compound statement introduces its own **block scope**."
  - 2) expression statements
    - "An expression followed by a semicolon is a statement."
  - 3) selection statements
  - 4) iteration statements
  - 5) jump statements

# Header Files

## Using C Headers in C++

- use the **C++ versions** of C library headers
  - Headers **in C** have names of the form `name.h`. The **C++ versions** of these headers are named `cname`.
  - **Warning:** names defined in the `cname` headers are defined inside the `std` namespace, whereas those defined in the `.h` versions are not

## Newline at EOF

It is good style to always put a newline at the end of text files (POSIX Standard), [stackoverflow](https://stackoverflow.com/questions/729692/why-should-text-files-end-with-a-newline)
- this is part of language standards:
  - in `C`: newline required at the end of header files
  - in `C++`: before `C++11`: newline required at the end of header files
  - "*No newline at end of file*" compiler warning, [stackoverflow](https://stackoverflow.com/questions/72271/no-newline-at-end-of-file-compiler-warning)
- in `git`: [stackoverflow](https://stackoverflow.com/questions/5813311/whats-the-significance-of-the-no-newline-at-end-of-file-log)

# Include Syntax

Usual practice is to use the `#include "local.h"` form for headers inside a `library/package/module`, and the `#include <external.h>` form for headers from `external/3rd-party` or system libraries.

Lippman, Lajoie, Moo: Headers from the **standard library** are enclosed in angle brackets (`< >`). Those that are not part of the library are enclosed in double quotes (`" "`).

# keywords

- see Table 2.3

## "using"

Using the namespace designation is **good form** because, if you use `using namespace some_namespace`, you run the risk of inadvertently using objects from the wrong library. This takes some **effort to fix**, whereas using the namespace designation cannot lead to such conflicts (see [example](https://stackoverflow.com/a/1452738)). I.e. from a **maintenance** perspective using the namespace designation is **best practice**.

## default

- explicitly-*defaulted* function definition: as an explicit instruction to the compiler to generate [special member function](special-member-function)

## auto

- tells the compiler to deduce the type from the initializer
  - thus, a variable that uses `auto` must have an initializer
- type that the compiler infers for `auto` is not always exactly the same as the initializer's type
  - eg. for 
    - references
      - compiler uses the referred object's type, and not the reference type
    - top-level `const`s
      - ignored

## decltype

- returns the type of its operand (like `auto`)

```cpp
decltype(f()) sum = x; // sum has whatever type f returns
```

- does not call `f`
- uses the type that such a call **would** return as the type for `sum`
- unlike `auto`, `decltype` returns the type of references and top-level `const`s
- `decltype((variable))` is always a reference type, whereas `decltype(variable)` is a reference type only if `variable` is a reference

# Variables aka Objects

"A region of memory that can contain data and has a type."

C++ programmers use the terms "variable" and "object" interchangeably.

## Types

- primitive types (aka **"built-in types"**)
  - arithmetic types
    - integral types (`char`, `int`, `bool`)
    - floating-point types (`float`, `double`)
  - `void`
- non-primitive types
  - **class types**
  - library types (e.g. `string`, `istream`, `ostream`)
  - compound types (2.3 "a type that is defined in terms of another type")
    - pointer types
    - reference types (2.3.1)
    - array types
    - container types (9)
      - sequential (full list, see table 9.1) ("element order corresponds to the position at which elements are put into the container")
        - `string` (see "C Notes")
        - `array`
        - `vector`
        - linked lists
          - `list` (doubly linked)
          - `forward_list` (singly linked)
      - associative ("store elements based on the value of a key")
      - unordered

## Initialization

- in C++: initialization != assignment
  - **Initialization** happens when a variable is given a value **when it is created**. 
  - **Assignment** obliterates an object's current value and replaces that value with a new one.

### Default Initialization

- "the initialization performed when an object is constructed with **no** initializer", i.e. `T object;` or `new T`
- "performed in three situations"
  - 1) when a variable (...) is declared with no initializer `T object;`
  - 2) when an object (...) is created by a `new`-expression with no initializer `new T`
  - 3) when a (...) data member is **not mentioned** in a **constructor initializer list** and that constructor is called
- if `T` is a **class type**, 
  - the constructors are considered and subjected to overload resolution against the empty argument list. 
  - The constructor selected (which is **one of** the **default constructors**) is called to provide the initial value for the new object; 
- if `T` is an **array type**, 
  - every element of the array is default-initialized; 
- otherwise, eg. **built-in type**, no initialization is performed

Examples:
- object of **built-in type**, **compound type** (eg. pointer to built-in type)
  - outside a block (global scope): **0**, **nullptr**
  - inside a block (local scope): **uninitialized/undefined** 
    - best practice: 
      - (in-class) initialize every built-in type object, compound type object
      - provide a default constructor
- object of **class type**
  - value defined by the class
    - some classes **require** that every object be explicitly initialized

### Value Initialization

- "the initialization performed when an object is constructed with an **empty** initializer", i.e. `T()` or `T{}` or `T object {};`
- performed in these situations
  - 1) when a nameless **temporary** object is created with the initializer consisting of an empty pair of parentheses `T()` or braces `T {}`;
  - 2) when an object with dynamic storage duration is created by a **new-expression** with the initializer consisting of an empty pair of parentheses `new T ()` or braces `new T {}`;
  - 3) when a non-static data member or a base class is initialized using a **member initializer** with an empty pair of parentheses `Class::Class(...) : member () { ... }` or braces `Class::Class(...) : member {} { ... }`;
  - 4) when a named object (automatic, static, or thread-local) is declared with the initializer consisting of a pair of braces. (since C++ 11)
- if `T` is a **class type** with a ...
  - "user-provided default constructor" **or** "no default constructor": the object is [default-initialized](#default-initialization);
  - "implicitly-defined" **or** "defaulted default constructor": all of the following 3 steps are performed in the following order:
    - 1) the object is [zero-initialized](#zero-initialization),
    - 2) the semantic constraints for default-initialization are checked, and 
    - 3) if `T` has a non-trivial default constructor, the object is default-initialized;
- if `T` is an **array type**, 
  - each element of the array is value-initialized;
- otherwise, eg. **built-in type**, the object is [zero-initialized](#zero-initialization).
- "References cannot be value-initialized"
- "All standard containers (`std::vector`, `std::list`, etc.) value-initialize their elements when constructed with a single `size_type` argument"
- Lippman p.132: "Initialization in which **built-in types** are initialized to zero and **class types** are initialized by the class's default constructor."
  - "Objects of a **class type** can be value initialized *only if* the class has a default constructor."
  - "Used to initialize a **container**'s elements when a size, but not an element initializer, is specified. Elements are initialized as **a copy of** this compiler-generated value."

### Zero-initialization

- "Sets the initial value of an object to zero."
- zero-initialization "does not have a dedicated syntax in the language", but other types of initialization perform zero-initialization
- "If `T` is a scalar type, the object is initialized to the value obtained by explicitly converting the integer literal `0` (zero) to `T`"

### Copy Initialization

- "Initializes an object **from another object**.", i.e. `T object = other;`
- we can supply only a **single initializer**
- happens when using `=`

```cpp
string s1;            // default initialization; s1 is the empty string
string s2 = s1;       // s2 is a copy of s1
string s3 = "hiya";   // s3 is a copy of the string literal
int units_sold = 0;
// not "Copy Initialization"
int units_sold = {0}; // since C++11 this is classified as "list initialization"
```

- copy initialization usually uses the **copy constructor**, but sometimes it uses the **move constructor**
- happens when
  - when we define variables using an `=`
  - functions
    - (Syntax 3) **pass** an object as **an argument to a parameter** of nonreference type ("pass by value")
    - (Syntax 4) **return** an object **from a function** that has a nonreference return type ("return by value")
  - brace initialization of
    - arrays
    - members of an aggregate class
  - container 
    - initialization
    - when we `insert` or `push` a container member

### Direct Initialization

- **Warning:** not to be confused with **direct-list-initialization** (see "list initialization")
  - the difference is well explained here: [stackoverflow](https://stackoverflow.com/a/71994272)

- "Initializes an object from explicit set of constructor arguments."

- uses the [Copy Constructor](#copy-constructor) 
  - proof: see [Copy Constructor](#copy-constructor) &rarr; "called whenever an object is initialized (by **direct-initialization** ... ) ..."
  - for members of class type, not for built-in types

Difference: Direct vs Copy Initialization:
- **direct initialization**: asks the compiler to "use ordinary function matching to **select the constructor** that best matches the arguments we provide"
- **copy initialization**: asks the compiler to "copy the right-hand operand into the object being created, converting that operand if necessary"

#### Case 1

Happens when we omit the `=`

```cpp
// Examples
string s4(10, 'c');   // s4 is cccccccccc
int units_sold(0);
int units_sold{0};    // "direct initialization" according to Case 4
```

#### Case 2

Happens when initializing with a nonempty **parenthesized** list:
- "1) Initialization with a nonempty **parenthesized** list of expressions or braced-init-lists" (ie. `arg` can be a braced-init-list, but it must be enclosed by parentheses `()`!).

```cpp
T object ( arg );               // (1)

T object ( arg1, arg2, ... );   // (1)
```

#### Case 3

Happens in **constructor initializer lists**:
- "6) Initialization of a base or a non-static member by constructor initializer list."
  - better explanation: [learn.microsoft.com](https://learn.microsoft.com/en-us/cpp/cpp/initializers?view=msvc-170#direct-initialization)
  - here, **"base"** refers to the `BaseClass` when using inheritance (see **Example 2**)
    - because when using inheritance `BaseClass(initializer)` is in the constructor initializer list (like a member that is initialized)

```cpp
// "member" is direct initialized
Class::Class() : member( args, ... ) { ... } 	// (6)
```

**Example 2**:

```cpp
class DerivedClass : public BaseClass{
public:
    // BaseClass and m_char are direct initialized
    DerivedClass(int n, char c) : BaseClass(n), m_char(c) {}

    ...
}
```

#### Case 4

**Single** brace-enclosed initializer for **built-in** objects:
- "2) Initialization of an object of non-class type with a single brace-enclosed initializer"
  - **Note:** if the object is of class type, this would be **list-initialization**, or more precisely **direct-list-initialization**

```cpp
T object { arg };
```

### In-class Initialization

When we create objects, the in-class initializers will be used to initialize the data members. 

- "Initializer provided as part of the declaration of a class data member."
- C++11
- **Members without an initializer** are default initialized
- When we provide an in-class initializer, we must do so 
  - following an `=` sign (copy initialization) **or**
  - inside curly braces `{}` (direct initialization)
  - **not:** initializer in parentheses

### List Initialization

- C++11
- "Initializes an object from **braced-init-list**."
- initialization using **curly braces**
- The compiler will not let us list initialize variables of **built-in type** if the initializer might lead to the loss of information

```cpp
long double ld = 3.1415926536;

int a{ld}, b = {ld}; // error: narrowing conversion required
int c(ld), d = ld;   // ok: but value will be truncated
```

- when we **supply a list of (vector) element values** we can only do this by using list initialization
  - We cannot supply a list of initializers using parentheses:
```cpp
vector<string> v1{"a", "an", "the"}; // list initialization
vector<string> v2("a", "an", "the"); // error
```

## Aggregate Initialization

- "Initializes an aggregate from an initializer list."
  - `T object = { arg1, arg2, ... };`,
  - `T object{ arg1, arg2, ... };` (since C++11)
- a form of **list initialization** (since C++11)

## Declaration vs Definition
 
- **"separate compilation"**: split programs into several files, each of which can be compiled independently.
- To support separate compilation, C++ distinguishes between declarations and definitions. 
  - A **declaration** makes a name known to the program. A file that wants to use a name defined elsewhere includes a declaration for that name. 
  - A **definition** creates the associated entity.
- A **variable declaration** specifies the type and name of a variable. 
- A **variable definition** is a declaration. 
  - In addition to specifying the name and type, a definition also **allocates storage** and may provide the variable with an **initial value**.
- Variables must be **defined exactly once** but can be **declared many times**.
- To use the same variable in multiple files, we must define that variable in one - and only one - file. Other files that use that variable must declare - but not define - that variable

### extern

- `extern`: To obtain a declaration that is **not** also a definition, we add the `extern` keyword and must not provide an explicit initializer.
- inside a function
  - It is an error to provide an initializer on an `extern` 
- outside a function 
  - we can initialize an `extern`, however, this overrides the `extern`. The `extern` becomes a definition in this case.

## Static typing

- C++ is a statically typed language, which means that **types are checked at compile time**. 
- The process by which types are checked is referred to as **type checking**.
- consequence of static typing: must declare the type of a variable before we can use that variable

## this

like `self` in Python:
- [stackoverflow](https://stackoverflow.com/questions/22526153/self-of-python-vs-this-of-cpp-c), inside the class block `self` must be written **explicitly** each time, whereas `this` can be dropped
- [stackoverflow](https://stackoverflow.com/a/61240703), `this->member = 4;` equals `(*this).member = 4;` equals `member = 4;`

p.257-258: "Defining Member Functions", "Introducing this", "Introducing `const` Member Functions"
- member functions access the object on which they were called through an implicit parameter `this`
  - when a member function is called (eg. `total.isbn()`), `this` is initialized with the address of the object on which the function was invoked (like `Sales_data::isbn(&total)`, where `isbn()` is defined as `Sales_data::isbn(Sales_data *const this)`)
- the `this` parameter is defined implicitly. Thus, it is legal, although unnecessary, to define

```cpp
struct Sales_data {
  ...
  std::string isbn() const { return bookNo; }
  ...
}
```

as

```cpp
struct Sales_data {
  ...
  std::string isbn() const { return this->bookNo; }
  ...
}
```

Type of `this`:
- default:
  - "`this` is a `const` pointer to the non`const` version of the class type" 
    - **phth**: eg. `this` is the "const pointer" `Sales_data *const` (it is not a "pointer to const" `const Sales_data *const`)
- in `const` member function blocks:
  - the keyword `const` that follows the parameter list modifies the type of the implicit `this` pointer:
    - A `const` following the parameter list indicates that `this` is a pointer to `const` (see [pointer to const](#pointer-to-const)).

## const objects

- may call only `const` member functions
- a `const` object does not assume its "constness" until after the constructor completes the object's initialization

## pointer to const

```cpp
const double pi = 3.14;
double *ptr = &pi;          // error: ptr is a plain pointer (see (2))
const double *cptr = &pi;
*cptr = 42;                 // error: cannot assign to *cptr (see (1))
```

- (1) a pointer to `const` may not be used to change the object to which the pointer points
- (2) we may store the address of a `const` object **only** in a pointer to `const`
- we can use a pointer to `const` to point to a non`const` object (exception to rule: "types of a pointer and the object to which it points must match")
- a pointer to `const` says nothing about whether the object to which the pointer points is `const` (like a [reference to const](#reference-to-const))
  - think of them as pointers or references "that *think* they point or refer to `const`"

## const pointer

```cpp
int errNumb = 0;
int *const curErr = &errNumb;   // curErr will always point to errNumb
```

- its value (i.e., the address that it holds) may not be changed
- The fact that a pointer is itself `const` says nothing about whether we can use the pointer to change the underlying object
- "unlike references, pointers are objects" &rarr; pointers can be `const`, references cannot

## static

- [stackoverflow](https://stackoverflow.com/a/15235626)

## Temporaries

- **"temporary"** aka **"temporary object"**

Examples when temporaries are **created** automatically by the compiler:

```cpp
double dval = 3.14;
const int &ri = dval;
```

is translated by the compiler like

```cpp
double dval = 3.14;
const int temp = dval;
const int &ri = temp;   // bind "ri" to the temporary "temp"
```

- This happens not only for type `int` temporaries but also for **class type** temporaries (given the class has a corresponding [converting constructor](#converting-constructor))
  - see `Sales_data::combine(const Sales_data &rhs)` call on p.295, 7.5.4
    - a temporary of type `const Sales_data &rhs` is created from a `string`

# Functions

## inline functions

- A function specified as `inline` (usually) is expanded "in line" at each call. 
  - the word "usually" means that this expansion does not happen sometimes because the compiler can choose to ignore the `inline`! (see point below)
- inline functions may be defined multiple times in the program (unlike ordinary functions), but all definitions must match
  - therefore, inline functions normally are **defined in headers**
- `inline` removes the **run-time overhead** of using a normal function.
  - Explanation: **Calling** a function is likely to be slower than **evaluating** the equivalent expression.
    - On most machines, a **function call** does a lot of work:
      - Registers are saved before the call and restored after the return;
      - arguments may be copied; and
      - the program branches to a new location.
- The `inline` specification is only a **request** to the compiler.
  - The compiler may choose to ignore this request.
- In general, the inline mechanism is meant to optimize **small, straight-line functions that are called frequently**.
  - Many compilers will not inline a recursive function.
  - A 75-line function will almost surely not be expanded inline.
- 7.3.2: In practice, well-designed C++ programs tend to have lots of small (inline) functions such as `do_display`

## Default Arguments

- 6.5.1
- "A default argument is specified as an initializer for a parameter in the parameter list"
- Arguments in the call are resolved by position. The default arguments are used for the trailing (right-most) arguments of a call.
  - "if a parameter has a default argument, all the parameters that follow it must also have default arguments"
  - **general rule**: order the parameters so that those least likely to use a default value appear first!
- when re-declaring functions (recall, re-declaring functions is legal):
  - each parameter can have its default specified **only once**
  - defaults can be specified only if all parameters **to the right** already have defaults
  - **best practice**: Default arguments ordinarily should be specified with the function declaration in an appropriate header.
- changing the value of a default argument
  - you can **assign** a new default value to a default argument
  - do not try to change a default argument by "hiding" its name in a new scope (see the example in p. 237 and the corresponding explanation on p.238)

## return values

ignoring return values:
- "calling a function and ignoring the return result is *very* common", [stackoverflow](https://stackoverflow.com/a/38919156)
- `printf("hello\n");` ignores the return value, [stackoverflow](https://stackoverflow.com/a/38919103)

## static functions

- [stackoverflow](https://stackoverflow.com/a/15235626)

## member functions

- "member function bodies may use other members of their class regardless of where in the class those members appear" (see "compile order" in [Classes](#classes))
- "code is interpreted as being inside the scope of the class" (ie. eg. no need to use `this` to access members)

### implicit "this" parameter

- a `total.isbn()` call is translated like a `Sales_data::isbn(&total)` call
  - "the compiler passes the address of `total` to the implicit `this` parameter" (as if `Sales_data::isbn(Sales_data *const this)` were the function definition, see "passing_by_reference.c" - Listing 9.6)

### const member functions

"`const` member functions cannot change the object on which they are called."
- "The purpose of that `const` is to **modify the type of** the implicit `this` pointer." (see [this](#this))
  - **phth**: `this` is a `const` pointer, but the `const` following the parameter list makes it a pointer to `const` (see [pointer to const](#pointer-to-const))
  - "A `const` following the parameter list indicates that `this` is a pointer to `const`"

We can think of the `const` member 
```cpp
std::string isbn() const { return bookNo; }
```

as if it were written as
```cpp
// this code is illegal: we may not explicitly define the this pointer ourselves
std::string Sales_data::isbn(const Sales_data *const this) { return this->bookNo; }
```

[stackoverflow](https://stackoverflow.com/a/3141107)
- A "`const` function", denoted with the keyword `const` after a function declaration, makes it a compiler error for this class function to change a member variable of the class. However, reading of a class variables is okay inside of the function, but writing inside of this function will generate a compiler error.

### inline member functions

- member functions ...
  - defined inside the class: automatically inline
  - defined outside the class: need to specify as `inline`
  - declared inside the class: need to specify as `inline`
- inline member functions should be defined in the same header as the corresponding class definition (for the same reason as described for inline functions)
- it is legal to specify `inline` on both the declaration and the definition. 
  - **Best practice**: specifying `inline` only on the definition outside the class can make the class easier to read.

## Lambdas

From [learn.microsoft](https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170):
- In C++11 and later, a **lambda expression** - often called **a lambda** - is a convenient way of defining an anonymous function object (a closure) right at the location where it's invoked or passed as an argument to a function. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous functions.

# Classes

- "Classes are user-defined types, defined by class-specifier"
- The **class specifier** has the following syntax: 
  - `class-key attr(optional) class-head-name final(optional) base-clause(optional) { member-specification } 	`
- `class-key`
  - one of `class`, `struct` and `union`. 
    - The keywords `class` and `struct` are identical except for 
      - the default member access and
      - the default base class access.
    - If it is `union`, the declaration introduces a union type. 
- declaration of **objects**:
  - `class ClassName item1;` (inherited from C) is equivalent to `ClassName item1;`
- **forward declaration:** declare a class without defining it
  - **incomplete type:** After a declaration and before a definition is seen, the class type is an **incomplete type** - it's known that the type is a class type but not known what members that type contains
  - A class must be **defined** - not just declared - before
    - we can write code that **creates objects** of that type
    - a reference or pointer is used to **access a member** of the type
- a class 
  - **cannot** have data members of its own type
  - **can** have data members that are pointers or references to its own type

## Compile Order

compile order: **two steps** 

1) **member declarations**,
2) **member function bodies**, if any

## Class Types

### struct

- `struct` is a `class-key` (see above)
- when we define a class intending for all of its members to be `public`, we use `struct`. 
  - If we intend to have `private` members, then we use `class`.

[stackoverflow](https://stackoverflow.com/a/1127406):
- In C++ the only difference between a `class` and a `struct` is that members and base classes are `private` by default in classes, whereas they are `public` by default in structs.
- So structs can have **constructors**, and the syntax is the same as for classes.

Why use `typedef struct`?

[Why should we typedef a struct so often in C? - Stack Overflow](https://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c)
- no longer have to write `struct` all over the place
- can make the code cleaner since it provides a smidgen **more abstraction**

### union

- `union` is a `class-key` (see above)
- "A `union` is a special **class type** that can hold only one of its non-static data members at a time."
- like a "room in a hotel", [stackoverflow](https://stackoverflow.com/a/2313676)

## Constructors

- "Classes control object **initialization** by defining one or more special member functions known as **constructors**."
- Constructors 
  - have the same **name** as the class.
  - control 
    - object **initialization**
    - what happens when we **copy**, **assign**, or **destroy** objects of the class type
      - **copy**: 
        - when we initialize a variable or 
        - when we pass or return an object by value
      - **assign**: when we use the assignment operator
      - **destroy**: 
        - local object: destroyed on exit from the block in which it was created
        - Objects stored in a `vector` (or an array): destroyed when that `vector` (or array) is destroyed
      - If we do **not** define these operations, the compiler will **synthesize** them for us. 
        - the versions that the compiler generates for us execute by copying, assigning, or destroying **each member** of the object
        - **Warning:** "classes that manage dynamic memory, generally **cannot** rely on the synthesized versions of these operations"
          - but if you use `vector` and `string` to manage dynamic memory the synthesized versions for copy, assignment and destruction will work
  - are special member functions, but
    - have no return type
    - must not be declared as `const`
- a class may have multiple constructors (&rarr; overloading)
- can write to `const` objects during their construction

### Default Constructor

- "a constructor which can be called with no arguments" (cppreference)
- "called during 
  - **default initializations** and 
  - **value initializations**"
- 1) **explicitly defined default constructor**
- 2) **synthesized default constructor** (implicitly defined default constructor)
  - the compiler **implicitly** defines this constructor, if we do not explicitly define one
    - but **only if** a class declares **NO** constructors
  - member initialization
    - if there is an **in-class initializer**, use it to initialize the member
    - else **default initialize** the member
- situations in which we **must** explicitly define a default constructor:
  - 1. we have defined at least one constructor, and therefore, the compiler will not generate a default constructor
  - 2. to make sure that **class members** of **built-in types** or **compound types** cannot end up **uninitialized**
    - **in blocks**: objects of built-in or compound type that are defined inside a block have **undefined value** when they are default initialized (see ["Default Initialization"](#default-initialization))
  - 3. when the compiler cannot synthesize a default constructor
- `= default` keyword
  - C++11
  - we can ask the compiler to generate the constructor for us by writing `= default` after the parameter list
    - this constructor does exactly the same work as the synthesized default constructor
- best practice
  - "it is almost always right to provide a default constructor if other constructors are being defined."
- [default arguments](#default-arguments):
  - "A constructor that supplies default arguments **for all its parameters** also defines the default constructor." (7.5.1 "Default Arguments and Constructors")

### Constructor Initializer List

7.1.4 "Constructors" &rarr; "Constructor Initializer List"
- When a member is omitted from the constructor initializer list, it is implicitly initialized **using the same process as is used by the synthesized default constructor**
  - **best practice:** 
    - constructors should "use an in-class initializer if one exists and gives the member the correct value", i.e. "constructors should not override in-class initializers"
    - **phth**: if there are no in-class initializers for a class **or** your compiler does not support in-class initializers, then **built-in types** must be explicitly initialized in the constructor initializer list (because otherwise they will be uninitialized, see "synthesized default constructor")

7.5.1 "Constructors Revisited" &rarr; "Constructor Initializer List"
- "If we do not explicitly initialize a member in the constructor initializer list, that member is **default initialized** before the constructor body starts executing"
- if you do not use constructor initializers, you do not "initialize" the members, but you **"assign"** values to the members (recall, in C++: assign != initialize)
- when constructor initializer is **required**:
  - "We **must** use the constructor initializer list to provide values for members that are ...
    - `const`, 
    - reference, or 
    - of a `class` type that does not have a default constructor."
  - **best practice**: By routinely using constructor initializers, you can avoid being surprised by compile-time errors when you have a class with a member that **requires** a constructor initializer
- **best practice**:
  - order of member initialization
    - write constructor initializers in the same order as the members are declared. 
    - when possible, avoid using members to initialize other members.
    - write member initializers to use the constructor's parameters rather than another data member from the same object (see example in 7.5.1)

### Delegating Constructor

- "In a delegating constructor, the **member initializer list** has a single entry that is **the name of the class itself**. Like other member initializers, the name of the class is followed by a parenthesized list of arguments. The argument list must match another constructor in the class."

### Converting Constructor

- **Implicit Class-Type Conversion**
- "A constructor that can be called with a **single argument** defines an implicit conversion **from** the constructor's parameter type **to** the class type."
- **only one** implicit class type conversion is allowed (p.295)

#### explicit

- **disable** the implicit conversion by declaring the converting constructor as `explicit`
  - you can use `explicit` on constructors with **a single argument** only
  - use `explicit` only on the constructor declaration inside the class
  - `explicit` constructors can be used only with **direct initialization** (see Example 1)
    - because copy initialization triggers an implicit class type conversion which the `explicit` does not allow

**Example 1**:

```cpp
Sales_data item1(null_book); // ok: direct initialization
// error: cannot use the copy form of initialization with an explicit constructor
Sales_data item2 = null_book;
```

**Example 2**:
- the `vector` constructor that takes a single size parameter is `explicit`

```cpp
void f(vector<int>); // f’s parameter is copy initialized
f(10); // error: can’t use an explicit constructor to copy an argument
f(vector<int>(10)); // ok: directly construct a temporary vector from an int
```

### Copy Control

- controlled by 5 **special member functions** ("copy-control members"):
  - copy constructor, 
  - copy-assignment operator, 
  - move constructor, 
  - move-assignment operator, and 
  - destructor
- "If a class does not define all of the copy-control members, the compiler **automatically defines** the missing operations"
  - **member-wise**: "the versions that the compiler generates for us execute by copying, assigning, or destroying **each member** of the object."

### Copy Constructor

- used for **initialization** (direct and copy forms), whereas the Copy-Assignment Operator is used for **assignment**

Lippman, 13.1.1 "The Copy Constructor"
- "A constructor is the copy constructor if 
  - its **first parameter** is a **reference to the class type** (eg. `T&`, `const T&`) and 
  - any **additional parameters** have default values"
- "almost always a reference to `const`" (although it can be a reference to nonconst)
- "the copy constructor usually should **not** be `explicit`" 
  - because it is often used for **implicit conversion** (see [converting constructor](#converting-constructor))

```cpp
class Foo {
public:
  Foo();             // default constructor
  Foo(const Foo&);   // copy constructor
  // ...
};
```

- "called whenever an object is initialized (by **direct-initialization** or **copy-initialization**) from another object of the same type, which includes"
  - **initialization**: `T a = b;` or `T a(b);`, where `b` is of type `T`;
  - **function argument passing**: `f(a);`, where `a` is of type `T` and `f` is `void f(T t);`
  - **function return**: `return a;` inside a function such as `T f()`, where `a` is of type `T`, which has no move constructor. 
- "the compiler is permitted (but not obligated) to skip the copy/move constructor and create the object directly" (see Example 1)

Example 1:

```cpp
string null_book = "9-999-99999-9"; // copy initialization
// may be rewritten to
string null_book("9-999-99999-9"); // compiler omits the copy constructor
```

#### Synthesized Copy Constructor

- for some classes disallows copying objects of that class type
- copies the members of its argument into the object being created **memberwise**
- unlike the synthesized default constructor, it is synthesized **even if** we define other constructors
- uses **direct initialization**
  - because the synthesized constructor is **equivalent to** using a **constructor initializer list**, see example on p.497
- type of member determines how the member is copied
  - **class type**: copied by the class' copy constructor
  - **built-in type**: copied directly (direct initialization)
  - **array**: copied elementwise

### Copy-Assignment Operator

- "a (...) member function with the name `operator=` that takes **exactly one parameter** of type `T`, `T&`, `const T&`"

```cpp
class-name & class-name ::operator= ( const class-name & )   // (2)
```

- used for **assignment**, whereas the Copy Constructor is used for **initialization**

#### Synthesized Copy-Assignment Operator

```cpp
T& T::operator=(const T&)
// or:
T& T::operator=(T&)
```

- for some classes disallows assignment
- analogue to synthesized copy constructor
- memberwise: **assign** each member of rhs object to lhs object (using copy-assignment operator for the type of that member)
  - arrays: elementwise
- returns a **reference to** its lhs object (via `return *this`)

### Destructor

```cpp
~ class-name ();
```

- "called when the lifetime of an object ends."
- "The purpose of the destructor is to free the resources that the object may have acquired during its lifetime."
- no return value
- takes no parameters
- order:
  - 1) function body is executed
    - typically, frees resources an object allocated during its lifetime
  - 2) (nonstatic) members are destroyed
    - in reverse order from the order in which they were initialized
- destruction part is **implicit**
  - cannot control how members are destroyed
    - whereas **for constructors** constructor initializer lists **can** control how members are initialized
- what happens when a member is destroyed:
  - **class type**: 
    - running the member's own destructor
  - **built-in types**:
    - do not have destructors, so nothing is done
  - **built-in pointer type**: 
    - does not `delete` the object to which that pointer points
      - **Note:** if you want to `delete` the object use **smart pointers** (which are class types)
- called when
  - **variables**: when they go out of scope
  - **members** of an object: when the object is destroyed
  - **elements of a container**: when a container is destroyed
  - **dynamically allocated objects**: `delete` is applied to a pointer to the object
  - **temporaries**: at the end of the creating expression
- not called when 
  - a **reference** to an object goes out of scope
  - a **pointer** to an object goes out of scope

## Access Control and Encapsulation

- "encapsulate" the implementation = "hide" the implementation

### Access Specifiers

access Specifiers (to enforce encapsulation, i.e. hiding of implementation details)
- `public` members: defines the interface
- `private` members: encapsulate (i.e., hide) the implementation

The only difference between `struct` and `class` is the **default access level**:
- If we use the `struct` keyword, the members defined before the first access specifier are `public`
- if we use `class`, then the members are `private`

Best practice:
- When we define a class intending for all of its members to be `public`, we use `struct`. 
- If we intend to have `private` members, then we use `class`.

Benefits of Encapsulation:
- User code cannot inadvertently corrupt the state of an encapsulated object.
- The implementation of an encapsulated class can change over time without requiring changes in user-level code.

### Friends

- A class can allow another class or function to **access its nonpublic members** by making that class or function a `friend`
  - `friend` declarations 
    - may appear only inside a class definition
    - may appear anywhere in the class
  - `friend` function definitions
    - `friend` function can be **defined** inside the class body (7.3.4)
      - such functions are implicitly `inline`
- friends
  - are not members
  - are not affected by the access control of the section in which they are declared
- A friend declaration **is not a general declaration** of the function. 
  - we must also declare the function **separately** from the friend declaration (some compilers do not require this, but this is best practice)
  - **best practice**:
    - group `friend` declarations together at the beginning or end of the class definition
    - in addition to the `friend` declaration, declare each friend (outside the class) in the same header as the class
- friendship is not transitive

## Member Function

### Special Member Function

source: cppreference

**special member function:** Some member functions are **"special"**: under certain circumstances they are defined by the compiler even if not defined by the user. They are:
- Default constructor
- Copy constructor 
- Move constructor 
- Copy assignment operator 
- Move assignment operator 
- Destructor 

**defaulted function:** Special member functions are the only functions that can be **"defaulted"**, that is, defined using `= default` instead of the function body. 

### Functions that return *this

Such functions 
- return a **reference** to the object on which they are called
- are **lvalues**, which means that they return the object itself, **not a copy** of the object.

**Motivation**: Without such functions we cannot execute a **sequence** of operations **on the same object**, such as

```cpp
// move the cursor to a given position, and set that character
myScreen.move(4,0).set('#');
```

- you can also call a member function based on whether 

## Data Member

## Type Member

- a class can define its own (local) types
  - this type names may be either `public` or `private`
- unlike ordinary members, members that define types **must appear before they are used**
  - **best practice**: as a result, type members usually appear **at the beginning of the class**

## ::ClassName

[stackoverflow](https://stackoverflow.com/questions/4269034/what-is-the-meaning-of-prepended-double-colon)

This ensures that resolution occurs from the global namespace, instead of starting at the namespace you're currently in. For instance, if you had two different classes called `Configuration` as such:

```cpp
class Configuration; // class 1, in global namespace
namespace MyApp
{
    class Configuration; // class 2, different from class 1
    function blah()
    {
        // resolves to MyApp::Configuration, class 2
        Configuration::doStuff(...) 
        // resolves to top-level Configuration, class 1
        ::Configuration::doStuff(...)
    }
}
```

Basically, it allows you to traverse up to the global namespace since your name might get clobbered by a new definition inside another namespace, in this case `MyApp`.

# References

- idea
  - Normally, when you use a reference, you do not use the address-of operator. You simply use the reference as you would use the target variable.
    - references are **aliases** for their target
  - enables the function to change the object being referred to

```cpp
int intOne;
int &rSomeRef = intOne;
intOne = 5;

// intOne: 5
// rSomeRef: 5
// &intOne: 0x3500
// &rSomeRef: 0x3500
```

- references (unlike other variables)
  - must be initialized when they are declared
  - cannot be reassigned
- space **before** the address-of operator is **required**
- usually "the type of a reference must match the type of the object to which it refers"
  - 2 exceptions:
    - 1) "we can initialize a reference to const from any expression that can be converted to the type of the reference" (see [reference to const](#reference-to-const))

## reference to const 

- aka "`const` reference", "lvalue reference to a `const` value"
- Unlike an ordinary reference, a reference to `const` cannot be used to change the object to which the reference is bound
- "we can **initialize** a reference to `const` from any expression that can be converted to the type of the reference"
  - we can bind a reference to `const` to 
    - a nonconst object, 
    - a literal, or 
    - a more general expression
    - an object of a different type (in this case, the reference is bound to a [temporary](#temporaries) object, see p.62)
- "Binding a reference to `const` to an object says nothing about whether the underlying object itself is `const`."
  - ie. the underlying object cannot be changed by using the reference to `const`, but it might be changed by other means
- binding a **non-const** reference to a [temporary](#temporaries) is illegal in C++, only **const** references may be bound to a temporary (see p.62)

# Nullpointer

- [Bjarne Stroustrup comment](https://www.stroustrup.com/bs_faq2.html#null)
- ([g++ doc](https://gcc.gnu.org/onlinedocs/libstdc++/manual/support.html#std.support.types.null))
- `NULL` ist definiert als [macro](https://gcc.gnu.org/onlinedocs/cpp/Macros.html) (i.e. a piece of code in a program that is replaced by the value of the macro; a macro is defined by `#define` directive; whenever a macro name is encountered by the [preprocessor](https://en.wikipedia.org/wiki/Preprocessor), it replaces the name with the definition of the macro): 
  - From [cppreference](https://en.cppreference.com/w/cpp/types/NULL):
    ```cpp
    #define NULL 0
    //since C++11
    #define NULL nullptr
    ```
  - dh `NULL` und `0` waren früher **dasselbe** [bis C++11] und jetzt sind `NULL` und `nullptr` **dasselbe** (aber how come [implicit cast difference](#implicit-cast-of-null-and-nullptr)?)
- "Unless you need to be compatible with C++98/C++03 or C you should prefer to use `nullptr` instead of `NULL`." ([g++ doc](https://gcc.gnu.org/onlinedocs/libstdc++/manual/support.html#std.support.types.null))

## Implicit Cast of NULL and nullptr

### To Pointer Types

- `NULL` und `nullptr` beide implicitly convertible to any **pointer** type
  - A **null pointer** constant (see `NULL`), can be converted to any **pointer** type [i.e. type with asterisk `*`], and the result is the null pointer value of that type. ([cppreference](https://en.cppreference.com/w/cpp/language/implicit_conversion))

### To Integral Types

- Unlike `NULL`, `nullptr` is **not** implicitly convertible or comparable to integral types [e.g. `int`, `char`] ([geeksforgeeks](https://www.geeksforgeeks.org/understanding-nullptr-c/))
  - `int x = NULL` geht; 
  - `int x = nullptr` geht **nicht**!
- `nullptr` is of type `nullptr_t`, which is implicitly convertible and comparable to any pointer type or pointer-to-member type. **It is not implicitly convertible or comparable to integral types** [e.g. `int`, `char`], **except for** `bool`. ([C++11](https://en.wikipedia.org/wiki/C%2B%2B11#Null_pointer_constant))

## Type of NULL and nullptr

- In C++11 hat `NULL` den type `nullptr_t` 
  - `nullptr_t` "is a distinct type that is not itself a pointer type or a pointer to member type." ([doc](https://en.cppreference.com/w/cpp/types/nullptr_t))
- "In C, the macro `NULL` may have the type `void*`, but that is not allowed in C++." ([cppreference](https://en.cppreference.com/w/cpp/types/NULL))
  - how come?: [stackoverflow](https://stackoverflow.com/a/69057243)
  - soll heißen: `NULL` hat in C++ **absichtlich nicht (wie in C)** den Type `void*`, weil there is no **implicit cast** from `void*` to any other type in C++ (in C wäre das aber möglich!). Bis C++11 war `NULL` das [integer literal](https://en.cppreference.com/w/cpp/language/integer_literal) "`0`", konnte damit also einen der integer literal types (s. Tabelle in [integer literal](https://en.cppreference.com/w/cpp/language/integer_literal)) haben. Seit C++11 hat `NULL` den type `nullptr_t` ([doc](https://en.cppreference.com/w/cpp/types/nullptr_t)).
    (dh zB
    ```cpp
    void* ptr = nullptr; 
    int foo = *ptr;    // this implicit cast is not allowed in C++
    ```
    gibt einen Compiler Error `error: ‘void*’ is not a pointer-to-object type`
    (**fix**: use a different type (a "pointer-to-object" type) instead of `void*` -  `void*` is a "pointer-to-nothing")
    Aber 
    ```cpp
    char* ptr = nullptr; 
    int foo = *ptr;
    ```
    gibt keinen Compiler Error, weil `char*` ein pointer-to-object type ist.)

# Polymorphism

1. function **overloading**
2. templates
3. virtual functions ( **overriding** )

[source](https://www.geeksforgeeks.org/templates-cpp/)
- "Both function overloading and templates are examples of **polymorphism** features of OOP."
- function templates vs overloading: 
  - "Function overloading is used when multiple functions do quite similar (not identical) operations, templates are used when multiple functions do identical operations."

# Templates

- **instantiation**: The process that the compiler uses to create classes or functions from templates
- templates are **not** functions or classes
- templates "can be thought of as instructions to the compiler for generating classes or functions"
- templates can make the code shorter and more manageable

## Function Templates

**Function Template**:

[stackoverflow](https://www.cplusplus.com/doc/oldtutorial/templates/)

```cpp
// function template
#include <iostream>
using namespace std;

template <class T>
T GetMax (T a, T b) {
  T result;
  result = (a>b)? a : b;
  return (result);
}

int main () {
  int i=5, j=6, k;
  long l=10, m=5, n;
  k=GetMax<int>(i,j);
  n=GetMax<long>(l,m);
  cout << k << endl;
  cout << n << endl;
  return 0;
}
```

**Generic Type**: Function templates are special functions that can operate with **generic types**. This allows us to create a function template whose functionality can be adapted to more than one type or class without repeating the entire code for each type.

**Template Parameter**: In C++ this can be achieved using **template parameters**. A template parameter is a special kind of parameter that can be used to pass a type as argument: just like regular function parameters can be used to pass values to a function, template parameters allow to pass also types to a function. These function templates can use these parameters as if they were any other regular type.

## Class Templates

[source](https://www.geeksforgeeks.org/templates-cpp/):
- to create a single class to work with different data types
- useful when a class defines something that is independent of the data type. 
  - Can be useful for classes like LinkedList, BinaryTree, Stack, Queue, Array, etc.

```cpp
// C++ Program to implement
// template Array class
#include <iostream>
using namespace std;

template <typename T> class Array {
private:
    T* ptr;
    int size;

public:
    Array(T arr[], int s);
    void print();
};

template <typename T> Array<T>::Array(T arr[], int s)
{
    ptr = new T[s];
    size = s;
    for (int i = 0; i < size; i++)
        ptr[i] = arr[i];
}

template <typename T> void Array<T>::print()
{
    for (int i = 0; i < size; i++)
        cout << " " << *(ptr + i);
    cout << endl;
}

int main()
{
    int arr[5] = { 1, 2, 3, 4, 5 };
    Array<int> a(arr, 5);
    a.print();
    return 0;
}
```

### Containers

- each container is defined in a header file with the same name as the type
- containers are class templates (3.3)
- container types: see ["Types"](#types)

#### std::array

- "a container that encapsulates **fixed size** arrays"
- "an aggregate type"
- "same semantics as a `struct` holding a **C-style array** `T[N]` as its only non-static data member."
  - **But**: "Unlike a C-style array, it doesn't decay to `T*` automatically."

#### std::vector

- **flexible-size** array (as opposed to the **fixed-size** array `std::array`)
- `std::vector` is a template, not a type

#### std::string

- A specialized container that contains characters.
- similar to `vector`
- Convert to C-style string (null-terminated string)
  - `.c_str()` converts a string to a null-terminated string (C-style string), [stackoverflow](https://stackoverflow.com/questions/7416445/what-is-use-of-c-str-function-in-c) (s. Antwort von hkBattousai)

# Overloading vs Overriding

- overloading: the same function name, but with a different signature (i.e. name of the function, the parameter list, and the keyword `const`, if used)
- overriding: the same function name and the same signature

# Overloading

[stackoverflow](https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm)

**Function Overloading**, **Operator Overloading**: C++ allows you to specify more than one definition for a **function** name or an **operator** in the same scope, which is called **function overloading** and **operator overloading** respectively. 

**overloaded declaration**, **overload resolution**: An overloaded declaration is a declaration that is declared with the same name as a previously declared declaration in the same scope, except that both declarations have different arguments and obviously different definition (implementation). When you call an overloaded **function** or **operator**, the compiler determines the most appropriate definition to use, by comparing the argument types you have used to call the function or operator with the parameter types specified in the definitions. The process of selecting the most appropriate overloaded function or operator is called **overload resolution**.

# Overriding

- "**Overriding** a function means changing the implementation of a base class function in a derived class." (Day 12, J Liberty)

## "Normal" Overriding

- "When a derived class creates a function with the same return type and signature as a member function in the base class, but with a new implementation, it is said to be **overriding** that function. When you make an object of the derived class, the correct function is called." (Day 12, J Liberty)

## virtual

- C++ allows **pointers to base classes** to be assigned to derived class objects `BaseClass* pBase = new DerivedClass;` (Day 12, J Liberty)
  - `pBase` can invoke any method on `BaseClass`, but what we would like is for those methods that are overridden in `DerivedClass()` to call the correct function
- phth: "normal" overriding (cf. above) is possible **without** the `virtual` (see Day 12, J Liberty), but, if a pointer to the base class is assigned to the derived class object, and we use this pointer to call an overridden function, the overriding will not work

[source](https://www.programiz.com/cpp-programming/virtual-functions):
- A **virtual function** is a member function in the base class that we *expect* to redefine in derived classes.
- Basically, a virtual function is used in the base class in order to ensure that the function is **overridden**. This especially applies to cases where a pointer of base class points to an object of a derived class.

```cpp
// source: https://www.geeksforgeeks.org/virtual-functions-in-derived-classes-in-cpp/
// C++ Program to demonstrate Virtual
// functions in derived classes
#include <iostream>
using namespace std;

class A {
public:
	virtual void fun() { cout << "\n A::fun() called "; } 
};

class B : public A {
public:
	void fun() { cout << "\n B::fun() called "; }
};

class C : public B {
public:
	void fun() { cout << "\n C::fun() called "; }
};

int main()
{
	// An object of class C
	C c;

	// A pointer of class B pointing
	// to memory location of c
	B* b = &c;

	// this line prints "C::fun() called"
    // (Note: without the "virtual" in "class A" this line prints "\n A::fun() called ")
	b->fun();

	getchar(); // to get the next character
	return 0;
}
```

# argc, argv

[stackoverflow](https://stackoverflow.com/questions/3024197/what-does-int-argc-char-argv-mean)

# Streams

A **stream** is a sequence of characters read from or written to an IO device. The term stream is intended to suggest that the characters are generated, or consumed, sequentially over time.

## iostream library

Defines the **types**: `istream` and `ostream`
Objects of type `istream`:
- `cin`
Objects of type `ostream`:
- `cout`
- `cerr`
- `clog`

## Buffer, Print Statements

**buffer**: A region of storage used to hold data. IO facilities often store input (or output) in a buffer and read or write the buffer independently from actions in the program. Output buffers can be explicitly flushed to force the buffer to be written. By default, reading cin flushes cout; cout is also flushed when the program ends normally.

```cpp
std::cout << "string" << std::endl
```

Writing `endl` has the effect of ending the current line and **flushing the buffer** associated with that device. Flushing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.
- **Best practice**: Programmers often add **print statements** during debugging. Such statements should **always flush the stream**. Otherwise, if the program crashes, output may be left in the buffer, leading to incorrect inferences about where the program crashed.

# Vectors

- elements are stored contiguously
- how a `vector` grows
  - Vectors typically allocate capacity beyond what is immediately needed.
  - The container holds this **storage in reserve** and uses it to allocate new elements **as they are added**.
    - Thus, there is **no need to reallocate** ("`vector` zu einem Ort umlagern wo mehr Platz ist") the container each time an element is added
  - dramatically more efficient than reallocating the container each time an element is added
- container size management:
  - container size management functions, see Table 9.10
    - `c.shrink_to_fit()`: Request to reduce `capacity()` to equal `size()`
    - `c.capacity()`: Number of elements `c` can have before reallocation is necessary.
    - `c.reserve(n)`: Allocate space for at least `n` elements.
  - vector `size`: number of elements the vector already holds
  - vector `capacity`: how many elements it can hold before more space must be allocated

# Strings

- **string literals** are not standard library `strings`
- elements are stored contiguously
- how a `string` grows
  - Strings typically allocate capacity beyond what is immediately needed. (like `vector`)

## `string::size_type`

- a **companion type**
  - companion types make it possible to use the library types in a machine-independent manner
- an unsigned type
- big enough to hold the size of any `string`
- tedious to type `string::size_type` &rarr; use `auto` or `decltype`

# Debugging

see "C notes"

tools:
- gdb
- valgrind

# Unit Testing

## Best Practices

- [Unit Testing Basics](https://www.jetbrains.com/help/clion/unit-testing-tutorial.html#basics)

## Test Runners

### ctest

`ctest` doesn't provide any testing macros/functions/classes on its own. It's just a **test runner**.

[Why useful?](https://www.reddit.com/r/cpp/comments/iwbdx7/is_ctest_worth_the_effort/):
- "**CTest** is useful for running multiple types of tests. You might have unit tests for C++ in **Catch2**, unit tests for python bindings in **pytest**, and you might have application-level testing that runs you program with specified arguments in a short **shell script**. CTest is the place to wire all these frameworks together so you can run all your testing in one shot. It works well for that."
- "And since I haven't seen it mentioned, the big C++ unit testing frameworks can integrate with CTest so you can see the pass/fail status of each test run by the framework"

## Test Frameworks

### Catch2

catch2 vs gtest:
- [snorristurluson.github.io](https://snorristurluson.github.io/Catch2/)
- [anteru.net](https://anteru.net/blog/2017/from-google-test-to-catch/)

### GoogleTest, gtest

- based on the **xUnit** architecture

#### Build

To see some **gtest samples**:
- build as [Standalone CMake Project](https://github.com/google/googletest/tree/main/googletest#standalone-cmake-project)

Build method used in AdvCpp course: 
- build by [Incorporating Into An Existing CMake Project](https://github.com/google/googletest/tree/main/googletest#incorporating-into-an-existing-cmake-project)
  - "Use CMake to download GoogleTest as part of the build's configure step. This approach doesn't have the limitations of the other methods." 

Just add to your `CMakeLists.txt` (CMake 3.14 or later):
```cmake
include(FetchContent)
FetchContent_Declare(
  googletest
  # Specify the commit you depend on and update it regularly.
  URL https://github.com/google/googletest/archive/5376968f6948923e2411081fd9372e71a59d8e77.zip
)
# For Windows: Prevent overriding the parent project's compiler/linker settings
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(googletest)

# Now simply link against gtest or gtest_main as needed. Eg
add_executable(example example.cpp)
target_link_libraries(example gtest_main)
add_test(NAME example_test COMMAND example)
```
