---
title: "C++ Notes"
read_time: false
excerpt: "For learning C++"
header:
    teaser: /assets/images/Cpp_logo.png
    overlay_image: /assets/images/Cpp_logo.png
    overlay_filter: 0.5 
toc: true
toc_label: "Contents"
toc_sticky: true
categories:
    - Notes
tags:
    - c++
    - notes

---

# DEFINITIONS

## areas of memory

- **stack** - Local variables, function parameters 
- **code space** - Code
- **global namespace** - global variables 
- **registers** - used for internal housekeeping functions, such as keeping track of the top of the stack and the instruction pointer
- **free store = heap** - Just about all of the remaining memory 

## Expressions, literals

https://en.cppreference.com/w/cpp/language/expressions
- **expression** := sequence of **operators** and their **operands**, that specifies a computation.

- **primary expression** := literals, Id-expressions, lambda-expressions, fold-expressions, requires-expressions
	- **literals** := the tokens of a C++ program that represent **constant** values [=Konstanten] (dh alle Zeichen, die man “nicht ändern kann”) 
        - **integer literals** (eg 1, 2, 3 …)
        - **character literals** (eg einzelne Buchstaben)
        - **boolean literals** (true und false)
        - **nullptr** 

- nullptr ist ein **literal** (s.o.)

- C++ **expression properties**: "*each C++ expression is characterized by two independent properties*"
    - **type**
    - **Value categories:**
        - **Primary categories:**
            - **prvalue expression** (eg literals (s.o.), arithmetic expressions [`+`,`-`,`%`,...], ...)
            - **xvalue expression**
            - **lvalue expression**
        - **Mixed categories:**
            - **glvalue expression**
            - **rvalue expression**

# Include Syntax

Usual practice is to use the `#include "local.h"` form for headers inside a `library/package/module`, and the `#include <external.h>` form for headers from `external/3rd-party` or system libraries.

# The `using` keyword

Using the namespace designation is **good form** because, if you use `using namespace some_namespace`, you run the risk of inadvertently using objects from the wrong library. This takes some **effort to fix**, whereas using the namespace designation cannot lead to such conflicts (see [example](https://stackoverflow.com/a/1452738)). I.e. from a **maintenance** perspective using the namespace designation is best practice.

# Nullpointer: nullptr, NULL

## Definition

- [Bjarne Stroustrup comment](https://www.stroustrup.com/bs_faq2.html#null)
- ([g++ doc](https://gcc.gnu.org/onlinedocs/libstdc++/manual/support.html#std.support.types.null))
- `NULL` ist definiert als [macro](https://gcc.gnu.org/onlinedocs/cpp/Macros.html) (i.e. a piece of code in a program that is replaced by the value of the macro; a macro is defined by `#define` directive; whenever a macro name is encountered by the [preprocessor](https://en.wikipedia.org/wiki/Preprocessor), it replaces the name with the definition of the macro): 
  ```cpp
  #define NULL 0
  //since C++11
  #define NULL nullptr
  ```
  (from [cppreference](https://en.cppreference.com/w/cpp/types/NULL))  
    - dh `NULL` und `0` waren früher **dasselbe** [bis C++11] und jetzt sind `NULL` und `nullptr` **dasselbe** (aber how come [implicit cast difference](#implicit-cast-of-null-and-nullptr)?)
- "Unless you need to be compatible with C++98/C++03 or C you should prefer to use `nullptr` instead of `NULL`." ([g++ doc](https://gcc.gnu.org/onlinedocs/libstdc++/manual/support.html#std.support.types.null))

## Implicit Cast of NULL and nullptr

### To Pointer Types

- `NULL` und `nullptr` beide implicitly convertible to any **pointer** type
    - A **null pointer** constant (see `NULL`), can be converted to any **pointer** type [i.e. type with asterisk `*`], and the result is the null pointer value of that type. ([cppreference](https://en.cppreference.com/w/cpp/language/implicit_conversion))

### To Integral Types

- Unlike `NULL`, `nullptr` is **not** implicitly convertible or comparable to integral types [e.g. `int`, `char`] ([geeksforgeeks](https://www.geeksforgeeks.org/understanding-nullptr-c/))
    - `int x = NULL` geht; 
    - `int x = nullptr` geht **nicht**!
- `nullptr` is of type `nullptr_t`, which is implicitly convertible and comparable to any pointer type or pointer-to-member type. **It is not implicitly convertible or comparable to integral types** [e.g. `int`, `char`], **except for** `bool`. ([C++11](https://en.wikipedia.org/wiki/C%2B%2B11#Null_pointer_constant))

## Type of NULL and nullptr

- "In C, the macro `NULL` may have the type `void*`, but that is not allowed in C++." ([cppreference](https://en.cppreference.com/w/cpp/types/NULL))
    - how come?: [stackoverflow](https://stackoverflow.com/a/69057243)
    - soll heißen: `NULL` hat in C++ **absichtlich nicht (wie in C)** den Type `void*`, weil there is no **implicit cast** from `void*` to any other type in C++ (in C wäre das aber möglich!). Bis C++11 war `NULL` das [integer literal](https://en.cppreference.com/w/cpp/language/integer_literal) "`0`", konnte damit also einen der integer literal types (s. Tabelle in [integer literal](https://en.cppreference.com/w/cpp/language/integer_literal)) haben. Seit C++11 hat `NULL` den type `nullptr_t` ([doc](https://en.cppreference.com/w/cpp/types/nullptr_t)).  
      (dh zB
      ```cpp
      void* ptr = nullptr; 
      int foo = *ptr;    // this implicit cast is not allowed in C++
      ```
      gibt einen Compiler Error `error: ‘void*’ is not a pointer-to-object type`   
      (**fix**: use a different type (a "pointer-to-object" type) instead of `void*` -  `void*` is a "pointer-to-nothing")   
      Aber 
      ```cpp
      char* ptr = nullptr; 
      int foo = *ptr;
      ```
      gibt keinen Compiler Error, weil `char*` ein pointer-to-object type ist.)

# Templates

## SYNTAX

**Function Template**:	(phth: besser als overloading, weil man nicht x mal dieselbe Funktion definieren muss)

(https://www.cplusplus.com/doc/oldtutorial/templates/)
```cpp
// function template
#include <iostream>
using namespace std;

template <class T>
T GetMax (T a, T b) {
  T result;
  result = (a>b)? a : b;
  return (result);
}

int main () {
  int i=5, j=6, k;
  long l=10, m=5, n;
  k=GetMax<int>(i,j);
  n=GetMax<long>(l,m);
  cout << k << endl;
  cout << n << endl;
  return 0;
}
```
Function templates are special functions that can operate with **generic types**. This allows us to create a function 
template whose functionality can be adapted to more than one type or class without repeating the entire code for each type.

In C++ this can be achieved using **template parameters**. A template parameter is a special kind of parameter that 
can be used to pass a type as argument: just like regular function parameters can be used to pass values to a function, 
template parameters allow to pass also types to a function. These function templates can use these parameters as if 
they were any other regular type.

# Overloading

(https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm)

C++ allows you to specify more than one definition for a **function** name or an **operator** in the same scope, which is called **function overloading** and **operator overloading** respectively. 

An overloaded declaration is a declaration that is declared with the same name as a previously declared declaration in the same scope, except that both declarations have different arguments and obviously different definition (implementation). When you call an overloaded **function** or **operator**, the compiler determines the most appropriate definition to use, by comparing the argument types you have used to call the function or operator with the parameter types specified in the definitions. The process of selecting the most appropriate overloaded function or operator is called **overload resolution**.

# Double Colon prepended to the class name

(https://stackoverflow.com/questions/4269034/what-is-the-meaning-of-prepended-double-colon)
This ensures that resolution occurs from the global namespace, instead of starting at the namespace you're currently in. For instance, if you had two different classes called "**Configuration**" as such:
```cpp
class Configuration; // class 1, in global namespace
namespace MyApp
{
    class Configuration; // class 2, different from class 1
    function blah()
    {
        // resolves to MyApp::Configuration, class 2
        Configuration::doStuff(...) 
        // resolves to top-level Configuration, class 1
        ::Configuration::doStuff(...)
    }
}
```
Basically, it allows you to traverse up to the global namespace since your name might get clobbered by a new definition inside another namespace, in this case "**MyApp**".

# argc, argv

https://stackoverflow.com/questions/3024197/what-does-int-argc-char-argv-mean

# Strings

## .c_str()

https://stackoverflow.com/questions/7416445/what-is-use-of-c-str-function-in-c
(s. Antwort von hkBattousai)

## Format Specifiers

e.g. `%d`, `%f`, `%.3f`

https://www.cprogramming.com/tutorial/printf-format-strings.html

# typedef struct

[Why should we typedef a struct so often in C? - Stack Overflow](https://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c)

# Lambdas

From [learn.microsoft](https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170):
In C++11 and later, a **lambda expression** - often called **a lambda** - is a convenient way of defining an anonymous function object (a closure) right at the location where it's invoked or passed as an argument to a function. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous functions.
