---
title: "C++ Notes"
read_time: false
excerpt: "For learning C++"
header:
    teaser: /assets/images/Cpp_logo.png
    overlay_image: /assets/images/Cpp_logo.png
    overlay_filter: 0.5 
toc: true
toc_label: "Contents"
toc_sticky: true
categories:
    - Notes
tags:
    - c++
    - notes

---

# Standards

## C++11

- see p. xix "New Features in C++11"

# Definitions

## Deep Copy vs Shallow Copy

see [stackoverflow](https://stackoverflow.com/a/184780)

## Areas of Memory

- **stack** - Local variables, function parameters 
- **code space** - Code
- **global namespace** - global variables 
- **registers** - used for internal housekeeping functions, such as keeping track of the top of the stack and the instruction pointer
- **free store = heap = dynamic memory** - Just about all of the remaining memory 

## Value Categories

Just learn them by using this [list of examples](https://en.cppreference.com/w/cpp/language/value_category).

From [learn.microsoft.com](https://learn.microsoft.com/en-us/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-170):
- Every C++ expression has a **type**, and belongs to a **value category**.
- The **value categories** are the basis for rules that compilers must follow when creating, copying, and moving **temporary objects** during expression evaluation.
- C++17:
  - A **glvalue** is an expression whose evaluation determines the identity of an object, bit-field, or function.
  - A **prvalue** is an expression whose evaluation initializes an object or a bit-field, or computes the value of the operand of an operator, as specified by the context in which it appears.
    - has no address that is accessible by your program
    - examples
      - literals, 
      - function calls that return a nonreference type, and 
      - temporary objects that are created during expression evaluation but accessible only by the compiler
  - An **xvalue** is a glvalue that denotes an object or bit-field whose resources can be reused (usually because it is near the end of its lifetime). 
    - has an address that no longer accessible by your program but can be used to initialize an rvalue reference, which provides access to the expression
    - examples
      - Certain kinds of expressions involving **rvalue references** (8.3.2) yield xvalues, such as a call to a function whose return type is an rvalue reference or a cast to an rvalue reference type.
      - function calls that return an **rvalue reference**, and 
      - the array subscript expressions where the array is an **rvalue reference**
      - member and pointer to member expressions where the object is an **rvalue reference**
  - An **lvalue** is a glvalue that isn't an xvalue.
    - has an address that your program can access
    - examples
      - variable names, including `const` variables, 
      - array elements, 
      - function calls that return an lvalue reference, 
      - bit-fields, 
      - unions, and 
      - class members
  - An **rvalue** is a prvalue or an xvalue.

![value-categories](/assets/images/cpp/value_categories.png)

[stackoverflow](https://stackoverflow.com/a/3601661):
- "The whole massacre began with the move semantics."

### lvalue and rvalue (informal)

- **every expression in C++** is either an **lvalue** or an **rvalue**
- inherited from C 
  - in C: simple mnemonic purpose: lvalues could stand on the left-hand side of an assignment whereas rvalues could not
- in C++: Roughly speaking, 
  - when we use an object as an **rvalue**, we use the **object's value** (its contents). 
  - when we use an object as an **lvalue**, we use the **object's identity** (its **location** in memory).
- we can use an lvalue when an rvalue is required, but we cannot use an rvalue when an lvalue (i.e., a location) is required

## POD Types, Layout Dependent Operations

phth:
- Some programs and compilers use **operations that depend on** a particular memory **layout**.
- Therefore, C++14 introduced three categories of simple classes and structs, **trivial**, **standard-layout**, and **POD**, so that programs can check the suitability of any given type for operations that depend on a particular memory layout.

[learn.microsoft.com](https://learn.microsoft.com/en-us/cpp/cpp/trivial-standard-layout-and-pod-types?view=msvc-170&source=recommendations):
- **layout:** refers to how the members of an object of class, struct or union type are arranged in memory. 
  - In some cases, the layout is well-defined by the language specification. 
  - But when a class or struct contains certain C++ language features such as virtual base classes, virtual functions, members with different access control, then the compiler is free to choose a layout. 
    - That layout may vary depending on what optimizations are being performed and in many cases the object might not even occupy a contiguous area of memory.
- **POD type:** When a class or struct is both trivial and standard-layout, it is a POD (Plain Old Data) type. 
  - The **memory layout** of POD types is therefore **contiguous** and each member has a higher address than the member that was declared before it, so that byte for byte copies and binary I/O can be performed on these types. 
  - Scalar types such as int are also POD types. 
  - POD types that are classes can have only POD types as non-static data members.

- PODType
  - detailed:
    - [C++98/03](https://stackoverflow.com/a/4178176/734069)
    - [C++11](https://stackoverflow.com/a/7189821/734069)
  - informal:
    - [types that are POD](https://stackoverflow.com/a/146589)
  - "POD (Plain Old Data) types, compatible with C `struct`"
  - "This means the type is compatible with the types used in the C programming language, that is, can be exchanged with C libraries directly, in its binary form."
    - scalar types
      - "object types that are not array types or class types"
        - arithmetic types
        - enumeration types
        - pointer types
        - pointer-to-member types
        - `std::nullptr_t`
        - cv-qualified versions of these types
    - POD classes
    - arrays of such types
    - cv-qualified versions of these types

## Operators

- the **scope** operator "`::`"
- the **output** operator "`<<`"
  - returns its left-hand operand
- the **input** operator "`>>`"
  - returns its left-hand operand
- [assignment operators](https://en.cppreference.com/w/cpp/language/operator_assignment) (`=`)
  - requires a (non`const`, ie. modifiable) lvalue as its left-hand operand 
  - yields its left-hand operand as an lvalue
  - sub-categories:
    - copy assignment operator
    - move assignment operator
    - compound assignment operator (`+=`)
- arithmetic operators
  - addition operator (`+`)
- logical and relational operators
  - logical AND (`&&`)
  - less than (`<`)
- the call operator (`()`)
- increment operator "`++`" and decrement operator "`--`"
  - Pre-increment and pre-decrement operators 
    - increments or decrements the value of the object and 
    - returns a reference to the result.
  - Post-increment and post-decrement 
    - creates a copy of the object, 
    - increments or decrements the value of the object and 
    - returns the copy from before the increment or decrement.
- complement operator (`~`)
- [member access operators](https://en.cppreference.com/w/cpp/language/operator_member_access)
  - subscript operator (`a[b]`)
    - "provides access to an object pointed-to by the pointer or array operand"
  - dereference/indirection operator (`*a`)
    - "provides access to an object or function pointed-to by the pointer operand"
  - address-of operator (`&a`)
    - "creates a pointer pointing to the object or function operand"
    - requires an lvalue operand
    - returns a pointer to its operand as an rvalue
  - member of object/dot operator (`a.b`)
    - "provide access to a data member or member function of the object operand"
    - returns the member named by the right-hand operand
  - member of pointer (`a->b`, equivalent to `(*a).b`)
    - "provide access to a data member or member function of the class pointed-to by the pointer operand"

### Lvalues vs Rvalues and Operators

- Operators differ as to whether they 
  - require lvalue or rvalue **operands**
  - **return** lvalues or rvalues
- Examples of operators that involve lvalues:
  - **Assignment** 
    - requires a (non`const`) lvalue as its left-hand operand
    - yields its left-hand operand as an lvalue.
  - **address-of** operator 
    - requires an lvalue operand
    - returns a pointer to its operand as an rvalue.
  - built-in **dereference** and **subscript** operators and the **iterator dereference** and **string and vector subscript** operators 
    - all yield lvalues.
  - built-in and iterator **increment** and **decrement** operators 
    - require lvalue operands 
    - the prefix versions (which are the ones used so far) also yield lvalues.

## Expressions, literals

source: [https://en.cppreference.com/w/cpp/language/expressions](https://en.cppreference.com/w/cpp/language/expressions)

- **expression** := sequence of **operators** and their **operands**, that specifies a computation.
- **primary expression** := literals, [id-expressions](https://www.ibm.com/docs/en/i/7.4?topic=expressions-identifier-c-only), lambda-expressions, fold-expressions, requires-expressions
  - **literals** := the tokens of a C++ program that represent **constant** values ( = Konstanten ) (dh alle Zeichen, die man "nicht ändern kann") 
    - **integer literals** (eg `1`, `2`, `3`, ...)
    - **character literals** (eg einzelne Buchstaben)
    - **boolean literals** (`true` und `false`)
    - **nullptr** (Merke: `nullptr` ist ein **literal**!)
- C++ expression **properties**: "*each C++ expression is characterized by two independent properties*"
  - **1. type**
  - **2. value category:** (see [Value Categories](#value-categories))
    - **Primary categories:**
      - **prvalue expression**
        - literals (s.o.)
        - arithmetic expressions (`+`,`-`,`%`,...)
        - ...
      - **xvalue expression**
      - **lvalue expression**
    - **Mixed categories:**
      - **glvalue expression**
      - **rvalue expression**
- **full-expression:** "A **full expression** is an expression that is not part of another expression or of a declarator.", [source](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1729.htm)

## Statements

- "fragments of the C program that are executed in sequence"
- 5 types
  - 1) compound statements (aka **block**)
    - "a brace-enclosed sequence of statements and declarations."
    - "Each compound statement introduces its own **block scope**."
  - 2) expression statements
    - "An expression followed by a semicolon is a statement."
  - 3) selection statements
  - 4) iteration statements
  - 5) jump statements

cppreference:

**Statements** are fragments of the C++ program that are executed in sequence. 
- The **body of any function** is a sequence of statements.
- For example:

```cpp
int main()
{
    int n = 1;                        // declaration statement
    n = n + 1;                        // expression statement
    std::cout << "n = " << n << '\n'; // expression statement
    return 0;                         // return statement
}
```

C++ includes the following types of statements:

1. labeled statements;
2. expression statements;
  - "An expression statement is an **expression** followed by a **semicolon**."
  - syntax: `attr(optional) expression(optional);`
  - "Most statements in a typical C++ program are expression statements, such as assignments or function calls."
  - "An expression statement without an expression is called a **null statement**. It is often used to provide an empty body to a for or while loop."
3. compound statements;
4. selection statements;
5. iteration statements;
6. jump statements;
7. declaration statements;
8. try blocks;
9. atomic and synchronized blocks (TM TS).

## CV Type Qualifiers

- "Appear in any type specifier, including decl-specifier-seq of declaration grammar, to specify constness or volatility of the object being declared or of the type being named."
  - `const` - defines that the type is constant.
  - `volatile` - defines that the type is volatile. 

[Wikipedia](https://en.wikipedia.org/wiki/Type_qualifier):

As of 2014 and C11, there are four type qualifiers **in standard C**: `const` (C89), `volatile` (C89), `restrict` (C99) and `_Atomic` (C11) – the latter has a private name to avoid clashing with user-defined names. The first two of these, `const` and `volatile`, are also present **in C++**, and are the only type qualifiers in C++. Thus **in C++** the term "cv-qualified type" (for `const` and `volatile`) is often used for "qualified type", while the terms "c-qualified type" and "v-qualified type" are used when only one of the qualifiers is relevant.

Of these, `const` is by far the best-known and most used, appearing in the C and C++ standard libraries and encountered in any significant use of these languages, which must satisfy const-correctness. The other qualifiers are used for low-level programming, and while widely used there, are rarely used by typical programmers. For a time however `volatile` was used by some C++ programmers for synchronization during threading, though this was discouraged and is now broken in most compilers. 

## Factory

Wikipedia:
- In object-oriented programming, a **factory** is an object for creating other objects; 
- formally, it is a function or method that returns objects of a varying prototype or class from some method call, which is assumed to be "new". 
- More broadly, a *subroutine* that returns a "new" object may be referred to as a "factory", as in **factory method** or **factory function**. ("even if functions are not objects")
- The factory pattern is the basis for a number of related software design patterns. 

## Invariants

BS4.3
- "invariant" aka "class invariant"
- "a statement of what is assumed to be true for a class"
  - eg. for `Vector`, the statement "`elem` points to an array of `sz` doubles" is an invariant 
    - nothing `Vector` does makes any sense unless the members of `Vector` have reasonable values
- job of a **constructor**: establish the invariant for its class (so that the member functions can rely on it)
- job of the **member functions**: make sure that the invariant holds when the member functions exit

# Header Files

## Using C Headers in C++

- use the **C++ versions** of C library headers
  - Headers **in C** have names of the form `name.h`. The **C++ versions** of these headers are named `cname`.
  - **Warning:** names defined in the `cname` headers are defined inside the `std` namespace, whereas those defined in the `.h` versions are not

## Newline at EOF

It is good style to always put a newline at the end of text files (POSIX Standard), [stackoverflow](https://stackoverflow.com/questions/729692/why-should-text-files-end-with-a-newline)
- this is part of language standards:
  - in `C`: newline required at the end of header files
  - in `C++`: before `C++11`: newline required at the end of header files
  - "*No newline at end of file*" compiler warning, [stackoverflow](https://stackoverflow.com/questions/72271/no-newline-at-end-of-file-compiler-warning)
- in `git`: [stackoverflow](https://stackoverflow.com/questions/5813311/whats-the-significance-of-the-no-newline-at-end-of-file-log)

# Include Syntax

Usual practice is to use the `#include "local.h"` form for headers inside a `library/package/module`, and the `#include <external.h>` form for headers from `external/3rd-party` or system libraries.

Lippman, Lajoie, Moo: Headers from the **standard library** are enclosed in angle brackets (`< >`). Those that are not part of the library are enclosed in double quotes (`" "`).

# Keywords

- see Table 2.3

## using

Using the namespace designation is **good form** because, if you use `using namespace some_namespace`, you run the risk of inadvertently using objects from the wrong library. This takes some **effort to fix**, whereas using the namespace designation cannot lead to such conflicts (see [example](https://stackoverflow.com/a/1452738)). I.e. from a **maintenance** perspective using the namespace designation is **best practice**.

## = default

- `= default` can be used only on member functions that have a synthesized version
- **defaulted functions**:
  - explicitly-*defaulted* function definition: as an explicit instruction to the compiler to generate a [special member function](#special-member-function)
- to explicitly ask the compiler to generate the **synthesized** versions of the **copy-control members**
- the synthesized function is **implicitly inline** (just as is any other member function defined in the body of the class)
  - if we do **not** want the synthesized member to be an inline function, we can specify `= default` on the member's **definition** (outside the class)

## = delete

- Motivation: how to prevent copies?
  - simply not defining the copy-control members does not work because the compiler will synthesize them, if we do not define them
- **deleted functions**:
  - one that is declared but may not be used in any other way
- signals to the compiler (and to readers of our code) that we are **intentionally not defining** these members
- A `=delete` makes an attempted use of the deleted function a compile-time error (BS6.1.1)
- Unlike `= default`, `= delete` 
  - must appear on the first declaration of a deleted function
  - we can specify `= delete` on **any** function
    - sometimes also useful to guide the **function-matching** process
- use cases:
  - "A base class in a class hierarchy is the classic example where we don't want to allow a memberwise copy" (BS6.1.1)
- **Warning:** You can `delete` a destructor. However, it is not possible to
  - define an object of a type with a deleted destructor
  - `delete` a pointer to a dynamically allocated object of a type with a deleted destructor
    - ie you **can** dynamically allocate such objects, but you cannot free them
- "synthesized as deleted"
  - in essence, if a class has a **data member** that **cannot** be default constructed, copied, assigned, or destroyed, then the corresponding copy-control member will be a deleted function
- prior to the new standard: 
  - prevent copying by declaring the copy constructor and copy-assignment operator as `private`
    - not best practice! Use `= default` instead.

## auto

- tells the compiler to deduce the type from the initializer
  - thus, a variable that uses `auto` must have an initializer
- type that the compiler infers for `auto` is not always exactly the same as the initializer's type
  - eg. for 
    - references
      - compiler uses the referred object's type, and not the reference type
    - top-level `const`s
      - ignored
- "in the type specifier sequence of a variable: `auto x = expr;` as a type specifier. The type is deduced from the initializer."
- "If the placeholder type specifier is used **to declare multiple variables**, the deduced types must match."
  - "For example, the declaration `auto i = 0, d = 0.0;` is ill-formed, while the declaration `auto i = 0, *p = &i;` is well-formed and the `auto` is deduced as `int`."
- "In **direct-list-initialization** (but not in copy-list-initialization), when deducing the meaning of the `auto` from a **braced-init-list**, the braced-init-list must contain **only one element**, and the type of `auto` will be the type of that element:"
```cpp
// C++17

// from: https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts
auto x1 = {3}; // x1 is std::initializer_list<int>
auto x2{1, 2}; // error: not a single element
auto x3{3};    // x3 is int
               // (before N3922 x2 and x3 were both std::initializer_list<int>)

// from: https://mariusbancila.ro/blog/2017/04/13/cpp17-new-rules-for-auto-deduction-from-braced-init-list/
auto a = {42};   // std::initializer_list<int>
auto b {42};     // int
auto c = {1, 2}; // std::initializer_list<int>   // therefore, quote: "but not in copy-list-initialization"
auto d {1, 2};   // error, too many 
```

## decltype

- returns the type of its operand (like `auto`)
- result is a reference type if the expression yields an lvalue, eg. if `p` is an `int*`
  - `decltype(*p)` is `int&` (because dereference yields an lvalue)
  - `decltype(&p)` is `int**` (because address-of operator yields an rvalue)

```cpp
decltype(f()) sum = x; // sum has whatever type f returns
```

- does not call `f`
- uses the type that such a call **would** return as the type for `sum`
- unlike `auto`, `decltype` returns the type of references and top-level `const`s
- `decltype((variable))` is always a reference type, whereas `decltype(variable)` is a reference type only if `variable` is a reference

## const

- **top-level const:** indicates that an **variable/object itself** is `const`
- **low-level const:** appears in the base type of compound types such as pointers or references

```cpp
int i = 0;
int *const p1 = &i; // we can’t change the value of p1; const is top-level
const int ci = 42; // we cannot change ci; const is top-level
const int *p2 = &ci; // we can change p2; const is low-level
const int *const p3 = p2; // right-most const is top-level, left-most is not
const int &r = ci; // const in reference types is always low-level
```

- When we copy an object
  - top-level `const`s are ignored
  - low-level `const`s are never ignored (ie. both objects must have the same low-level `const` qualification)

## constexpr

**constant expressions**:
- an expression 
  - whose value cannot change and 
  - that can be evaluated at compile time. 
- examples:
  - A literal
  - A `const` object that is initialized from a constant expression

```cpp
const int max_files = 20;         // max_files is a constant expression
const int limit = max_files + 1;  // limit is a constant expression
int staff_size = 27;              // staff_size is not a constant expression
const int sz = get_size();        // sz is not a constant expression (because value of its initializer is not known until run time)
```

`constexpr` declaration:
- C++11
  - introduced because it can be difficult to determine that an initializer is a constant expression
- asks the compiler to verify that a variable is a **constant expression**
- Variables declared as `constexpr` are 
  - implicitly `const` and 
  - must be initialized by **constant expressions**
- pointers and reference as `constexprs` must be initialized from
  - the `nullptr` literal
  - the literal (i.e., constant expression) `0`
  - an object that remains at a fixed address, eg.
    - an object defined **outside** of any function (those defined inside are not stored at fixed addresses)
    - local `static` objects/variables
- cannot use an ordinary function as an initializer for a `constexpr` variable
- `constexpr` functions
  - the new standard lets us define certain functions as `constexpr`. 
  - must be simple enough that the compiler can evaluate them at compile time. 
  - can be used in the initializer of a `constexpr` variable.
- **best practice:**
  - use `constexpr` for variables that you intend to use as constant expressions

```cpp
constexpr int mf = 20;        // 20 is a constant expression
constexpr int limit = mf + 1; // mf + 1 is a constant expression
constexpr int sz = size();    // ok only if size is a constexpr function
```

- The types we can use in a `constexpr` are known as **literal types**
  - eg. arithmetic, reference, and pointer types

```cpp
// the `constexpr` specifier applies to the pointer, not the type to which the pointer points:
const int *p = nullptr;       // p is a pointer to a const int
constexpr int *q = nullptr;   // q is a const pointer to int

// a constexpr pointer may point to a const or a nonconst type:
constexpr int *np = nullptr;  // np is a constant pointer to int that is null
int j = 0;
constexpr int i = 42;         // type of i is const int
// i and j must be defined outside any function
constexpr const int *p = &i;  // p is a constant pointer to the const int i
constexpr int *p1 = &j;       // p1 is a constant pointer to the int j
```

# Type Aliases

- A type alias 
  - is a type name
  - can appear wherever a type name can appear

## typedef

- **interpretation:** do not interpret a declaration that uses a type alias by conceptually "replacing" the alias with its corresponding type

```cpp
typedef char *pstring;
const pstring cstr = 0; // - cstr is a constant pointer to char
                        // - base type is const char* (a pointer type)
const pstring *ps;      // ps is a pointer to a constant pointer to char

// WRONG interpretation:
const char *cstr = 0;   // wrong interpretation of const pstring cstr
// - declares cstr as a pointer to const char rather than as a const pointer to char
// - the base type is char (without asterisk!)
// - the asterisk is part of the declarator!
```

## using

- C++11
- aka **alias declaration**

```cpp
using SI = Sales_item;      // SI is a synonym for Sales_item
```

# Types

- primitive types (aka **"built-in types"**)
  - arithmetic types
    - integral types (`char`, `int`, `bool`)
    - floating-point types (`float`, `double`)
  - `void`
- non-primitive types
  - **class types**
    - library types (e.g. `string`, `istream`, `ostream`)
  - compound types (2.3 "a type that is defined in terms of another type")
    - pointer types
    - reference types (2.3.1)
    - array types
    - container types (9)
      - sequential (full list, see table 9.1) ("element order corresponds to the position at which elements are put into the container")
        - `string` (see "C Notes")
        - `array`
        - `vector`
        - linked lists
          - `list` (doubly linked)
          - `forward_list` (singly linked)
      - associative ("store elements based on the value of a key")
      - unordered

## Print Type

`typeid(a).name()`
- **Problem with this approach**: see [stackoverflow](https://stackoverflow.com/a/20170989)
  - throws away cv-qualifiers (ie. `const`, `volatile`), references, and lvalue/rvalue-ness (because the standard mandates this behavior)

## Incomplete Types

- **after a declaration** and before a definition is seen, a type is an **incomplete type**

### Forward Declarations

```cpp
// forward declaration:
// declare a class without defining it
class Screen; // declaration of the Screen class
```

- We can 
  - define pointers or references to such types
  - declare (but not define) functions that use an incomplete type as a parameter or return type
- we cannot
  - create objects of that type
  - use a reference or pointer to access a member of the type

Examples:
- data members of the class' own type:
  - Because a class is not **defined** until its class body is complete, a class cannot have data members of its own type
  - However, a class is considered **declared** (but not yet defined) as soon as its class name has been seen. Therefore, a class can have data members that are pointers or references to its own type

# Variables, Objects

"A region of memory that can contain data and has a type." (Lippman)

- cppreference: "A **variable** is an object or a reference that is not a non-static data member, that is introduced by a declaration."

Lippman
- C++ programmers use the terms "variable" and "object" interchangeably.
- variable expressions are **lvalues**
- a variable is an expression with one operand and no operator

## Construction Order

- construction order
  - base classes (first to last)
  - data members (in declaration order)
  - constructor body
- destruction order
  - reverse of construction order (due to stack memory)

## Initialization

- in C++: initialization != assignment
  - **Initialization** happens when a variable is given a value **when it is created**. 
  - **Assignment** obliterates an object's current value and replaces that value with a new one.
- sources
  - see [learn.microsoft.com](https://learn.microsoft.com/en-us/cpp/cpp/initializers?view=msvc-170)

### Default Initialization

- "the initialization performed when an object is constructed with **no** initializer", i.e. `T object;` or `new T`
- "performed in three situations"
  - 1) when a variable (...) is declared with no initializer `T object;`
  - 2) when an object (...) is created by a `new`-expression with no initializer `new T`
  - 3) when a (...) data member is **not mentioned** in a **constructor initializer list** and that constructor is called
- **precisely:**
  - if `T` is a **class type**, 
    - the constructors are considered and subjected to overload resolution against the empty argument list. 
    - The constructor selected (which is **one of** the **default constructors**) is called to provide the initial value for the new object; 
  - if `T` is an **array type**, 
    - every element of the array is default-initialized; 
  - otherwise, eg. **built-in type**, no initialization is performed
    - this includes raw pointers, eg. `MyClass *a;` does not initialize `a`, [stackoverflow](https://stackoverflow.com/a/37638617)

Examples:
- object of **built-in type**, **compound type** (eg. pointer to built-in type)
  - outside a block (global scope): **0**, **nullptr**
  - inside a block (local scope): **uninitialized/undefined** 
    - **best practice**:
      - every built-in type object, compound type object should be (in-class) initialized
      - provide a default constructor
- object of **class type**
  - value defined by the class
    - some classes **require** that every object be explicitly initialized

### Value Initialization

- "the initialization performed when an object is constructed with an **empty** initializer", i.e. `T()` or `T{}` or `T object{};`
- performed in these situations
  - 1) when a **nameless temporary** object is created with the initializer consisting of an empty pair of parentheses `T()` or braces `T{}`;
  - 2) when an object with dynamic storage duration is created by a **new-expression** with the initializer consisting of an empty pair of parentheses `new T()` or braces `new T{}`;
  - 3) when a non-static data member or a base class is initialized using a **member initializer** with an empty pair of parentheses `Class::Class(...) : member () { ... }` or braces `Class::Class(...) : member {} { ... }`;
  - 4) when a named object (automatic, static, or thread-local) is declared with the initializer consisting of a pair of braces. (since C++ 11)
- **roughly**: 
  - default initializes class types, 
  - zero-initializes + default initializes all others
  - therefore, safer than default initialization
- **precisely**:
  - if `T` is a **class type** with a ...
    - "user-provided default constructor" **or** "no default constructor": the object is [default-initialized](#default-initialization);
    - "implicitly-defined" **or** "defaulted default constructor": all of the following 3 steps are performed in the following order:
      - 1) the object is [zero-initialized](#zero-initialization),
      - 2) the semantic constraints for default-initialization are checked, and 
      - 3) if `T` has a non-trivial default constructor, the object is default-initialized;
  - if `T` is an **array type**, 
    - each element of the array is value-initialized;
  - otherwise, eg. **built-in type**, the object is [zero-initialized](#zero-initialization).
- "References cannot be value-initialized"
- "All standard containers (`std::vector`, `std::list`, etc.) value-initialize their elements when constructed with a single `size_type` argument"
- Lippman p.132: "Initialization in which **built-in types** are initialized to zero and **class types** are initialized by the class's default constructor."
  - "Objects of a **class type** can be value initialized *only if* the class has a default constructor."
  - "Used to initialize a **container**'s elements when a size, but not an element initializer, is specified."
    - "Elements are initialized as **a copy of** this compiler-generated value."

### Zero-initialization

- "Sets the initial value of an object to zero."
- zero-initialization "does not have a dedicated syntax in the language", but other types of initialization perform zero-initialization
- "If `T` is a **scalar type**, the object is initialized to the value obtained by **explicitly converting** the integer literal `0` (zero) to `T`"
  - scalar types: "object types that are not array types or class types"
    - eg. pointers, arithmetic types (integral types, floating-point types), etc.

```cpp
// explicit conversions of "0":
// https://stackoverflow.com/a/21387175
long *a = 0;           // ok, 0 is a null pointer constant
long *b = (long *)0;   // ok, (long *)0 is a null pointer with appropriate type
// invalid in C++:
long *c = (void *)0;   // ok in C, invalid conversion in C++
// In both C and C++, (int *)0 is a constant expression whose value is a null pointer. It is not, however, a "null pointer constant".
long *d = (int *)0;    // invalid conversion in both C and C++
```

- merke: "null pointer constant" != "constant expression whose value is a null pointer"
  - this difference usually only matters for the assignments in the code above, [stackoverflow](https://stackoverflow.com/a/21387175))
  - **Null pointer constant**: "Null pointer constant is either `nullptr` (or any other prvalue of type `std::nullptr_t`), or integer literal of value `0`.", [stackoverflow](https://stackoverflow.com/a/59990291)

### Copy Initialization

```cpp
T object = other; 	// (1) 	
T object = {other}; 	// (2) 	(until C++11)
f(other) 	        // (3) 	
return other; 	        // (4) 	
```

- "Initializes an object **from another object**.", i.e. `T object = other;`
- we can supply only a **single initializer**
- happens when using `=`

```cpp
string s1;            // default initialization; s1 is the empty string
string s2 = s1;       // s2 is a copy of s1
string s3 = "hiya";   // s3 is a copy of the string literal
int units_sold = 0;
// not "Copy Initialization"
int units_sold = {0}; // since C++11 this is classified as "copy-list-initialization"
```

- copy initialization usually uses the **copy constructor**, but sometimes it uses the **move constructor**
  - cppreference: "If `other` is an **rvalue expression**, a move constructor will be selected by overload resolution and called during copy-initialization. This is still considered copy-initialization; there is no special term (e.g., move-initialization) for this case."
- happens when
  - when we define variables using an `=`
  - functions
    - (Syntax 3) **pass** an object as **an argument to a parameter** of nonreference type ("pass by value")
    - (Syntax 4) **return** an object **from a function** that has a nonreference return type ("return by value")
  - brace initialization of
    - arrays
    - members of an aggregate class
  - container 
    - initialization
    - when we `insert` or `push` a container member

### Direct Initialization

- "Initializes an object from explicit set of constructor arguments."
- Syntax: see "Case 1, 2, etc." below
- uses the **Copy Constructor**
  - proof: see [Copy Constructor](#copy-constructor) &rarr; "called whenever an object is initialized (by **direct-initialization** ... ) ..."
  - for members of class type, not for built-in types (which do not have constructors)

**Difference**: Direct vs Copy Initialization:
- **direct initialization**: asks the compiler to "use ordinary function matching to **select the constructor** that best matches the arguments we provide"
- **copy initialization**: asks the compiler to "copy the right-hand operand into the object being created, converting that operand if necessary"

**Difference**: Direct vs Direct-list Initialization:
- only for **single non-class type initializer**: is both **direct-list-initialization** and **direct initialization**
  - common example: `int object{3}`
  - the difference is well explained here: [stackoverflow](https://stackoverflow.com/a/71994272)

#### Case 1

Happens when we omit the `=`

```cpp
// Examples
string s4(10, 'c');   // s4 is cccccccccc
int units_sold(0);
int units_sold{0};    // - special case of "direct initialization" according to Case 4 (as long as the initializer is non-class type)
                      // - special case of "direct-list-initialization" with one element
```

#### Case 2

Happens when initializing with a nonempty **parenthesized** list:
- "1) Initialization with a nonempty **parenthesized** list of expressions or braced-init-lists" (ie. `arg` can be a braced-init-list, but it must be enclosed by parentheses `()`!).

```cpp
T object ( arg );               // (1)

T object ( arg1, arg2, ... );   // (1)
```

#### Case 3

Happens in **constructor initializer lists**:
- "6) Initialization of a **base** or a **non-static member** by constructor initializer list."
  - better explanation: [learn.microsoft.com](https://learn.microsoft.com/en-us/cpp/cpp/initializers?view=msvc-170#direct-initialization)
  - here, **"base"** refers to the `BaseClass` when using inheritance (see **Example 2**)
    - because when using inheritance `BaseClass(initializer)` is in the constructor initializer list (like a member that is initialized)

```cpp
// "member" is direct initialized
Class::Class() : member( args, ... ) { ... } 	// (6)
```

**Example 2**:

```cpp
class DerivedClass : public BaseClass{
public:
    // BaseClass and m_char are direct initialized
    DerivedClass(int n, char c) : BaseClass(n), m_char(c) {}

    ...
}
```

#### Case 4

**Single** brace-enclosed initializer for **built-in** objects:
- "2) Initialization of an object of **non-class type** with a single brace-enclosed initializer"
  - **Note:** if the object is of class type, this would be **list-initialization**, or more precisely **direct-list-initialization**

```cpp
T object { arg };
```

### In-class Initialization

When we create objects, the in-class initializers will be used to initialize the data members. 

- "Initializer provided as part of the declaration of a class data member."
- C++11
- **Members without an initializer** are default initialized
- When we provide an in-class initializer, we must do so 
  - following an `=` sign (copy initialization) **or**
  - inside curly braces `{}` (direct initialization)
  - **not:** initializer in parentheses

### List Initialization

- C++11
- "Initializes an object from **braced-init-list**.", "that is, a possibly empty brace-enclosed list of expressions or nested braced-init-lists"
- 2 syntaxes:
  - **Direct-list-initialization**
    - 1) `T object { arg1, arg2, ... };`, "initialization of a named variable with a braced-init-list (that is, a possibly empty brace-enclosed list of expressions or nested braced-init-lists)"
      - thus, "Direct Initialization" &rarr; "Case 4" is a special case of "Direct-list-initialization"
  - **Copy-list-initialization**
    - 6) `T object = { arg1, arg2, ... };`, "initialization of a named variable with a braced-init-list after an equals sign"

ADVANTAGES:
- The compiler will not let us list initialize variables of **built-in type** if the initializer might lead to the loss of information

```cpp
long double ld = 3.1415926536;

// a: both "direct-list-initialization" and "direct initialization -> Case 4"
// b: both "copy-list-initialization" and "copy initialization"
int a{ld}, b = {ld}; // error: narrowing conversion required
// c: direct initialization
// d: copy initialization
int c(ld), d = ld;   // ok: but value will be truncated
```

VECTORS:
- when we **supply a list of (vector) element values** we can only do this by using list initialization
  - We cannot supply a list of initializers using parentheses:
```cpp
vector<string> v1{"a", "an", "the"}; // list initialization
vector<string> v2("a", "an", "the"); // error
```

### Aggregate Initialization

C++11:
- a form of **list initialization** (since C++11)
- "Initializes an aggregate from an initializer list."
  - `T object = { arg1, arg2, ... };`,
  - `T object{ arg1, arg2, ... };` (since C++11)
- An **aggregate** is one of the following types:
  - array type
  - class type (typically, `struct` or `union`), that has
    - no user-provided, inherited, or explicit constructors
    - no private or protected non-static data members
    - no base classes
    - no virtual member function
    - no default member initializers (in-class initializers)

### Reference Initialization

- "Binds a reference to an object."
- "A reference to T can be initialized with an object of type T, a function of type T, or an object implicitly convertible to T."
- "Once initialized, a reference cannot be reseated (changed) to refer to another object."
- "If the initializer is a braced-init-list, rules of **list initialization** are followed."
- "Otherwise, if the reference is an lvalue reference: ..." (see [cppreference](https://en.cppreference.com/w/cpp/language/reference_initialization))

1) When a named **lvalue reference** variable is declared with an initializer
```cpp
T & ref = target ;
T & ref = { arg1, arg2, ... }; 
T & ref ( target );
T & ref { arg1, arg2, ... }; 
```

2) When a named **rvalue reference** variable is declared with an initializer
```cpp
T && ref = target ;
T && ref = { arg1, arg2, ... }; 
T && ref ( target );
T && ref { arg1, arg2, ... }; 
```

3) In a function call expression, when the function parameter has reference type
4) In the `return` statement, when the function returns a reference type
5) When a non-static data member of reference type is initialized using a member initializer

## Declaration vs Definition
 
- **"separate compilation"**: split programs into several files, each of which can be compiled independently.
- To support separate compilation, C++ distinguishes between declarations and definitions. 
  - A **declaration** makes a name known to the program. A file that wants to use a name defined elsewhere includes a declaration for that name. 
  - A **definition** creates the associated entity.
- A **variable declaration** specifies the type and name of a variable. 
- A **variable definition** is a declaration. 
  - In addition to specifying the name and type, a definition also **allocates storage** and may provide the variable with an **initial value**.
- Variables must be **defined exactly once** but can be **declared many times**.
- To use the same variable in multiple files, we must define that variable in one - and only one - file. Other files that use that variable must declare - but not define - that variable

### extern

- `extern`: To obtain a declaration that is **not** also a definition, we add the `extern` keyword and must not provide an explicit initializer.
- inside a function
  - It is an error to provide an initializer on an `extern` 
- outside a function 
  - we can initialize an `extern`, however, this overrides the `extern`. The `extern` becomes a definition in this case.

## Static typing

- C++ is a statically typed language, which means that **types are checked at compile time**. 
- The process by which types are checked is referred to as **type checking**.
- consequence of static typing: **must declare the type** of a variable before we can use that variable

## this

like `self` in Python:
- [stackoverflow](https://stackoverflow.com/questions/22526153/self-of-python-vs-this-of-cpp-c), inside the class block `self` must be written **explicitly** each time, whereas `this` can be dropped
- [stackoverflow](https://stackoverflow.com/a/61240703), `this->member = 4;` equals `(*this).member = 4;` equals `member = 4;`

p.257-258: "Defining Member Functions", "Introducing this", "Introducing `const` Member Functions"
- member functions access the object on which they were called through an implicit parameter `this`
  - when a member function is called (eg. `total.isbn()`), `this` is initialized with the address of the object on which the function was invoked (like `Sales_data::isbn(&total)`, where `isbn()` is defined as `Sales_data::isbn(Sales_data *const this)`)
- the `this` parameter is defined implicitly. Thus, it is legal, although unnecessary, to define

```cpp
struct Sales_data {
  ...
  std::string isbn() const { return bookNo; }
  ...
}
```

as

```cpp
struct Sales_data {
  ...
  std::string isbn() const { return this->bookNo; }
  ...
}
```

Type of `this`:
- default:
  - "`this` is a `const` pointer to the non`const` version of the class type" 
    - **phth**: eg. `this` is the "const pointer" `Sales_data *const` (it is not a "pointer to const" `const Sales_data *const`)
- in `const` member function blocks:
  - the keyword `const` that follows the parameter list modifies the type of the implicit `this` pointer:
    - A `const` following the parameter list indicates that `this` is a pointer to `const` (see [pointer to const](#pointer-to-const)).

## const objects

- may call only `const` member functions
- a `const` object does not assume its "constness" until after the constructor completes the object's initialization

## pointer to const

```cpp
const double pi = 3.14;
double *ptr = &pi;          // error: ptr is a plain pointer (see (2))
const double *cptr = &pi;
*cptr = 42;                 // error: cannot assign to *cptr (see (1))
```

- (1) a pointer to `const` may not be used to change the object to which the pointer points
- (2) we may store the address of a `const` object **only** in a pointer to `const`
- we can use a pointer to `const` to point to a non`const` object (exception to rule: "types of a pointer and the object to which it points must match")
- a pointer to `const` says nothing about whether the object to which the pointer points is `const` (like a [reference to const](#reference-to-const))
  - think of them as pointers or references "that *think* they point or refer to `const`"

## const pointer

```cpp
int errNumb = 0;
int *const curErr = &errNumb;   // curErr will always point to errNumb
```

- its value (i.e., the address that it holds) may not be changed
- The fact that a pointer is itself `const` says nothing about whether we can use the pointer to change the underlying object
- "unlike references, pointers are objects" &rarr; pointers can be `const`, references cannot

## static

- [stackoverflow](https://stackoverflow.com/a/15235626)

### static members

- members that are associated with the class, rather than with individual objects of the class type
- basically, like any other member
  - can be `public` or `private`
  - type of a `static` data member can be `const`, reference, array, class type
  - etc ...
- unlike other members
  - exist outside any object
    - objects do **not** contain data associated with static data members
  - static members are **shared by all** the objects of the class type
  - static member functions
    - do not have a `this` pointer
    - may not be declared as `const`

**Declaration:**

```cpp
class Account {
  public:
    void calculate() { amount += amount * interestRate; }
    static double rate() { return interestRate; }
    static void rate(double);
  private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate();
};
```

**Definition:**

```cpp
// static member functions:
// - do not repeat the "static" keyword outside the class body
void Account::rate(double newRate)
{
  interestRate = newRate;
}

// static data members:
// - not defined when we create objects
// - not initialized by the class' constructors
// - must be 
//   - defined and initialized OUTSIDE the class body
//   - declared, but NOT initialized inside the class body!
//   - defined outside ANY function (like global variables)
double Account::interestRate = initRate();   // define and initialize a static class member
// Once the class name is seen, the remainder of the definition is in the scope of the class
// -> we can use "initRate" without qualification (even though it is private)
```

**best practice:**
- put the definition of `static` data members in the same file that contains the definitions of the class noninline member functions 
  - avoids double definitions

**in-class initialization:**
- usually you do **not** do this for static members, but
  - we can provide in-class initializers for static members that have `const` integral type
  - must do so for static members that are `constexpr`s of literal type
    - the initializers must be constant expressions
    - such members are themselves constant expressions
  - **important:** if an initializer is provided inside the class, the member's definition must not specify an initial value:

```cpp
// definition of a static member with no initializer
constexpr int Account::period; // initializer provided in the class definition
```

**best practice:**
- Even if a `const` static data member is initialized in the class body, that member ordinarily should be defined outside the class definition.

### Usage

```cpp
double r;
r = Account::rate();  // access a static member using the scope operator

Account ac1;
Account *ac2 = &ac1; 
// equivalent ways to call the static member rate function
r = ac1.rate();       // through an Account object or reference
r = ac2->rate();      // through a pointer to an Account object

class Account {
  public:
    // Member functions can use static members directly, without the scope operator
    void calculate() { amount += amount * interestRate; }
  private:
    static double interestRate;
    // remaining members as before
};
```

Can be used in ways that would be illegal for nonstatic members:
```cpp
// static members can have incomplete types
class Bar {
  public:
    // ...
  private:
    static Bar mem1;  // ok: static member can have incomplete type
    Bar *mem2;        // ok: pointer member can have incomplete type
    // error:
    Bar mem3;         // error: data members must have complete type
 };

// static members can be used as a default argument
class Screen {
  public:
    // bkground refers to the static member
    // declared LATER in the class definition
    Screen& clear(char = bkground);
  private:
    static const char bkground;
};
```

## Temporaries

- aka **"temporary object"**
- "Unnamed object created by the compiler while evaluating an expression." (Lippman)
  - "A temporary exists until the end of the largest expression that encloses the expression for which it was created."
- All temporary objects are **destroyed** as the last step in evaluating the **full-expression** that (lexically) contains the point where they were created, [cppreference](https://en.cppreference.com/w/cpp/language/lifetime#Temporary_object_lifetime)
  - and if multiple temporary objects were created, they are destroyed in the order opposite to the order of creation.
  - This is true even if that evaluation ends in throwing an exception.
  - **phth:** ie. in "expression statements" (where the "full-expression" is the **outermost** expression **without** the semicolon) temporaries are destroyed right before the outermost ";"

Examples when temporaries are **created** automatically by the compiler:

```cpp
double dval = 3.14;
const int &ri = dval;
```

is translated by the compiler like

```cpp
double dval = 3.14;
const int temp = dval;
const int &ri = temp;   // bind "ri" to the temporary "temp"
```

- This happens not only for type `int` temporaries but also for **class type** temporaries (given the class has a corresponding [converting constructor](#converting-constructor))
  - see `Sales_data::combine(const Sales_data &rhs)` call on p.295, 7.5.4
    - a temporary of type `const Sales_data &rhs` is created from a `string`

### Unnamed Temporaries

Creating **unnamed temporary objects**, [stackoverflow](https://stackoverflow.com/a/18892056):
- the object is destroyed immediately after ";".
- memory is allocated (automatically, on the stack) for this temp object and it's freed (again automatically) after ";". 
- the **constructor** and **destructor** are called, as expected.

```cpp
// note: this does not explicitly call the constructor, instead this line creates a temporary unnamed object with type "Demo", which is destroyed immediately after ";"

#include<iostream.h>

class Demo
{
    public :

    Demo()
    {
        cout<<"\nIn Demo const";
    }
    ~Demo()
    {
        cout<<"\nin demo dest";
    }
};

void main() {
    Demo();
}
```

## Lifetimes

From `[basic.life]`:

The lifetime of an object of type T **begins** when:
- storage with the proper alignment and size for type T is obtained, **and**
- its initialization (if any) is complete (including vacuous initialization), (...)

The lifetime of an object o of type T **ends** when:
- if T is a **non-class type**, the object is destroyed, or
- if T is a **class type**, the destructor call starts, or
- the storage which the object occupies is 
  - released, or is 
  - reused by an object that is not nested within o.

**Resources** are bound to the **lifetime** of an object in [RAII](#raii)
- "RAII is a C++ programming technique which **binds** the **life cycle** of a **resource** that must be acquired before use to the **lifetime** of an object." (cppreference)
  - eliminating **"naked new"** expressions

- **Global objects:** 
  - allocated at program start-up and 
  - destroyed when the program ends
- **Local, automatic objects:** 
  - created and destroyed when the block in which they are defined is entered and exited
- **Local static objects:**
  - [cppreference](https://en.cppreference.com/w/cpp/language/storage_duration#Static_local_variables)
  - allocated before their first use ("are initialized the first time control passes through their declaration")
  - and are destroyed when the program ends ("The destructor for a block-scope static variable is called at program exit, but only if the initialization took place successfully.")
- **Dynamically allocated objects:** 
  - allocated at run time, ie. the program controls their lifetimes
  - they exist until they are explicitly freed
  - lifetime is independent of where they are created
- **Temporaries:**
  - "A temporary exists until the end of the largest expression that encloses the expression for which it was created." (Lippman)
    - **phth:** ie. gets destroyed before the ";"

## Anonymous Objects

- aka **nameless temporary** object

From [anonymous objects](https://www.learncpp.com/cpp-tutorial/anonymous-objects/):
- In C++, anonymous objects are primarily used either **to pass or return values** without having to create lots of **temporary** variables to do so.
  - can make the program shorter, cleaner, and generally easier to follow
- Memory allocated dynamically is also done so anonymously 
  - (which is why its address must be assigned to a pointer, otherwise we'd have no way to refer to it).
- It is also worth noting that because anonymous objects have expression scope, they can only be used once (unless bound to a constant l-value reference, which will extend the lifetime of the temporary object to match the lifetime of the reference). 
- If you need to reference a value in multiple expressions, you should use a **named** variable instead.

N3337: in `[class.temporary]`:

Example: Consider the following code:

```cpp
class X {
  public:
    X(int);
    X(const X&);            // X has no move constructor
    X& operator=(const X&);
    ~X();
};
class Y {
  public:
    Y(int);
    Y(Y&&);                 // Y has no copy constructor
    ~Y();
};

X f(X);
Y g(Y);

void h() {
  X a(1);
  X b = f(X(2));    // pass X(2) to f() using copy constructor
  Y c = g(Y(3));    // pass Y(3) to g() using move constructor
  a = f(a);
}
```

- An implementation might use a temporary in which to construct `X(2)` before passing it to `f()` using `X`'s **copy constructor**;
  - alternatively, `X(2)` might be constructed in the space used to hold the argument. ("copy elision")
- Likewise, an implementation might use a temporary in which to construct `Y(3)` before passing it to `g()` using `Y`'s **move constructor**; 
  - alternatively, `Y(3)` might be constructed in the space used to hold the argument. ("copy elision")
- Also, a temporary might be used to hold the result of `f(X(2))` before copying it to b using `X`'s **copy constructor**; 
  - alternatively, `f()`’s result might be constructed in `b`. ("copy elision")
- Likewise, a temporary might be used to hold the result of `g(Y(3))` before moving it to c using `Y`'s **move constructor**; 
  - alternatively, `g()`’s result might be constructed in `c`. ("copy elision")
- On the other hand, the expression `a=f(a)` requires a temporary for the result of `f(a),` which is then assigned to `a`.

# Functions

## scope

cppreference:
- **scope**: Each **name** that appears in a C++ program is only visible in some possibly discontiguous portion of the source code called its scope.
- **block scope**: 
  - The **potential scope** of a name declared in a **block (compound statement)** begins at the point of declaration and ends at the end of the block.
  - **Actual scope** is the same as potential scope unless an identical name is declared in a **nested block**, in which case the potential scope of the name in the nested block is excluded from the actual scope of the name in the enclosing block.
- **Function parameter scope**
  - **begin of scope**: The potential scope of a name declared in a function parameter (...) or of a function-local predefined variable **begins at** the point of declaration.
    - **end of scope 1**: If the enclosing function declarator is not the declarator of a function definition, its potential scope **ends at** the end of that function declarator.
    - **end of scope 2**: Otherwise, its potential scope **ends at** the end of the last exception handler of the function-try-block, or at the end of the function body if a function try block was not used. 

```cpp
// example: function parameter scope:
const int n = 3;
 
int f1(
    int n // scope of function parameter n begins,
          // scope of global n pauses
//  , int y = n // error: default argument references a function parameter
);
```

Inside class definitions:
- The definitions of the member functions of a class are **nested inside** the scope of **the class itself**.
  - Hence, if a member function uses a name of a data member, this name is resolved as the data member defined inside the class.
    - ie. we do not have to specify the data member's scope via a `className::` prefix

## inline functions

- A function specified as `inline` (usually) is expanded "in line" at each call. 
  - the word "usually" means that this expansion does not happen sometimes because the compiler can choose to ignore the `inline`! (see point below)
- inline functions may be defined multiple times in the program (unlike ordinary functions), but all definitions must match
  - therefore, inline functions normally are **defined in headers**
- `inline` removes the **run-time overhead** of using a normal function.
  - Explanation: **Calling** a function is likely to be slower than **evaluating** the equivalent expression.
    - On most machines, a **function call** does a lot of work:
      - Registers are saved before the call and restored after the return;
      - arguments may be copied; and
      - the program branches to a new location.
- The `inline` specification is only a **request** to the compiler.
  - The compiler may choose to ignore this request.
- In general, the inline mechanism is meant to optimize **small, straight-line functions that are called frequently**.
  - Many compilers will not inline a recursive function.
  - A 75-line function will almost surely not be expanded inline.
- 7.3.2: In practice, well-designed C++ programs tend to have lots of small (inline) functions such as `do_display`

## Default Arguments

- 6.5.1
- "A **default argument** is specified as an initializer for a parameter in the parameter list"
- Arguments in the call are **resolved** by position. The default arguments are used for the trailing (right-most) arguments of a call.
  - "if a parameter has a default argument, all the parameters that follow it must also have default arguments"
  - **general rule**: order the parameters so that those least likely to use a default value appear first!
- when re-declaring functions (recall, re-declaring functions is legal):
  - each parameter can have its default specified **only once**
  - defaults can be specified only if all parameters **to the right** already have defaults
  - **best practice**: Default arguments ordinarily should be specified with the function declaration in an appropriate header.
- changing the value of a default argument
  - you can **assign** a new default value to a default argument
  - do not try to change a default argument by "hiding" its name in a new scope (see the example in p. 237 and the corresponding explanation on p.238)
- "Function parameters are not allowed in default arguments (...).", [cppreference](https://en.cppreference.com/w/cpp/language/default_arguments)

```cpp
int f(int a, int b = a);          // Error: the parameter a used in a default argument
```

## return values

ignoring return values:
- "calling a function and ignoring the return result is *very* common", [stackoverflow](https://stackoverflow.com/a/38919156)
- eg. `printf("hello\n");` ignores the return value, [stackoverflow](https://stackoverflow.com/a/38919103)

## static functions

- see [static members](#static-members)
- see [stackoverflow](https://stackoverflow.com/a/15235626)

## member functions

- "member function bodies may use other members of their class regardless of where in the class those members appear" (see "compile order" in [Classes](#classes))
- "code is interpreted as being inside the scope of the class" (ie. eg. no need to use `this` to access members)

### implicit "this" parameter

- a `total.isbn()` call is translated like a `Sales_data::isbn(&total)` call
  - "the compiler passes the address of `total` to the implicit `this` parameter" (as if `Sales_data::isbn(Sales_data *const this)` were the function definition, see `passing_by_reference.c` - Listing 9.6)

### const member functions

"const member functions cannot change the object on which they are called."
- "The purpose of that `const` is to **modify the type of** the implicit `this` pointer." (see [this](#this))
  - **phth**: `this` is a `const` pointer, but the `const` following the parameter list makes it a pointer to `const` (see [pointer to const](#pointer-to-const))
  - "A `const` following the parameter list indicates that `this` is a pointer to `const`"

We can think of the `const` member 
```cpp
std::string isbn() const { return bookNo; }
```

as if it were written as
```cpp
// this code is illegal: we may not explicitly define the this pointer ourselves
std::string Sales_data::isbn(const Sales_data *const this) { return this->bookNo; }
```

[stackoverflow](https://stackoverflow.com/a/3141107)
- A "`const` function", denoted with the keyword `const` after a function declaration, makes it a compiler error for this class function to change a member variable of the class. However, reading of a class variables is okay inside of the function, but writing inside of this function will generate a compiler error.

### inline member functions

- member functions ...
  - defined inside the class: automatically inline
  - defined outside the class: need to specify as `inline`
  - declared inside the class: need to specify as `inline`
- inline member functions should be defined in the same header as the corresponding class definition (for the same reason as described for inline functions)
- it is legal to specify `inline` on both the declaration and the definition. 
  - **Best practice**: specifying `inline` only on the definition outside the class can make the class easier to read.

## Lambdas

From [learn.microsoft](https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170):
- In C++11 and later, a **lambda expression** - often called **a lambda** - is a convenient way of defining an anonymous function object (a closure) right at the location where it's invoked or passed as an argument to a function. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous functions.

## Return Value Optimization, RVO

### Return using Move instead of Copy

TODO

### Copy Elision

- for `return` statements: copy elision happens **in addition to** the "Move instead of Copy Trick" mentioned above

Initialization:
- a **copy** or **move constructor invocation** is often optimized away by constructing the object used to initialize right in the target object
  - among other things, this happens when copy or move constructors are invoked when functions `return` values (see [Copy Constructor](#copy-constructor), "called whenever ...")
- in the following example a compiler will typically construct the `X` from `make()` directly in `x`; thus eliminating ("eliding") a copy:

```cpp
X make(Sometype);   // create an "X" object named "make", calls the "X(Sometype)" constructor (defined in BS6.1.1)
X x = make(value);  // direct initialize "make" AND 
                    // copy initialize "x" (copying is not necessary because "make" was already created in "x")
```

Avoids Move Constructor Invocations:
- compiler is obliged (by the C++ standard) to eliminate most copies associated with initialization, so **move constructors** are not invoked
- eliminates (even) the very minor overhead of a move
- cppreference: "When the initializer is a prvalue, the move constructor call is often optimized out (...), see copy elision."

Does **not** avoid Move-Assignment Operator Invocations:
- The same is usually not possible for **assignments**.
  - ie. it is usually not possible to implicitly eliminate copy or move operations from assignments

**Prvalue semantics ("guaranteed copy elision")**:
- **phth:** "prvalues" sind im Prinzip die "rvalues", die bisher besprochen wurden
- Since C++17, a prvalue is not materialized until needed, and then it is constructed directly into the storage of its final destination. 
  - This sometimes means that even when the language syntax visually suggests a copy/move (e.g. copy initialization), no copy/move is performed
  - examples:

```cpp
// from: https://en.cppreference.com/w/cpp/language/copy_elision
// phth: brackets "[]" by me

// Example 1: Initializing the returned object in a return statement, when the operand is a prvalue of the same class type (ignoring cv-qualification) as the function return type:
T f()           // [return type of f is nonreference, ie. a prvalue]
{
    return U(); // constructs a [nameless] temporary of type U,
                // then [copy] initializes the returned T from the temporary [using T's copy/move constructor]
}
T g()           // [return type of g is nonreference, ie. a prvalue]
{
    return T(); // constructs the returned T directly; no move
}
// The destructor of the type returned must be accessible at the point of the return statement and non-deleted, even though no T object is destroyed. 
```

```cpp
// Example 2: In the initialization of an object, when the initializer expression is a prvalue of the same class type (ignoring cv-qualification) as the variable type:
// phth: 
// - f() (from Example 1) returns a nameless temporary object of nonreference type T, ie a prvalue
// - T() returns a nameless temporary object of nonreference type T, ie a prvalue
T x = T(T(f())); // x is initialized by the result of f() directly; no move
```

## Functions with Varying Parameters

- Sometimes we do not know in advance **how many arguments** we need to pass to a function
- **two primary ways** to write a function that takes a varying number of arguments
  - if all the arguments have the same type
    - pass a library type named `initializer_list`
  - if the argument types vary
    - write a special kind of function, known as a [variadic template](#variadic-templates)
- ellipsis
  - special parameter type
  - can be used to pass a varying number of arguments
  - should be used only in programs that need to interface to C functions

### `initializer_list`

- a library type 
- a template type
- represents an array of values of the specified type
- defined in the `initializer_list` header
- elements are always `const` values
  - there is no way to change the value of an element
- operations:

```cpp
initializer_list<T> lst; // Default initialization; an empty list of elements of type T.
initializer_list<T> lst{a,b,c...};
                // lst has as many elements as there are initializers; elements are copies of
                // the corresponding initializers. Elements in the list are const.
lst2(lst)   // Copying or assigning an initializer_list does not copy the elements
lst2 = lst  // in the list. After the copy, the original and the copy share the elements.
lst.size()  // Number of elements in the list.
lst.begin() // Returns a pointer to the first and one past the last element in lst.
lst.end()
```

- When we pass a sequence of values to an `initializer_list` parameter, we must enclose the sequence in curly braces

```cpp
void error_msg(initializer_list<string> il)
{
  for (auto beg = il.begin(); beg != il.end(); ++beg)
    cout << *beg << " ";
  cout << endl;
}

// expected, actual are strings
if (expected != actual)
  error_msg({"functionX", expected, actual});
else
  error_msg({"functionX", "okay"});
```

- we can use a **range for** to process the elements

```cpp
void error_msg(ErrCode e, initializer_list<string> il)
{
  cout << e.msg() << ": ";
  for (const auto &elem : il)
    cout << elem << " " ;
  cout << endl;
}
```

## return

- Values are returned in exactly the same way as variables and parameters are initialized: 
  - The **return value** is used to **initialize** a **temporary** at the call site, and that temporary is the result of the function call.

### Return a Reference

Examples:

```cpp
// Return a reference to the shorter of two strings:

// The strings are not copied when the function is called or when the result is returned
const string &shorterString(const string &s1, const string &s2)
{
  return s1.size() <= s2.size() ? s1 : s2;
}

// Never Return a Reference or Pointer TO A LOCAL OBJECT:

// disaster: this function returns a reference to a local object
const string &manip()
{
  string ret;
  // transform ret in some way
  if (!ret.empty())
    return ret;       // WRONG: returning a reference to a local object!
  else
    return "Empty";   // WRONG: "Empty" is a local temporary string
}
```

# Classes

- "Classes are user-defined types, defined by class-specifier"
- The **class specifier** has the following syntax: 
  - `class-key attr(optional) class-head-name final(optional) base-clause(optional) { member-specification }`
- `class-key`
  - one of `class`, `struct` and `union`. 
    - The keywords `class` and `struct` are identical except for 
      - the default member access and
      - the default base class access.
    - If it is `union`, the declaration introduces a union type. 
- declaration of **objects**:
  - `class ClassName item1;` (inherited from C) is equivalent to `ClassName item1;`
- **forward declaration:** declare a class without defining it
  - **incomplete type:** After a declaration and before a definition is seen, the class type is an **incomplete type** - it's known that the type is a class type but not known what members that type contains
  - A class must be **defined** - not just declared - before
    - we can write code that **creates objects** of that type
    - a reference or pointer is used to **access a member** of the type
- a class 
  - **cannot** have data members of its own type
  - **can** have data members that are pointers or references to its own type

## Compile Order

compile order: **two steps** 

1. **member declarations**
2. **member function bodies**, if any

Therefore, data members can be used inside member function bodies, **even if** the data members are declared **after** the member function bodies.

## Class Types

### struct

- `struct` is a `class-key` (see above)
- when we define a class intending for all of its members to be `public`, we use `struct`. 
  - If we intend to have `private` members, then we use `class`.

From [stackoverflow](https://stackoverflow.com/a/1127406):
- In C++ the only difference between a `class` and a `struct` is that members and base classes are `private` by default in classes, whereas they are `public` by default in structs.
- So structs can have **constructors**, and the syntax is the same as for classes.

Why use `typedef struct`?

From [Why should we typedef a struct so often in C? - Stack Overflow](https://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c):
- no longer have to write `struct` all over the place
- can make the code cleaner since it provides a smidgen **more abstraction**

### union

- `union` is a `class-key` (see above)
- "A `union` is a special **class type** that can hold only one of its non-static data members at a time."
- like a "room in a hotel", [stackoverflow](https://stackoverflow.com/a/2313676)

## Constructors

- "Constructors do not have names" (`[class.ctor]`, N3337)
- "Classes control object **initialization** by defining one or more **special member functions** known as **constructors**."
- order:
  - 1) base members
  - 2) members are initialized in the [constructor initializer list](#constructor-initializer-list)
    - members **omitted** in the constructor initializer list are **default initialized** 
      - proofs: cppreference: 
        - in "Default Initialization": "3) when a base class or a non-static data member is not mentioned in a constructor initializer list and that constructor is called."
        - in "Constructors and member initializer lists": "The **member initializer list** is the place where **non-default initialization** of these (data member) objects can be specified.", implies that default initialization is the default behavior (for omitted data members)
  - 3) the constructor body is executed
    - members can be **assigned** in the constructor body, but they cannot be **initialized** there!
- Constructors 
  - have the same **name** as the class.
  - control 
    - object **initialization**
    - what happens when we **copy**, **assign**, or **destroy** objects of the class type
      - **copy**: 
        - when we initialize a variable or 
        - when we pass or return an object by value
      - **assign**: when we use the assignment operator
      - **destroy**: 
        - local object: destroyed on exit from the block in which it was created
        - Objects stored in a `vector` (or an array): destroyed when that `vector` (or array) is destroyed
      - If we do **not** define these operations, the compiler will **synthesize** them for us. 
        - the versions that the compiler generates for us execute by copying, assigning, or destroying **each member** of the object
        - **Warning:** "classes that manage dynamic memory, generally **cannot** rely on the synthesized versions of these operations"
          - but if you use `vector` and `string` to manage dynamic memory the synthesized versions for copy, assignment and destruction will work
  - are special member functions, but
    - have no return type
    - must not be declared as `const`
- a class may have multiple constructors (&rarr; overloading)
- can write to `const` objects during their construction

### Default Constructor

- "a constructor which can be called with no arguments" (cppreference)
- "called during 
  - **default initializations** and 
  - **value initializations**"
- 1) **explicitly defined default constructor**
- 2) **synthesized default constructor** (implicitly defined default constructor)
  - the compiler **implicitly** defines this constructor, if we do not explicitly define one
    - but **only if** a class declares **NO** constructors
  - member initialization
    - if there is an **in-class initializer**, use it to initialize the member
    - else **default initialize** the member
- situations in which we **must** explicitly define a default constructor:
  - 1. we have defined at least one constructor, and therefore, the compiler will not generate a default constructor
  - 2. to make sure that **class members** of **built-in types** or **compound types** cannot end up **uninitialized**
    - **in blocks**: objects of built-in or compound type that are defined inside a block have **undefined value** when they are default initialized (see ["Default Initialization"](#default-initialization))
  - 3. when the compiler cannot synthesize a default constructor
- defaulted default constructor
  - C++11
  - we can ask the compiler to generate the constructor for us by writing `= default` after the parameter list
    - this constructor does exactly the same work as the synthesized default constructor
- **best practice:**
  - "it is almost always right to provide a default constructor if other constructors are being defined."
- see [default arguments](#default-arguments):
  - "A constructor that supplies default arguments **for all its parameters** also defines the default constructor." (7.5.1 "Default Arguments and Constructors")

### Constructor Initializer List

In cppreference: **"member initializer list"**
- "The body of a function definition of any constructor, before the opening brace of the compound statement (see [statements](#statements)), may include the **member initializer list**, whose syntax is the colon character `:`, followed by the comma-separated list of one or more member-initializers, each of which has the following syntax ..."
- "Before the compound statement that forms the function body of the constructor begins executing, initialization of all direct bases, virtual bases, and non-static data members is finished. The **member initializer list** is the place where **non-default initialization** of these objects can be specified."
  - thus, all members omitted in the member initializer list are **default initialized**

Omitted Members:
- When a member is omitted from the constructor initializer list, it is implicitly initialized **using the same process as is used by the synthesized default constructor** (7.1.4 "Constructors" &rarr; "Constructor Initializer List")
  - **best practice:** 
    - constructors should "use an in-class initializer if one exists and gives the member the correct value", i.e. "constructors should not override in-class initializers"
    - **phth**: if there are no in-class initializers for a class **or** your compiler does not support in-class initializers, then **built-in types** must be explicitly initialized in the constructor initializer list (because otherwise they will be uninitialized, see "synthesized default constructor")
- "If we do not explicitly initialize a member in the constructor initializer list, that member is **default initialized** before the constructor body starts executing" (7.5.1 "Constructors Revisited" &rarr; "Constructor Initializer List")

Initialization vs Assignment:
- if you do not use constructor initializers, you do not **"initialize"** the members, but you **"assign"** values to the members (recall, in C++: assign != initialize) (7.5.1 "Constructors Revisited" &rarr; "Constructor Initializer List")

When constructor initializer is **required**:
- "We **must** use the constructor initializer list to provide values for members that are ...
  - `const`, 
  - reference, or 
  - of a `class` type that does not have a default constructor."
- **best practice**: By routinely using constructor initializers, you can avoid being surprised by compile-time errors when you have a class with a member that **requires** a constructor initializer

**best practice**:
- order of member initialization
  - write constructor initializers in the same order as the members are declared. 
  - when possible, avoid using members to initialize other members.
  - write member initializers to use the constructor's parameters rather than another data member from the same object (see example in 7.5.1)

### Delegating Constructor

- "In a delegating constructor, the **member initializer list** has a single entry that is **the name of the class itself**. Like other member initializers, the name of the class is followed by a parenthesized list of arguments. The argument list must match another constructor in the class."

### Converting Constructor

- **Implicit Class-Type Conversion**
- cppreference: "Implicit conversion is defined in terms of copy-initialization: if an object of type T can be copy-initialized with expression E, then E is **implicitly convertible** to T."
- "A constructor that can be called with a **single argument** defines an implicit conversion **from** the constructor's parameter type **to** the class type."
- **only one** implicit class type conversion is allowed (p.295)

#### explicit

- **disable** the implicit conversion by declaring the converting constructor as `explicit`
  - you can use `explicit` on constructors with **a single argument** only
  - use `explicit` only on the constructor declaration inside the class
  - `explicit` constructors can be used only with **direct initialization** (see Example 1)
    - because copy initialization triggers an implicit class type conversion which the `explicit` does not allow
- "use `explicit` for constructors that take a single argument unless there is a good reason not to" (BS6.1.2)

**Example 1**:

```cpp
Sales_data item1(null_book); // ok: direct initialization
// error: cannot use the copy form of initialization with an explicit constructor
Sales_data item2 = null_book;
```

**Example 2**:
- the `vector` constructor that takes a single size parameter is `explicit`

```cpp
void f(vector<int>); // f’s parameter is copy initialized
f(10); // error: can’t use an explicit constructor to copy an argument
f(vector<int>(10)); // ok: directly construct a temporary vector from an int
```

## Copy Control

- controlled by 5 **special member functions** ("copy-control members"):
  - copy constructor, 
  - copy-assignment operator, 
  - move constructor, 
  - move-assignment operator, and 
  - destructor
- "If a class does not define all of the copy-control members, the compiler **automatically defines** the missing operations"
  - **member-wise**: "the versions that the compiler generates for us execute by copying, assigning, or destroying **each member** of the object."

### Copy Constructor

- used for **initialization** (direct and copy forms), whereas the Copy-Assignment Operator is used for **assignment**

Lippman, 13.1.1 "The Copy Constructor"
- "A constructor is the copy constructor if 
  - its **first parameter** is a **reference to the class type** (eg. `T&`, `const T&`) and 
  - any **additional parameters** have default values"
- "almost always a reference to `const`" (although it can be a reference to nonconst)
- "the copy constructor usually should **not** be `explicit`" 
  - because it is often used for **implicit conversion** (see [converting constructor](#converting-constructor))

```cpp
class Foo {
public:
  Foo();             // default constructor
  Foo(const Foo&);   // copy constructor
  // ...
};
```

- "called whenever an object is initialized (by **direct-initialization** or **copy-initialization**) from another object of the same type, which includes"
  - **initialization**: `T a = b;` or `T a(b);`, where `b` is of type `T`;
  - **function argument passing**: `f(a);`, where `a` is of type `T` and `f` is `void f(T t);`
  - **function return**: `return a;` inside a function such as `T f()`, where `a` is of type `T`, which has no move constructor. 
- "the compiler is permitted (but not obligated) to skip the copy/move constructor and create the object directly" (see Example 1)

Example 1:

```cpp
string null_book = "9-999-99999-9"; // copy initialization
// may be rewritten to
string null_book("9-999-99999-9"); // compiler omits the copy constructor
```

Defined as deleted (see p.508, 538), if
- the class has a member whose own copy constructor is deleted or inaccessible. 
- the class has a member with a deleted or inaccessible destructor.
- see "synthesized as deleted" in section ["delete"](#delete)
  - in essence, if a class has a **data member** that **cannot** be default constructed, copied, assigned, or destroyed, then the corresponding copy-control member will be a deleted function
- we define a move constructor

#### Synthesized Copy Constructor

- for some classes disallows copying objects of that class type
- copies the members of its argument into the object being created **memberwise**
- unlike the synthesized default constructor, it is synthesized **even if** we define other constructors
- the synthesized constructor is **equivalent to** using a **constructor initializer list**, see example on p.497
- **always** uses **direct initialization**
  - if the synthesized copy constructor belongs to a `class` or `struct`, but not if it belongs to a `union`
  - **cppreference**: "For non-union class types (`class` and `struct`), the constructor performs full member-wise copy of the object's bases and non-static members, in their initialization order, using **direct initialization**."
- type of member determines how the member is copied
  - **class type**: copied by the class' copy constructor (using direct initialization)
  - **built-in type**: copied directly (direct initialization)
  - **array**: copied elementwise (using direct initialization)
- problem with pointer members:
  - see [Memberwise Assignment Example](https://www.cs.mtsu.edu/~xyang/2170/copyconstructor.html)
    - In class `StudentTestScores` the member `testScores` is a pointer. In `StudentTestScores student2 = student1;` `student2`'s `testScroes` member simply gets a **copy of the address** stored in `student1`'s `testScores` member. Both pointers will point to the same address.

### Copy-Assignment Operator

- "a (...) member function with the name `operator=` that takes **exactly one parameter** of type `T`, `T&`, `const T&`"

```cpp
class-name & class-name ::operator= ( const class-name & )   // (2)
```

- used for **assignment**, whereas the Copy Constructor is used for **initialization**
- "called whenever selected by overload resolution, e.g. when an object appears on the left side of an assignment expression"

Defined as deleted (see p.508, 538), if
- a member has a deleted or inaccessible copy-assignment operator, or 
- the class has a `const` or reference member.
- see "synthesized as deleted" in section ["delete"](#delete)
  - in essence, if a class has a **data member** that **cannot** be default constructed, copied, assigned, or destroyed, then the corresponding copy-control member will be a deleted function
- we define a move-assignment operator

#### Synthesized Copy-Assignment Operator

```cpp
T& T::operator=(const T&)
// or:
T& T::operator=(T&)
```

- for some classes disallows assignment
- analogue to synthesized copy constructor
- memberwise: **assign** each member of rhs object to lhs object (using copy-assignment operator for the type of that member)
  - arrays: elementwise
- returns a **reference to** its lhs object (via `return *this`)

#### Valuelike Copy-Assignment Operator

- **combine** the actions of the **destructor** and the **copy constructor**
- must handle self-assignment
  - always create a local temporary before using `delete` (see example below)
- must be exception safe
  - ie. will leave the left-hand operand in a sensible state should an exception occur
    - If an exception occurs, it will happen **before** we have changed the left-hand operand.
- a good pattern to use:

```cpp
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);  // copy the underlying string (into a local temporary)
  delete ps;                        // free the old memory
  ps = newp;                        // copy data from rhs (now in the temporary) into this object
  i = rhs.i;
  return *this;                     // return this object
}
```

#### Pointerlike Copy-Assignment Operator

Ways to implement:
1. easiest way: use `shared_ptrs` to manage the resources in the class.
2. Sometimes we want to manage a resource directly. In such cases, it can be useful to use a **reference count**.

Reference Counting:
1. In addition to initializing the object, each constructor (other than the copy constructor) creates a counter (which is in stored in dynamic memory).
2. The copy constructor increments the **shared** counter.
3. The destructor decrements the counter.
4. The copy-assignment operator increments the right-hand operand's counter and decrements the counter of the left-hand operand. If the counter for the left-hand operand goes to zero, the copy-assignment operator must destroy the state of the left-hand operand.

```cpp
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  ++*rhs.use;                   // increment the use count of the right-hand operand
  if (--*use == 0) {            // then decrement this object's counter
    delete ps;                  // if no other users
    delete use;                 // free this object's allocated members
  }
  ps = rhs.ps;                  // copy data from rhs into this object
  i = rhs.i;
  use = rhs.use;
  return *this;                 // return this object
}
```

#### Copy-and-Swap Assignment Operator

- classes **that manage resources** often also define a function named `swap`
  - particularly important for classes that we plan to use with **algorithms** that reorder elements
    - If a class defines its own `swap`, then the algorithm uses that class-specific version.
    - Otherwise, it uses the `swap` function defined by the library.
- the library `swap` makes unnecessary copies, so define a custom version for your class

The idea:

```cpp
// the library's "swap":
// will make three copy operations
// (none of these 3 memory allocations is necessary)
HasPtr temp = v1;     // make a temporary copy of the value of v1 (1st copy of the string that was originally in v1)
v1 = v2;              // assign the value of v2 to v1 (a copy of the string that was originally in v2)
v2 = temp;            // assign the saved value of v1 to v2 (2nd copy of the string that was originally in v1)

// better, our "swap":
// only "swap the pointers"
string *temp = v1.ps;   // make a temporary copy of the pointer in v1.ps
v1.ps = v2.ps;          // assign the pointer in v2.ps to v1.ps        
v2.ps = temp;           // assign the saved pointer in v1.ps to v2.ps  
```

A `swap` function and Copy-and-Swap Assignment Operator for the `HasPtr` class:

```cpp
class HasPtr {
  friend void swap(HasPtr&, HasPtr&);
  // other members as in § 13.2.1 (p. 511)
};
inline
void swap(HasPtr &lhs, HasPtr &rhs)
{
  using std::swap;        // does NOT hide the declarations for the HasPtr version of swap
                          // - type-specific version of swap will be a better match
                          // - library version of swap will be used, if there is no type-specific version
  swap(lhs.ps, rhs.ps);   // swap the pointers, not the string data
  swap(lhs.i, rhs.i);     // swap the int members
}

// note rhs is passed by value, which means the HasPtr copy constructor
// copies the string in the right-hand operand into rhs
HasPtr& HasPtr::operator=(HasPtr rhs)
{
  // swap the contents of the left-hand operand with the local variable rhs
  swap(*this, rhs);   // rhs now points to the memory this object had used
  return *this;       // rhs is destroyed, which deletes the pointer in rhs
}
```

Assignment operators that use copy and swap ...
- are automatically **exception safe**
  - ie. will leave the left-hand operand in a sensible state should an exception occur
    - The only code that might throw is the `new` expression inside the copy constructor.
    - If an exception occurs, it will happen **before** we have changed the left-hand operand.
- correctly handle **self-assignment**

### Destructor

```cpp
~ class-name ();
```

- "is the complement of a constructor" (BS5.2.2)
- "called when the lifetime of an object ends."
- "The purpose of the destructor is to free the resources that the object may have acquired during its lifetime."
- no return value
- takes no parameters
- order:
  - 1) function body is executed
    - typically, frees resources an object allocated during its lifetime
  - 2) (nonstatic) members are destroyed
    - in reverse order from the order in which they were initialized
- destruction part is **implicit**
  - cannot control how members are destroyed
    - whereas **for constructors** constructor initializer lists **can** control how members are initialized
- what happens when a member is destroyed:
  - **class type**: 
    - running the member's own destructor
  - **built-in types**:
    - do not have destructors, so nothing is done
  - **built-in pointer type**: 
    - does not `delete` the object to which that pointer points
      - **Note:** if you want to `delete` the object use **smart pointers** (which are class types)
- called when
  - **variables**: when they go out of scope
  - **members** of an object: when the object is destroyed
  - **elements of a container**: when a container is destroyed
  - **dynamically allocated objects**: `delete` is applied to a pointer to the object
  - **temporaries**: at the end of the creating expression
- not called when 
  - a **reference** to an object goes out of scope
  - a **pointer** to an object goes out of scope

Defined as deleted (p. 508), if
- the class has a member whose own destructor is deleted or is inaccessible (e.g., `private`).
- see "synthesized as deleted" in section ["delete"](#delete)
  - in essence, if a class has a **data member** that **cannot** be default constructed, copied, assigned, or destroyed, then the corresponding copy-control member will be a deleted function

#### Synthesized Destructor

- is automatically defined for any class that does not define its own destructor
- for some classes disallows destruction
- otherwise, the synthesized destructor has an empty function body
- members are automatically destroyed **AFTER** the (empty) destructor body is run
  - **Important**: Members are destroyed as part of the implicit destruction phase **that follows** the destructor body
- example
```cpp
// no work to do other than destroying the members, which happens automatically AFTER the destructor body
~Sales_data() { }   // equivalent to the synthesized `Sales_data` destructor
```

#### Destructors throwing Exceptions

- destructors should never throw exceptions that the destructor itself does not handle
  - **best practice:** if a destructor does an operation that might throw, it should wrap that operation in a `try` block and handle it **locally to** the destructor.
- in practice, because destructors free resources (and do not allocate &rarr; `bad_alloc` exception), it is **unlikely** that they will throw exceptions
  - All of the standard library types guarantee that their destructors will not raise an exception

### Rule of Zero/Three/Five

- **Rule of Zero/Three/Five:** define all of the copy-control members or none (using the default for all)
  - it is unusual to need one without needing to define them all
- **rule 1**: "Classes That Need Destructors Need Copy and Assignment"
  - decide first whether the class needs a destructor (often more obvious than the need for copy constructor or assignment operator)
  - if the class needs a destructor, it almost surely needs a copy constructor and copy-assignment operator as well
- **rule 2**: "Classes That Need Copy Need Assignment, and Vice Versa"
- why these rules? &rarr; read examples in the book
- **rule 3**: "When a class has a pointer member, it is usually a good idea to be explicit about copy and move operations" (BS6.1.1)
  - "Classes that define their own copy constructor and copy-assignment operator generally also benefit by defining the move operations" (Lippman)

### Moving Objects

- useful if
  - an object is immediately destroyed after it is copied
    - here, moving can provide a significant performance boost compared to copying
  - for classes that have a **resource** that may not be shared
    - Hence, objects of these types **cannot** be copied but can be moved
    - examples 
      - the IO classes (resource: an IO buffer)
      - `unique_ptr` class (resource: a pointer)
- copying is expensive if the objects
  - are large
  - themselves require memory allocation (e.g., `strings`)
- examples of classes that support 
  - move as well as copy: `string`, `shared_ptr`
  - move, but not copy: IO classes, `unique_ptr`
- [Rvalue References](#rvalue-references) were introduced by the new standard to support move operations

```cpp
// Rvalues Are Moved, Lvalues Are Copied
// - constructor is chosen by ordinary function matching
StrVec v1, v2;
v1 = v2;                      // v2 is an lvalue; copy assignment
StrVec getVec(istream &);     // getVec returns an rvalue
v2 = getVec(cin);             // getVec(cin) is an rvalue; move assignment (because StrVec&& is an exact match)

// But Rvalues Are Copied If There Is No Move Constructor
// - even if we attempt to move them by calling std::move
class Foo {
  public:
    Foo() = default;
    Foo(const Foo&); // copy constructor
    // other members, but Foo does not define a move constructor
};
Foo x;
Foo y(x);               // copy constructor; x is an lvalue
Foo z(std::move(x));    // copy constructor, because there is no move constructor (no problem, this is safe!)
```

### Both Move Operations

The move constructor and move-assignment operator are defined as **deleted**, if
- in general, a move operation is never implicitly defined as a **deleted** function
- if we explicitly ask the compiler to generate a move operation by using `= default`, and the compiler is unable to move all the members, then the move operation will be defined as **deleted**
- rules (see p.538) for when a **synthesized** move operation is defined as deleted are analogous to those for the copy operations with **one exception**
  - **the exception**: if the class has a member that 
    - defines its own copy constructor but does not also define a move constructor, or 
    - doesn't define its own copy operations and for which the compiler is unable to synthesize a move constructor.
  - otherwise, see "synthesized as deleted" in section ["delete"](#delete)
    - in essence, if a class has a **data member** that **cannot** be default constructed, copied, assigned, or destroyed, then the corresponding copy-control member will be a deleted function

```cpp
// assume Y is a class that defines its own copy constructor but not a move constructor
struct hasY {
  hasY() = default;
  hasY(hasY&&) = default;
  Y mem; // hasY will have a deleted move constructor
};
hasY hy, hy2 = std::move(hy); // error: move constructor is deleted
```

### Move Constructor

- "a non-template constructor whose first parameter is `T&&`, `const T&&`, (...) and either there are no other parameters, or the rest of the parameters all have default values"
- "The move constructor is typically called when an object is initialized (by **direct-initialization** or **copy-initialization**) from rvalue (xvalue or prvalue) (...) of the same type, including
  - **initialization**: `T a = std::move(b);` or `T a(std::move(b));`, where `b` is of type `T`;
  - **function argument passing**: `f(std::move(a));`, where a is of type `T` and `f` is `void f(T t);`
  - **function return**: `return a;` inside a function such as `T f()`, where a is of type `T` which has a move constructor."
- "Move constructors typically "steal" the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc.) rather than make copies of them, and leave the argument in some **valid** but otherwise indeterminate state."
  - **valid object**: see [move assignment operator](#move-assignment-operator)

Lippman
- 1st parameter is an **rvalue reference** to the class type
- additional parameters must all have default arguments (like for the copy constructor)
- **destructible state:** must ensure that the moved-from object is left in a state such that destroying that object will be "harmless"
  - original object must no longer point to those moved resources
  - **phth:** eg. by resetting pointer members of the **moved-from** object (= the original object) to `nullptr`, otherwise, when the **moved-from** object gets destroyed, the destructor of the **moved-from** object will `delete` the memory to which the **moved-to** object's (= the copied object's) pointer members point
- unlike a copy constructor, the move constructor **does not** itself **allocate** any resources, it **takes over** resources
  - thus, will not throw any exceptions

```cpp
StrVec::StrVec(StrVec &&s) noexcept // move won't throw any exceptions
  // member initializers take over the resources in s
  : elements(s.elements), first_free(s.first_free), cap(s.cap)
{
  // leave s in a state in which it is safe to run the destructor
  s.elements = s.first_free = s.cap = nullptr;
}
```

- `noexcept`
  - a way to promise that a function does not throw any exceptions
  - move constructors and move assignment operators that cannot throw exceptions **should** be marked as `noexcept`
  - why is `noexcept` needed?
    - unless the library knows that our move constructor will not throw, it will do **extra work** to cater to the possibliity that moving an object of our class type might throw.
    - without `noexcept` (specified on the element type's move constructor), in circumstances such as `vector<elementType>` reallocation, eg. when we call `push_back`, `vector<elementType>` **MUST** use `elementType`'s copy constructor instead of `elementType`'s move constructor
      - why "MUST"? - because `vector` guarantees that if an exception happens when we call `push_back`, the `vector` itself will be left unchanged (however, using a move constructor changes the `vector` itself and may possibly throw an exception)
        - (similarly, other **library containers** also provide guarantees as to what they do if an exception happens)
      - `vector` reallocation happens 
      - more detailed explanation (see p.536)

```cpp
// must specify on both:
// - the declaration in the class header
// - the definition if that definition appears outside the class
class StrVec {
  public:
    StrVec(StrVec&&) noexcept; // move constructor
    // other members as before
};
StrVec::StrVec(StrVec &&s) noexcept : /* member initializers */
{ /* constructor body */ }
```

BS
- a move constructor is supposed to remove ("steal") the value from its argument.
- Examples
  - an integer returned by a function call is never used again, so you can safely "steal" its value/resources/state
- After a move, the moved-from object should be in a state that allows a **destructor** to be run

#### std::move

- calls the move constructor
  - eg. "initialization: `T a = std::move(b);` or `T a(std::move(b));`, where `b` is of type `T`"
- **explicitly casts** an lvalue to its corresponding rvalue reference type
- in the `utility` header
- returns an rvalue reference to its given object
  - "It is exactly equivalent to a `static_cast` to an rvalue reference type." (cppreference)
- **problem:** we cannot directly bind `rr1` to `&&rr2`
  - **solution:** we can explicitly cast `rr1` using `std::move`:

```cpp
int &&rr1 = 42;             // ok: literals are rvalues
int &&rr2 = rr1;            // error: the expression rr1 is an lvalue!
int &&rr3 = std::move(rr1); // ok
```

- after a call to `std::move` 
  - we **cannot** use 
    - `rr1`
    - the value of a moved-from object
  - we **can** 
    - assign to it
    - destroy it
- **best practice:** 
  - always call `std::move` not `move`
  - do not use `std::move` casually:
    - Casually used in ordinary user code (as opposed to class implementation code), moving an object is more likely to lead to mysterious and hard-to-find bugs than to any improvement in the performance of the application.
  - Outside of class implementation code such as **move constructors** or **move-assignment operators**, use `std::move` only when you are certain 
    - that you need to do a move and 
    - that the move is guaranteed to be safe
      - we must be absolutely certain that there can be no other users of the moved-from object

BS
- `std::move`
- doesn't actually move anything
- returns an **rvalue reference** (a reference to its argument from which we may move)
- it is a kind of cast

#### Synthesized Move Constructor

Conditions under which the compiler synthesizes:
- **copy**:
  - recall, **always** synthesized (if we do not declare our own **copy constructor** or **copy-assignment operator**)
- **move**:
  - are **not** synthesized, if
    - a class defines its own copy constructor, copy-assignment operator, or destructor
      - thus, some classes do not have a move constructor or a move-assignment operator &rarr; copy is used in place of move
  - are synthesized, **only** if
    - the class doesn't define any of its own copy-control members **and** every nonstatic data member of the class **can be moved**
      - The compiler **can move**
        - members of built-in type.
        - members of a class type **if** the member's class has the corresponding move operation

```cpp
// the compiler will synthesize the move operations for X and hasX
struct X {
  int i;          // built-in types can be moved
  std::string s;  // string defines its own move operations
};
struct hasX {
  X mem;          // X has synthesized move operations
};
X x, x2 = std::move(x);         // uses the synthesized move constructor
hasX hx, hx2 = std::move(hx);   // uses the synthesized move constructor
```

### Move-Assignment Operator

- "a non-template non-static member function with the name `operator=` that takes exactly one parameter (...) of type `T&&,` `const T&&`, `volatile T&&`, or `const volatile T&&`."

```cpp
class-name& class-name::operator=(class-name&&) 	// (1)
```

- **called when the rhs is an rvalue:**
  - "is called whenever it is selected by overload resolution, e.g. when an object appears on the left-hand side of an assignment expression, where the **right-hand side is an rvalue** of the same or implicitly convertible type."

Lippman:
- A move assignment is defined similarly (as the move constructor)
  - it is supposed to remove the value from its argument
- does the same work as the **destructor** and the **move constructor**
- if it will not throw any exceptions, we **should** make it `noexcept` 
  - to prevent library containers from automatically using the copy constructor in circumstances such as `vector` reallocation (see section ["Move Constructor"](#move-constructor))
- like a copy-assignment operator
  - must guard against self-assignment

```cpp
StrVec &StrVec::operator=(StrVec &&rhs) noexcept
{
  // direct test for self-assignment "if (this != &rhs)":
  // why is this test necessary?
  // - when "a = a;", then the move assignment operator would NOT be called because the rhs "a" is an lvalue.
  // - when "a = std::move(a);", then the move assignment operator would be called because the rhs "std::move(a)" is an rvalue. 
  //   - in this case, "this == &r" would be true, so that the if condition "if (this != &rhs)" is necessary to prevent this form of self-assignment
  if (this != &rhs) {
    free();                     // free existing elements
    elements = rhs.elements;    // take over resources from rhs
    first_free = rhs.first_free;
    cap = rhs.cap;
    // leave rhs in a destructible state
    rhs.elements = rhs.first_free = rhs.cap = nullptr;
  }
  return *this;
}
```

**requirements** (like the move constructor):
1. **destructible state:** must ensure that the moved-from object is in a state in which the destructor can be run
  - eg. by setting the pointer members of the moved-from object to `nullptr`
2. **valid:** must guarantee that the object remains valid
  - **valid object:** one that can safely be given a new value or used in other ways that do not depend on its current value
  - example: 
    - move from a `string` or container object: 
      - we know that the moved-from object remains valid. 
        - As a result, we can run operations such as as `empty` or `size` on moved-from objects.
      - However, we **don't know** what result we'll get.
      - therefore, programs should never depend on the value of a moved-from object!

#### Copy-and-Swap Assignment and Move

The assignment operator has a nonreference parameter, which means the parameter is **copy initialized**.
- Depending on the type of the argument, copy initialization uses either the copy constructor or the move constructor; lvalues are copied and rvalues are moved. 
- As a result, this single assignment operator **acts as both** the copy-assignment and move-assignment operator.

```cpp
class HasPtr {
  public:
    // added move constructor
    HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) {p.ps = 0;}
    // assignment operator is both the move- and copy-assignment operator
    HasPtr& operator=(HasPtr rhs)
                { swap(*this, rhs); return *this; }
    // other members as in § 13.2.1 (p. 511)
};
```

## Access Control and Encapsulation

- "encapsulate" the implementation = "hide" the implementation

### Access Specifiers

access Specifiers (to enforce encapsulation, i.e. hiding of implementation details)
- `public` members: defines the interface
- `private` members: encapsulate (i.e., hide) the implementation

The only difference between `struct` and `class` is the **default access level**:
- If we use the `struct` keyword, the members defined before the first access specifier are `public`
- if we use `class`, then the members are `private`

Best practice:
- When we define a class intending for all of its members to be `public`, we use `struct`. 
- If we intend to have `private` members, then we use `class`.

Benefits of Encapsulation:
- User code cannot inadvertently corrupt the state of an encapsulated object.
- The implementation of an encapsulated class can change over time without requiring changes in user-level code.

### Friends

- A class can allow another class or function to **access its nonpublic members** by making that class or function a `friend`
  - `friend` declarations 
    - may appear only inside a class definition
    - may appear anywhere in the class
  - `friend` function definitions
    - `friend` function can be **defined** inside the class body (7.3.4)
      - such functions are implicitly `inline`
- friends
  - are not members
  - are not affected by the access control of the section in which they are declared
- A friend declaration **is not a general declaration** of the function. 
  - we must also declare the function **separately** from the friend declaration (some compilers do not require this, but this is best practice)
  - **best practice**:
    - group `friend` declarations together at the beginning or end of the class definition
    - in addition to the `friend` declaration, declare each friend (outside the class) in the same header as the class
- friendship is not transitive

## Member Function

### Special Member Function

source: cppreference

**special member function:** Some member functions are **"special"**: under certain circumstances they are defined by the compiler even if not defined by the user. They are:
- Default constructor
- Copy constructor 
- Move constructor 
- Copy assignment operator 
- Move assignment operator 
- Destructor 

**defaulted function:** Special member functions are the only functions that can be **"defaulted"**, that is, defined using `= default` instead of the function body. (from: [cppreference: member functions](https://en.cppreference.com/w/cpp/language/member_functions))

### Functions that return *this

Such functions 
- return a **reference** to the object on which they are called
- are **lvalues**, which means that they return the object itself, **not a copy** of the object.

**Motivation**: Without such functions we cannot execute a **sequence** of operations **on the same object**, such as

```cpp
// move the cursor to a given position, and set that character
myScreen.move(4,0).set('#');
```

- you can also call a member function based on whether 

## Data Member

## Type Member

- a class can define its own (local) types
  - this type names may be either `public` or `private`
- unlike ordinary members, members that define types **must appear before they are used**
  - **best practice**: as a result, type members usually appear **at the beginning of the class**

## ::ClassName

From [stackoverflow](https://stackoverflow.com/questions/4269034/what-is-the-meaning-of-prepended-double-colon):

This ensures that resolution occurs from the global namespace, instead of starting at the namespace you're currently in. For instance, if you had two different classes called `Configuration` as such:

```cpp
class Configuration; // class 1, in global namespace
namespace MyApp
{
    class Configuration; // class 2, different from class 1
    function blah()
    {
        // resolves to MyApp::Configuration, class 2
        Configuration::doStuff(...) 
        // resolves to top-level Configuration, class 1
        ::Configuration::doStuff(...)
    }
}
```

Basically, it allows you to traverse up to the global namespace since your name might get clobbered by a new definition inside another namespace, in this case `MyApp`.

## Constructors throwing Exceptions

From [isocpp](https://isocpp.org/wiki/faq/exceptions#selfcleaning-members):
- Every data member inside your object should clean up its own mess
- If a constructor throws an exception, the object's destructor is not run
  - Therefore, if your object has already done something that needs to be undone (such as allocating some memory, opening a file, or locking a semaphore), this "stuff that needs to be undone" must be remembered by a data member inside the object.

From [isocpp](https://isocpp.org/wiki/faq/exceptions#ctors-can-throw):
- Note: if a constructor finishes by throwing an exception, the memory associated with the object itself is cleaned up — there is no memory leak. 
- For example:

```cpp
void f()
{
  X x;             // If X::X() throws, the memory for x itself will not leak
  Y* p = new Y();  // If Y::Y() throws, the memory for *p itself will not leak
}
```

related: [Handle a Constructor that fails](#handle-a-constructor-that-fails)

# References

## Lvalue References

- aka **lvalue references**
- idea
  - Normally, when you use a reference, you do not use the address-of operator. You simply use the reference as you would use the target variable.
    - references are **aliases** for their target
  - enables the function to change the object being referred to

```cpp
int intOne;
int &rSomeRef = intOne;
intOne = 5;

// intOne: 5
// rSomeRef: 5
// &intOne: 0x3500
// &rSomeRef: 0x3500
```

- references (unlike other variables)
  - must be initialized when they are declared
  - cannot be reassigned
- space **before** the address-of operator is **required**
- usually "the type of a reference must match the type of the object to which it refers"
  - 2 exceptions:
    - 1) "we can initialize a reference to const from any expression that can be converted to the type of the reference" (see [reference to const](#reference-to-const))

### reference to const 

- aka "`const` reference", "lvalue reference to a `const` value"
- `X const& x` is equivalent to `const X& x`, and `X const* x` is equivalent to `const X* x`. (see [isocpp.org](https://isocpp.org/wiki/faq/const-correctness#const-ref-nonsense))
- Unlike an ordinary reference, a reference to `const` cannot be used to change the object to which the reference is bound
- "we can **initialize** a reference to `const` from any expression that can be converted to the type of the reference"
  - we can bind a reference to `const` to 
    - a nonconst object, 
    - a literal, or 
    - a more general expression
    - an object of a different type (in this case, the reference is bound to a [temporary](#temporaries) object, see p.62)
- "Binding a reference to `const` to an object says nothing about whether the underlying object itself is `const`."
  - ie. the underlying object cannot be changed by using the reference to `const`, but it might be changed by other means
- binding a **non-const** reference to a [temporary](#temporaries) is illegal in C++, only **const** references may be bound to a temporary (see p.62)

```cpp
const int ci = 1024;
const int &r1 = ci;     // ok: both reference and underlying object are const
r1 = 42;                // error: r1 is a reference to const
int &r2 = ci;           // error: nonconst reference to a const object

// Initialization and References to const:
int i = 42;
const int &r1 = i;        // we can bind a const int& to a plain int object
const int &r2 = 42;       // ok: r1 is a reference to const
const int &r3 = r1 * 2;   // ok: r3 is a reference to const
int &r4 = r * 2;          // error: r4 is a plain, non const reference

// Temporaries and References to const:
// see examples in section "Temporaries"

// A Reference to const May Refer to an Object That Is Not const:
int i = 42;
int &r1 = i;          // r1 bound to i
const int &r2 = i;    // r2 also bound to i; but cannot be used to change i
r1 = 0;               // r1 is not const; i is now 0
r2 = 0;               // error: r2 is a reference to const
```

### const references

- usually refers to [reference to const](#reference-to-const)

From [isocpp.org](https://isocpp.org/wiki/faq/const-correctness#const-ref-nonsense):
- references are always `const`
- `X& const x` is functionally equivalent to `X& x`. Since you're gaining nothing by adding the `const` after the `&`, you shouldn't add it: it will confuse people — the `const` will make some people think that the `X` is const, as if you had said `const X& x`.

## Rvalue References

- introduced by the new standard to support move operations
- a reference that must be bound to an rvalue
- obtained by using `&&`
- may be bound only to an object that is about to be destroyed
  - so that we are free to "move" resources from an rvalue reference to another object
- rvalue and lvalue references have the opposite **binding properties**:

```cpp
int i = 42;
int &r = i;             // ok: r refers to i
int &&rr = i;           // error: cannot bind an rvalue reference to an lvalue
int &r2 = i * 42;       // error: i * 42 is an rvalue
const int &r3 = i * 42; // ok: we can bind a reference to const to an rvalue
int &&rr2 = i * 42;     // ok: bind rr2 to the result of the multiplication
```

Examples of expressions that return
- lvalues
  - Functions that return lvalue references
  - operators
    - assignment
    - subscript
    - dereference
    - prefix increment/decrement (`++i`)
  - Variable expressions
- rvalues (prvalues)
  - Functions that return a nonreference type
  - operators
    - arithmetic
    - relational
    - bitwise
    - postfix increment/decrement (`i++`)
  - literals

- rvalue references refer to objects that are about to be destroyed
- **ephemeral** vs **persistent**: 
  - lvalues have persistent state, whereas **rvalues** are either **literals** or **temporary objects**
- code that uses an rvalue reference is free to take over value/resources/state from the object to which the reference refers
  - "steal" value/resources/state from the object (rhs) bound to an rvalue reference (lhs)
- you **cannot** directly bind an rvalue reference **to a variable**, even if that variable was defined as an rvalue reference type

```cpp
int &&rr1 = 42;         // ok: literals are rvalues
// Error:
int &&rr2 = rr1;        // error: the expression rr1 is an lvalue!
```

## Reference to Pointer

From [stackoverflow](https://stackoverflow.com/a/1898556):
- a reference to a pointer is like a reference to any other variable

```cpp
void fun(int*& ref_to_ptr)
{
    ref_to_ptr = 0; // set the "passed" pointer to 0
    // if the pointer is not passed by ref,
    // then only the copy(parameter) you received is set to 0,
    // but the original pointer(outside the function) is not affected.
}
```

## Pointer to Reference

From [stackoverflow](https://stackoverflow.com/a/1898556):
- A pointer to reference is illegal in C++
  - because - unlike a pointer - a reference is just a concept that allows the programmer to make **aliases** of something else.
- A pointer is a **place in memory** that has the address of something else, but a reference is NOT.

# Pointer

- see my "C Notes"
- A pointer is a **compound type** that "points to" another type. 
- Like references,
  - pointers are used for **indirect access to other objects**. 
- Unlike a reference, 
  - a pointer is an object in its own right. 
  - a pointer need not be initialized at the time it is defined.
- Pointers can be **assigned** and **copied**
  - a single pointer can point to several different objects over its lifetime.
- pointers defined at **block scope** have **undefined value** if they are not initialized (like other built-in types)
- Each **pointer** is equal to the **address of the first byte** of the pointed-to variable (JA201)
  - The **address of a variable** is actually the address of the first (lowest) byte it occupies (JA201)
- **best practice:**
  - always initialize pointers

```cpp
double dval;
double *pd = &dval; // ok: initializer is the address of a double
// copy initialization of a pointer (more examples, see Lippman)
double *pd2 = pd;   // ok: initializer is a pointer to double
```

**How to memorize**:

From [stackoverflow](https://stackoverflow.com/a/2837853):
- The symbols `*` and `&` both have **two different meanings** that have to do with indirection.
  - `*` when used as part of a **type** indicates that the type is a pointer: 
    - `int` is a type, so `int*` is a pointer-to-int type, and `int**` is a pointer-to-pointer-to-int type.
  - `&` when used as part of a **type** indicates that the type is a reference. 
    - `int` is a type, so `int&` is a reference-to-int (there is no such thing as reference-to-reference). 
    - References and pointers are used for similar things, but they are quite different and not interchangable. 
    - A reference is best thought of as an alias, or alternate name, for an existing variable.
  - `*` when used as a **unary operator** performs an operation called "dereference" (which has nothing to do with reference types!).
    - This operation is only meaningful on pointers.
  - `&` when used as a **unary operator** performs an operation called "address-of".
- So remember, the type suffix `&` is for references, and has nothing to do with the unary operatory `&`, which has to do with getting addresses for use with pointers. The two uses are completely unrelated. And `*` as a type suffix declares a pointer, while `*` as a unary operator performs an action on pointers.

## delete

- Delete an array: `delete[] arrayName`
- Deleting a `nullptr` does not cause any change and no error.
- You cannot delete a pointer to a local stack allocated variable:
```cpp
int x;
int* ptr1 = &x;

// x is present on stack frame as
// local variable, only dynamically
// allocated variables can be destroyed
// using the delete operator
delete ptr1;

return 0;

// Output: Runtime error
```

## Nullpointer

- [Bjarne Stroustrup comment](https://www.stroustrup.com/bs_faq2.html#null)
- ([g++ doc](https://gcc.gnu.org/onlinedocs/libstdc++/manual/support.html#std.support.types.null))
- `NULL` ist definiert als [macro](https://gcc.gnu.org/onlinedocs/cpp/Macros.html) (i.e. a piece of code in a program that is replaced by the value of the macro; a macro is defined by `#define` directive; whenever a macro name is encountered by the [preprocessor](https://en.wikipedia.org/wiki/Preprocessor), it replaces the name with the definition of the macro): 
  - From [cppreference](https://en.cppreference.com/w/cpp/types/NULL):
    ```cpp
    #define NULL 0
    //since C++11
    #define NULL nullptr
    ```
  - dh `NULL` und `0` waren früher **dasselbe** [bis C++11] und jetzt sind `NULL` und `nullptr` **dasselbe** (aber how come [implicit cast difference](#implicit-cast-of-null-and-nullptr)?)
- "Unless you need to be compatible with C++98/C++03 or C you should prefer to use `nullptr` instead of `NULL`." ([g++ doc](https://gcc.gnu.org/onlinedocs/libstdc++/manual/support.html#std.support.types.null))

### Implicit Cast of NULL and nullptr

#### To Pointer Types

- `NULL` und `nullptr` beide implicitly convertible to any **pointer** type
  - A **null pointer** constant (see `NULL`), can be converted to any **pointer** type [i.e. type with asterisk `*`], and the result is the null pointer value of that type. ([cppreference](https://en.cppreference.com/w/cpp/language/implicit_conversion))

#### To Integral Types

- Unlike `NULL`, `nullptr` is **not** implicitly convertible or comparable to integral types [e.g. `int`, `char`] ([geeksforgeeks](https://www.geeksforgeeks.org/understanding-nullptr-c/))
  - `int x = NULL` geht; 
  - `int x = nullptr` geht **nicht**!
- `nullptr` is of type `nullptr_t`, which is implicitly convertible and comparable to any pointer type or pointer-to-member type. **It is not implicitly convertible or comparable to integral types** [e.g. `int`, `char`], **except for** `bool`. ([C++11](https://en.wikipedia.org/wiki/C%2B%2B11#Null_pointer_constant))

### Type of NULL and nullptr

In C++11 hat `NULL` den type `nullptr_t` 
- `nullptr_t` "is a distinct type that is not itself a pointer type or a pointer to member type." ([doc](https://en.cppreference.com/w/cpp/types/nullptr_t))

"In C, the macro `NULL` may have the type `void*`, but that is not allowed in C++." ([cppreference](https://en.cppreference.com/w/cpp/types/NULL))
- how come?: [stackoverflow](https://stackoverflow.com/a/69057243)
- soll heißen: `NULL` hat in C++ **absichtlich nicht (wie in C)** den Type `void*`, weil there is no **implicit cast** from `void*` to any other type in C++ (in C wäre das aber möglich!). Bis C++11 war `NULL` das [integer literal](https://en.cppreference.com/w/cpp/language/integer_literal) "`0`", konnte damit also einen der integer literal types (s. Tabelle in [integer literal](https://en.cppreference.com/w/cpp/language/integer_literal)) haben. Seit C++11 hat `NULL` den type `nullptr_t` ([doc](https://en.cppreference.com/w/cpp/types/nullptr_t)).

dh zB
```cpp
void* ptr = nullptr; 
int foo = *ptr;    // this implicit cast is not allowed in C++
```
gibt einen Compiler Error `error: ‘void*’ is not a pointer-to-object type` (**fix**: use a different type (a "pointer-to-object" type) instead of `void*` -  `void*` is a "pointer-to-nothing")

Aber 
```cpp
char* ptr = nullptr; 
int foo = *ptr;
```
gibt keinen Compiler Error, weil `char*` ein pointer-to-object type ist.

# Polymorphism

1. function **overloading**
2. templates
3. virtual functions ( **overriding** )

[source](https://www.geeksforgeeks.org/templates-cpp/)
- "Both function overloading and templates are examples of **polymorphism** features of OOP."
- function templates vs overloading: 
  - "Function overloading is used when multiple functions do quite similar (not identical) operations, templates are used when multiple functions do identical operations."

# Templates

- **instantiation**: The process that the compiler uses to create classes or functions from templates
- templates are **not** functions or classes
- templates "can be thought of as instructions to the compiler for generating classes or functions"
- templates can make the code shorter and more manageable

## Function Templates

**Function Template**:

[stackoverflow](https://www.cplusplus.com/doc/oldtutorial/templates/)

```cpp
// function template
#include <iostream>
using namespace std;

template <class T>
T GetMax (T a, T b) {
  T result;
  result = (a>b)? a : b;
  return (result);
}

int main () {
  int i=5, j=6, k;
  long l=10, m=5, n;
  k=GetMax<int>(i,j);
  n=GetMax<long>(l,m);
  cout << k << endl;
  cout << n << endl;
  return 0;
}
```

**Generic Type**: Function templates are special functions that can operate with **generic types**. This allows us to create a function template whose functionality can be adapted to more than one type or class without repeating the entire code for each type.

**Template Parameter**: In C++ this can be achieved using **template parameters**. A template parameter is a special kind of parameter that can be used to pass a type as argument: just like regular function parameters can be used to pass values to a function, template parameters allow to pass also types to a function. These function templates can use these parameters as if they were any other regular type.

## Class Templates

[source](https://www.geeksforgeeks.org/templates-cpp/):
- to create a single class to work with different data types
- useful when a class defines something that is independent of the data type. 
  - Can be useful for classes like LinkedList, BinaryTree, Stack, Queue, Array, etc.

```cpp
// C++ Program to implement
// template Array class
#include <iostream>
using namespace std;

template <typename T> class Array {
private:
    T* ptr;
    int size;

public:
    Array(T arr[], int s);
    void print();
};

template <typename T> Array<T>::Array(T arr[], int s)
{
    ptr = new T[s];
    size = s;
    for (int i = 0; i < size; i++)
        ptr[i] = arr[i];
}

template <typename T> void Array<T>::print()
{
    for (int i = 0; i < size; i++)
        cout << " " << *(ptr + i);
    cout << endl;
}

int main()
{
    int arr[5] = { 1, 2, 3, 4, 5 };
    Array<int> a(arr, 5);
    a.print();
    return 0;
}
```

### Containers

- table of all containers: [cppreference](https://en.cppreference.com/w/cpp/container#Function_table)
- each container is defined in a header file with the same name as the type
- containers are class templates (3.3)
- container types: see ["Types"](#types)

#### std::array

- "a container that encapsulates **fixed size** arrays"
- "an aggregate type"
- "same semantics as a `struct` holding a **C-style array** `T[N]` as its only non-static data member."
  - **But**: "Unlike a C-style array, it doesn't decay to `T*` automatically."

#### C-style Arrays

- are a compound type
- the **dimension** must be a **constant expression**
- cannot use `auto` to deduce the type
- elements in an array are **default initialized**
  - thus, an array of built-in type that is defined inside a function will have undefined values.
- An **array name without brackets** is a pointer to the array's first element (JA202)
  - You can also use the expression `&data[0]` to obtain the address of the array's first element (JA202)
  - The name of an array is a **pointer constant**; it can't be changed and remains fixed for the entire time the program executes (JA202)
    - You can, however, declare a pointer variable and initialize it to point at the array:

```cpp
int array[100], *p_array;
/* additional code goes here */
p_array = array;
```

- C-style arrays do not support Copy or Assignment (but `std::array` does!)

```cpp
int a[] = {0, 1, 2};  // array of three ints
int a2[] = a;         // error: cannot initialize one array with another
a2 = a;               // error: cannot assign one array to another
```

**Pointer Arithmetic**:

- Computing a pointer more than one past the last element is an error, although the compiler is unlikely to detect such errors.
 
```cpp
constexpr size_t sz = 5;
int arr[sz] = {1,2,3,4,5};
int *ip = arr;              // equivalent to int *ip = &arr[0]
int *ip2 = ip + 4;          // ip2 points to arr[4], the last element in arr

// ok: arr is converted to a pointer to its first element; p points one past the end of arr
int *p = arr + sz;          // use caution -- do not dereference!
int *p2 = arr + 10;         // error: arr has only 5 elements; p2 has undefined value; compiler is unlikely to detect this error

// distance between two pointers (to elements of the same array):
// - return type: `ptrdiff_t` (a machine-specific type, in <cstddef> header)
auto n = end(arr) - begin(arr);     // n is 5, the number of elements in arr

// "compare pointers" using relational operators:

// eg. traverse the elements in arr
int *b = arr, *e = arr + sz;
while (b < e) {                 // ok: b and e are related
  // use *b
  ++b;
}

// error: cannot use the relational operators on pointers to two unrelated objects:
int i = 0, sz = 42;
int *p = &i, *e = &sz;
// undefined: p and e are unrelated; comparison is meaningless!
while (p < e)
```

- pointer arithmetic is also valid 
  - for null pointers
    - If `p` is a null pointer, we can add or subtract an integral constant expression whose value is `0` to `p`.
    - We can also subtract two null pointers from one another, in which case the result is `0`.
  - for pointers that point to an object that is not an array.
    - the pointers must point to the same object, or one past that object. 

**References and Pointers to Arrays**:

```cpp
int *ptrs[10];              // ptrs is an array of ten pointers to int
int &refs[10] = /* ? */;    // error: no arrays of references
int (*Parray)[10] = &arr;   // Parray points to an array of ten ints
int (&arrRef)[10] = arr;    // arrRef refers to an array of ten ints
```

Similarly, we can pass a parameter that is a reference to an array:

```cpp
void print(int (&arr)[10])   // the dimension is part of the type
{
  for (auto elem : arr)
    cout << elem << endl;
}
```

#### std::vector

- **flexible-size** array (as opposed to the **fixed-size** array `std::array`)
- `std::vector` is a template, not a type
- elements are stored contiguously
- how a `vector` grows
  - Vectors typically allocate capacity beyond what is immediately needed.
  - The container holds this **storage in reserve** and uses it to allocate new elements **as they are added**.
    - Thus, there is **no need to reallocate** ("`vector` zu einem Ort umlagern wo mehr Platz ist") the container each time an element is added
  - dramatically more efficient than reallocating the container each time an element is added
- container size management:
  - container size management functions, see Table 9.10
    - `c.shrink_to_fit()`: Request to reduce `capacity()` to equal `size()`
    - `c.capacity()`: Number of elements `c` can have before reallocation is necessary.
    - `c.reserve(n)`: Allocate space for at least `n` elements.
  - vector `size`: number of elements the vector already holds
  - vector `capacity`: how many elements it can hold before more space must be allocated

Element Access:

`front`
- "Returns a **reference to** the first element in the container."
- "Calling front on an empty container causes undefined behavior."

`back`
- "Returns a **reference to** the last element in the container."
- "Calling back on an empty container causes undefined behavior."

`push_back`
- "Appends the given element value to the end of the container"
- "If the new `size()` is greater than `capacity()` then all iterators and references (including the `end()` iterator) are invalidated. Otherwise only the end() iterator is invalidated."

`pop_back`
- "Removes the last element of the container."
- "Calling `pop_back` on an empty container results in undefined behavior."
- "Iterators and references to the last element, as well as the end() iterator, are invalidated."

#### std::string

- A specialized container that contains characters.
- similar to `vector`
  - `std::string` can be considered as `std::vector<char>`
- Convert to C-style string (null-terminated string)
  - `.c_str()` converts a string to a null-terminated string (C-style string), [stackoverflow](https://stackoverflow.com/questions/7416445/what-is-use-of-c-str-function-in-c) (s. Antwort von hkBattousai)
- **string literals** are not standard library `strings`
- elements are stored contiguously
- how a `string` grows
  - Strings typically allocate capacity beyond what is immediately needed. (like `vector`)

`string::size_type`
- a **companion type**
  - companion types make it possible to use the library types in a machine-independent manner
- an unsigned type
- big enough to hold the size of any `string`
- tedious to type `string::size_type` &rarr; use `auto` or `decltype`

**C-style Strings**:

```cpp
strlen(p)                           // Returns the length of p, not counting the null.
strcmp(p1,p2)                       // Compares p1 and p2 for equality. Returns 0 if p1 == p2, a positive value if p1 > p2, a negative value if p1 < p2.
strcat(p1,p2)                       // Appends p2 to p1. Returns p1.
strcpy(p1,p2)                       // Copies p2 into p1. Returns p1.
```

### Iterators

Generic programming:
- **Best practice:** C++ programmers
  - use `!=` rather than `<`
    - because only a few library types have the `<` operator
  - use `!=` as a matter of habit
  - use iterators rather than subscripts
    - because only a few library types have the subscript operator

## Variadic Templates

TODO

- a template function or class that can take a varying number of parameters. 
- The varying parameters are known as a **parameter pack**.
- There are two kinds of parameter packs:
  - A **template parameter pack** represents zero or more template parameters, 
  - a **function parameter pack** represents zero or more function parameters.
- We use an **ellipsis** to indicate that a template or function parameter represents a pack.

```cpp
// "Args" is a template parameter pack; "rest" is a function parameter pack
// "Args" represents zero or more template type parameters
// "rest" represents zero or more function parameters
template <typename T, typename... Args>
void foo(const T &t, const Args& ... rest);
```

Example:

```cpp
// Given these calls ...
int i = 0; double d = 3.14; string s = "how now brown cow";
foo(i, s, 42, d);     // three parameters in the pack
foo(s, 42, "hi");     // two parameters in the pack
foo(d, s);            // one parameter in the pack
foo("hi");            // empty pack

// ... the compiler will instantiate
void foo(const int&, const string&, const int&, const double&);
void foo(const string&, const int&, const char(&)[3]);
void foo(const double&, const string&);
void foo(const char(&)[3]);
// in each case,
// - the type of T is deduced from the type of the first argument
// - remaining arguments (if any) provide the number of, and types for, the additional arguments to the function
```

# Overloading vs Overriding

- overloading: the same function name, but with a different signature (i.e. name of the function, the parameter list, and the keyword `const`, if used)
- overriding: the same function name and the same signature

# Overloading

[stackoverflow](https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm)

**Function Overloading**, **Operator Overloading**: C++ allows you to specify more than one definition for a **function** name or an **operator** in the same scope, which is called **function overloading** and **operator overloading** respectively. 

**overloaded declaration**, **overload resolution**: An overloaded declaration is a declaration that is declared with the same name as a previously declared declaration in the same scope, except that both declarations have different arguments and obviously different definition (implementation). When you call an overloaded **function** or **operator**, the compiler determines the most appropriate definition to use, by comparing the argument types you have used to call the function or operator with the parameter types specified in the definitions. The process of selecting the most appropriate overloaded function or operator is called **overload resolution**.

# Overriding

- "**Overriding** a function means changing the implementation of a base class function in a derived class." (Day 12, J Liberty)

## "Normal" Overriding

- "When a derived class creates a function with the same return type and signature as a member function in the base class, but with a new implementation, it is said to be **overriding** that function. When you make an object of the derived class, the correct function is called." (Day 12, J Liberty)

## virtual

- C++ allows **pointers to base classes** to be assigned to derived class objects `BaseClass* pBase = new DerivedClass;` (Day 12, J Liberty)
  - `pBase` can invoke any method on `BaseClass`, but what we would like is for those methods that are overridden in `DerivedClass()` to call the correct function
- phth: "normal" overriding (cf. above) is possible **without** the `virtual` (see Day 12, J Liberty), but, if a pointer to the base class is assigned to the derived class object, and we use this pointer to call an overridden function, the overriding will not work

[source](https://www.programiz.com/cpp-programming/virtual-functions):
- A **virtual function** is a member function in the base class that we *expect* to redefine in derived classes.
- Basically, a virtual function is used in the base class in order to ensure that the function is **overridden**. This especially applies to cases where a pointer of base class points to an object of a derived class.

```cpp
// source: https://www.geeksforgeeks.org/virtual-functions-in-derived-classes-in-cpp/
// C++ Program to demonstrate Virtual
// functions in derived classes
#include <iostream>
using namespace std;

class A {
public:
	virtual void fun() { cout << "\n A::fun() called "; } 
};

class B : public A {
public:
	void fun() { cout << "\n B::fun() called "; }
};

class C : public B {
public:
	void fun() { cout << "\n C::fun() called "; }
};

int main()
{
	// An object of class C
	C c;

	// A pointer of class B pointing
	// to memory location of c
	B* b = &c;

	// this line prints "C::fun() called"
    // (Note: without the "virtual" in "class A" this line prints "\n A::fun() called ")
	b->fun();

	getchar(); // to get the next character
	return 0;
}
```

# Streams

A **stream** is a sequence of characters read from or written to an IO device. The term stream is intended to suggest that the characters are generated, or consumed, sequentially over time.

## iostream library

Defines the **types**: `istream` and `ostream`
Objects of type `istream`:
- `cin`
Objects of type `ostream`:
- `cout`
- `cerr`
- `clog`

## Buffer, Print Statements

**buffer**: A region of storage used to hold data. IO facilities often store input (or output) in a buffer and read or write the buffer independently from actions in the program. Output buffers can be explicitly flushed to force the buffer to be written. By default, reading cin flushes cout; cout is also flushed when the program ends normally.

```cpp
std::cout << "string" << std::endl
```

Writing `endl` has the effect of ending the current line and **flushing the buffer** associated with that device. Flushing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.
- **Best practice**: Programmers often add **print statements** during debugging. Such statements should **always flush the stream**. Otherwise, if the program crashes, output may be left in the buffer, leading to incorrect inferences about where the program crashed.

# Dynamic Memory

- managed through
  - `new`: 
    - allocates, and optionally initializes, an object in dynamic memory 
    - returns a pointer to that object
    - if the constructor throws an exception:
      - "If initialization terminates by throwing an exception (e.g. from the **constructor**), if new-expression allocated any storage, it calls the appropriate deallocation function: `operator delete` for non-array type, `operator delete[]` for array type.", [cppreference](https://en.cppreference.com/w/cpp/language/new#Construction)
  - `delete`
    - takes a pointer to a dynamic object,
    - destroys that object,
    - frees the associated memory
- by default, dynamically allocated objects are **default initialized**
  - built-in or compound type: undefined value
  - class type: default constructor
- we can also use
  - direct initialization
  - value initialization
- **Best practice:** always initialize dynamically allocated objects

```cpp
// default initialization
string *ps = new string; // initialized to empty string
int *pi = new int; // pi points to an uninitialized int

// (forms of) direct initialization:
// traditional:
int *pi = new int(1024); // object to which pi points has value 1024
string *ps = new string(10, '9'); // *ps is "9999999999"
// list initialization (direct-list-initialization)
vector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9}; // vector with ten elements with values from 0 to 9

// value initialization:
string *ps1 = new string; // default initialized to the empty string
string *ps = new string(); // value initialized to the empty string
int *pi1 = new int; // default initialized; *pi1 is undefined
int *pi2 = new int(); // value initialized to 0; *pi2 is 0

// const objects:
const int *pci = new const int(1024);   // allocate and initialize a const int
const string *pcs = new const string;   // allocate a default-initialized const empty string
// - recall, const objects MUST be initialized
// - pci and pcs are "pointers to const"
```

## Memory Exhaustion and Exceptions

Memory Exhaustion:
- by default, if `new` is unable to allocate the requested storage, it throws an **exception** of type `bad_alloc` (defined in the `new` header)

Prevent throwing an exception:
- **placement new:** a placement new lets us pass additional arguments to `new`
- to prevent `new` from throwing an exception pass an object named `nothrow` (defined in the `new` header):
  - if unable to allocate the requested storage, this form of `new` will return a null pointer

```cpp
// if allocation fails, new returns a null pointer
int *p1 = new int;              // if allocation fails, new throws std::bad_alloc
int *p2 = new (nothrow) int;    // if allocation fails, new returns a null pointer
```

- In order to prevent memory exhaustion, we must return dynamically allocated memory to the system once we are finished using it. We return memory through a `delete` expression.

## delete

- The pointer we pass to delete must either
  - point to dynamically allocated memory or
  - be a null pointer.
- **Warning:** Most compilers will accept the following situations, even though they are **undefined**:
  - deleting a pointer to memory that was not allocated by `new`: undefined
  - deleting the same pointer value more than once: undefined

```cpp
int i, *pi1 = &i, *pi2 = nullptr;
double *pd = new double(33), *pd2 = pd;
delete i;       // error: i is not a pointer
delete pi1;     // undefined: pi1 refers to a local
delete pd;      // ok
delete pd2;     // undefined: the memory pointed to by pd2 was already freed
delete pi2;     // ok: it is always ok to delete a null pointer

// const objects
const int *pci = new const int(1024);
delete pci;     // ok: deletes a const object
```

## Common Problems

1. Forgetting to delete memory &rarr; **"memory leak"**
  - Neglecting to delete dynamic memory is known as a memory leak, because the memory is never returned to the free store. 
  - Testing for memory leaks is difficult because they usually cannot be detected until the application is run for a long enough time to actually exhaust memory.
2. Using an object after it has been deleted. 
  - This error can sometimes be detected by making the pointer null after the delete.
3. Deleting the same memory twice. 
  - This error can happen when two pointers address the same dynamically allocated object. 
  - If `delete` is applied to one of the pointers, then the object's memory is returned to the free store. 
  - If we subsequently `delete` the second pointer, then the free store may be corrupted.

# Dangling Pointers

- one that refers to memory that once held an object but no longer does so
- When we delete a pointer,
  - that pointer becomes **invalid**
  - on many machines the pointer continues to hold the address of the (freed) dynamic memory.
- dangling pointers have all the problems of **uninitialized pointers**
- avoid the problems by
  - deleting just before the pointer itself goes out of scope
  - if we need to keep the pointer around, we can assign `nullptr` after using `delete`
    - **Warning:** resetting a pointer has no effect on any of the other pointers

## Smart Pointers

- to implement the "no naked `new`" rule
- "Smart pointers enable automatic, exception-safe, object lifetime management."
- a smart pointer acts **like a regular pointer** with the important exception that it **automatically deletes** the object to which it points
- defined in `memory` header
- `unique_ptr`: "owns" the object to which it points
  - represents unique ownership (its destructor destroys its object) (BS)
- `shared_ptr`: allows multiple pointers to refer to the same object
  - represents shared ownership (the last shared pointer's destructor destroys the object) (BS)
  - `weak_ptr`: companion class, a weak reference to an object managed by a `shared_ptr`
- **best practice:**
  - try to not use them
  - try to use containers and other types that manage their resources
  - in general, only when we really need pointer semantics:
    - When we share an object
    - When we refer to a polymorphic object
    - A shared polymorphic object

### `shared_ptr` class

- smart pointers are **templates** (ie must supply type in angle brackets)
- **default initialized** smart pointer hold a **null pointer**
- similar to `unique_ptr` except that `shared_ptrs` are **copied** rather than moved (BS)

Examples:

```cpp
shared_ptr<string> p1;  // shared_ptr that can point at a string
shared_ptr<list<int>> p2; // shared_ptr that can point at a list of ints
// if p1 is not null, check whether it's the empty string
if (p1 && p1->empty())
  *p1 = "hi"; // if so, dereference p1 to assign a new value to that string
```

#### `make_shared`

- **best practice:** `make_shared` is the preferred method for constructing an object and returning an appropriate smart pointer
  - BS: Creating an object using `new` and passing it to a `shared_ptr` is
    - more verbose
    - allows for mistakes
    - notably less efficient 
      - because it needs a separate allocation for the use count that is essential in the implementation of a `shared_ptr`
- `make_shared<type>(args)` (non-member function template of `std::shared_ptr`)
  - allocates and initializes an object in dynamic memory
  - returns a `shared_ptr` that points to that object
  - if we do not pass any arguments, then the object is **value initialized**

1) Constructs an object of type `T` and wraps it in a `std::shared_ptr` using `args` as the parameter list for the constructor of `T`.

```cpp
template< class T, class... Args >
shared_ptr<T> make_shared( Args&&... args );
```

Examples:

```cpp
// shared_ptr that points to an int with value 42
shared_ptr<int> p3 = make_shared<int>(42);
// p4 points to a string with value 9999999999
shared_ptr<string> p4 = make_shared<string>(10, '9');
// p5 points to an int that is value initialized (§ 3.3.1 (p. 98)) to 0
shared_ptr<int> p5 = make_shared<int>();

// ordinarily we use auto:
// p6 points to a dynamically allocated, empty vector<string>
auto p6 = make_shared<vector<string>>();
```

- keeps track of how many other `shared_ptrs` point to the same object
- **reference count** (aka "use count"):
  - is **incremented** when we
    - copy a `shared_ptr`
    - use a `shared_ptr` to initialize another `shared_ptr`, 
    - use a `shared_ptr` as the right-hand operand of an assignment, 
    - pass it to a function
    - return it from a function by value
  - is **decremented** when
    - we assign a new value to the `shared_ptr`
    - the `shared_ptr` itself is destroyed
      - such as when a local `shared_ptr` goes out of scope
  - Once a `shared_ptr`'s counter goes to zero, the `shared_ptr` automatically frees the object that it manages
  - Note: The reference count does not have to be a counter. Some other data structure may be used. This is up to the implementation.

```cpp
auto p = make_shared<int>(42); // object to which p points has one user
auto q(p); // p and q point to the same object
// object to which p and q point has two users
auto r = make_shared<int>(42); // int to which r points has one user
r = q; // assign to r, making it point to a different address
// increase the use count for the object to which q points
// reduce the use count of the object to which r had pointed
// the object r had pointed to has no users; that object is automatically freed
```

- automatically destroys the object to which that `shared_ptr` points via the `shared_ptr` **destructor** (the destructor of the `shared_ptr` class)
- the destructor of the `shared_ptr` class
  - frees the resources that an object has allocated (all destructors do this)
  - decrements the reference count of the object to which that `shared_ptr` points
- often used for [factory functions](#factory)

```cpp
// factory returns a shared_ptr pointing to a dynamically allocated object
shared_ptr<Foo> factory(T arg)
{
  // process arg as appropriate
  // shared_ptr will take care of deleting this memory
  return make_shared<Foo>(arg);
}

void use_factory(T arg)
{
  shared_ptr<Foo> p = factory(arg);
  // use p
} // p goes out of scope; the memory to which p points is automatically freed

// - the return statement in use_factory returns a copy of p to its caller
//   - Copying a shared_ptr adds to the reference count of that object
//   - therefore, the memory itself will not be freed (exactly, what we want!)
shared_ptr<Foo> use_factory(T arg)
{
  shared_ptr<Foo> p = factory(arg);
  // use p
  return p; // reference count is incremented when we return p
} // p goes out of scope; the local variable/object p is destroyed; the memory to which p points is not freed
```

Note: The same does not work with dynamic objects managed through **built-in pointers**:

```cpp
// factory returns a pointer to a dynamically allocated object
Foo* factory(T arg)
{
  // process arg as appropriate
  return new Foo(arg); // caller is responsible for deleting this memory
}

// "memory leak"
// - cannot be detected until the application is run for a long enough time to actually exhaust memory
void use_factory(T arg)
{
  Foo *p = factory(arg);
  // use p but do not delete it
} // p goes out of scope, but the memory to which p points is not freed!

// fix 1
void use_factory(T arg)
{
  Foo *p = factory(arg);
  // use p
  delete p; // remember to free the memory now that we no longer need it
}

// fix 2 (if we still need the allocated object)
Foo* use_factory(T arg)
{
  Foo *p = factory(arg);
  // use p
  return p; // caller must delete the memory
}
```

- make sure that `shared_ptrs` don't stay around after they are no longer needed
  - The program will execute correctly but **may waste memory** if you neglect to destroy `shared_ptrs` that the program does not need

#### A Class with Resources That Have Dynamic Lifetime

```cpp
class StrBlob {
  public:
    typedef std::vector<std::string>::size_type size_type;
    StrBlob();
    StrBlob(std::initializer_list<std::string> il);
    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }
    // add and remove elements
    void push_back(const std::string &t) {data->push_back(t);}
    void pop_back();
    // element access
    std::string& front();
    std::string& back();
  private:
    std::shared_ptr<std::vector<std::string>> data;
    // throws msg if data[i] isn’t valid
    void check(size_type i, const std::string &msg) const;
};

// constructors
StrBlob::StrBlob(): data(make_shared<vector<string>>()) { }
StrBlob::StrBlob(initializer_list<string> il):
    data(make_shared<vector<string>>(il)) { }

// element access members
void StrBlob::check(size_type i, const string &msg) const
{
  if (i >= data->size())
    throw out_of_range(msg);
}
string& StrBlob::front()
{
  // if the vector is empty, check will throw
  check(0, "front on empty StrBlob");
  return data->front();
}
string& StrBlob::back()
{
  check(0, "back on empty StrBlob");
  return data->back();
}
void StrBlob::pop_back()
{
  check(0, "pop_back on empty StrBlob");
  data->pop_back();
}

// copy, assign, destroy:
// - use the default versions of the operations that copy, assign, and destroy objects of its type
//   - memberwise: the default versions copy, assign, and destroy the object's members
//     - StrBlob has only one data member, which is a shared_ptr
//       - the vector allocated by StrBlob constructors is automatically destroyed when the reference count goes to 0
```

#### using "new"

```cpp
shared_ptr<double> p1; // shared_ptr that can point at a double
shared_ptr<int> p2(new int(42)); // p2 points to an int with value 42

// smart pointer constructors that take pointers are `explicit`
// (ie. cannot implicitly convert a built-in pointer to a smart pointer)
shared_ptr<int> p1 = new int(1024); // error: must use direct initialization
shared_ptr<int> p2(new int(1024)); // ok: uses direct initialization

// for the same reason, this return statement does not work
shared_ptr<int> clone(int p) {
  return new int(p); // error: implicit conversion to shared_ptr<int>
}

// instead, must explicitly bind a shared_ptr to the pointer
shared_ptr<int> clone(int p) {
  // ok: explicitly create a shared_ptr<int> from int*
  return shared_ptr<int>(new int(p));
}
```

#### Do Not Mix Ordinary Pointers and Smart Pointers

- General Rule: Once we give `shared_ptr` responsibility for a pointer, we should no longer use a built-in pointer to access the memory to which the `shared_ptr` now points.

```cpp
// ptr is created and initialized when process is called
void process(shared_ptr<int> ptr)
{
  // use ptr
} // ptr goes out of scope and is destroyed

// right way to use this function
shared_ptr<int> p(new int(42)); // reference count is 1
process(p);                     // copying p increments its count; in process the reference count is 2
int i = *p;                     // ok: reference count is 1

// WRONG way to use this function
int *x(new int(1024));        // dangerous: x is a plain pointer, not a smart pointer
process(x);                   // error: cannot convert int* to shared_ptr<int>
process(shared_ptr<int>(x));  // legal, but the memory will be deleted! => don't pass built-in pointer to temporary shared_ptr!
int j = *x;                   // undefined: x is a dangling pointer!
```

#### Do Not Use "get" to Initialize or Assign Another Smart Pointer

- `get`
  - returns a built-in pointer to the object that the smart pointer is managing
  - intended for cases when we need to pass a built-in pointer to **code that can't use a smart pointer**
  - code that uses the return from `get` **must not delete that pointer**
  - must not bind another smart pointer to the pointer returned by `get` (although the compiler will not complain)

```cpp
shared_ptr<int> p(new int(42)); // reference count is 1 (there is only ONE reference count for both p and q)
int *q = p.get(); // ok: but don't use q in any way that might delete its pointer
{ // new block
  // undefined: two independent shared_ptrs point to the same memory
  shared_ptr<int>(q);           // bind ANOTHER smart pointer to the pointer returned by `get`
  // note: this does not explicitly call the constructor, instead this line creates a temporary unnamed object with type "shared_ptr", which is destroyed immediately after ";" (see https://stackoverflow.com/a/18892056)
} // block ends, q is destroyed, and the memory to which q points is freed
int foo = *p; // undefined; the memory to which p points was freed
```

#### `reset`

- to assign a new pointer to a `shared_ptr`
- updates the reference counts
  - if appropriate, deletes the object to which the `shared_ptr` points
- often used together with `unique` to control changes to the object shared among several `shared_ptrs`

```cpp
shared_ptr<int> p(new int(42));
p = new int(1024);          // error: cannot assign a pointer to a shared_ptr
p.reset(new int(1024));     // ok: p points to a new object

if (!p.unique())          // Before changing the underlying object, we check whether we're the only user.
  p.reset(new string(*p));    // we aren't alone; allocate a new "deep" copy (to which p points now); 
                              // other users can continue using the original object to which p pointed
*p += newVal; // now that we know we're the only pointer, okay to change this object
```

#### Problems

From lecture slides:
```cpp
int i = std::atoi(argv[1]);
// execution order: 
// 1. new X{}                       // allocate
// 2. do_something(i)               // may throw an exception!
// 3. std::shared_ptr<X>(...)       // memory allocated in 1. is bound to a shared_ptr
// 4. f()                           // where 2. and 3. are passed to f()
//
// -> will leak, if do_something() throws an exception in step 2.!
try { f(std::shared_ptr<X>(new X{}), do_something(i)); }
catch (int&) { std::cout << "exception main\n"; }
```

BS15.2.1:
- in code below: 
  - unlike `unique_ptr`, `shared_ptr` are copied rather than moved
  - in the code below `f()` or `g()` may spawn a task holding a copy of `fp` or in some other way store a copy that outlives `user()`
    - **problem**: makes the lifetime of the shared object hard to predict

```cpp
void f(shared_ptr<fstream>);
void g(shared_ptr<fstream>);

void user(const string& name, ios_base::openmode mode)
{
  shared_ptr<fstream> fp {new fstream(name,mode)};
  if (!∗fp)         // make sure the file was properly opened
    throw No_file{};

  f(fp);
  g(fp);
  // ...
}
```

### `unique_ptr` class

- "owns" the object to which it points
- only one `unique_ptr` at a time can point to a given object
- there is no library function comparable to `make_shared` that returns a `unique_ptr`
  - instead, we bind it to a pointer returned by `new`
- `release`
  - returns the pointer currently stored in the `unique_ptr` 
  - makes that `unique_ptr` null
- `reset`
  - takes an optional pointer 
  - repositions the `unique_ptr` to point to the given pointer
  - if the `unique_ptr` is not null, then the object to which the `unique_ptr` had pointed is deleted

```cpp
// declaration
unique_ptr<double> p1; // unique_ptr that can point at a double
// must use the direct form of initialization
unique_ptr<int> p2(new int(42)); // p2 points to int with value 42

// does not support ordinary copy or assignment
unique_ptr<string> p1(new string("Stegosaurus"));
unique_ptr<string> p2(p1);  // error: no copy for unique_ptr
unique_ptr<string> p3;
p3 = p2;                    // error: no assign for unique_ptr

// transfers ownership from p1 (which points to the string Stegosaurus ) to p2
unique_ptr<string> p2(p1.release()); // release makes p1 null
unique_ptr<string> p3(new string("Trex"));
// transfers ownership from p3 to p2
p2.reset(p3.release()); // reset deletes the memory to which p2 had pointed

// problem with "release"
p2.release(); // WRONG: p2 won't free the memory and we’ve lost the pointer
auto p = p2.release(); // ok, but we must remember to delete(p)

// Deletes the object to which p1 points; makes p1 null.
p1 = nullptr
```

```cpp
// BS15.2.1: 
// most basic use of these "smart pointers" is to prevent memory leaks
void f(int i, int j)          // X* vs. unique_ptr<X>
{
  X∗ p = new X;               // allocate a new X
  unique_ptr<X> sp {new X};   // allocate a new X and give its pointer to unique_ptr
  // ...
  if (i<99) throw Z{};        // may throw an exception
  if (j<77) return;           // may return "early"
  // ... use p and sp ..
  delete p;                   // destroy *p
}
// - we delete p, BUT we "forgot" to delete p if i<99 or if j<77
// - only a "unique_ptr" ensures that its object is properly destroyed whichever way we exit f() (by throwing an exception, by executing return, or by "falling off the end")

// often used for passing free-store allocated objects in and out of functions
unique_ptr<X> make_X(int i)
// make an X and immediately give it to a unique_ptr
{
  // ... check i, etc. ...
  return unique_ptr<X>{new X{i}};
}
```

BS15.2.1
- A `unique_ptr` is a **handle to an individual object** (or an array) 
  - in much the same way that a `vector` is a **handle to a sequence of objects**. 
  - Both control the lifetime of other objects (using RAII) and
  - both rely on **elimination of copying** (copy elision) or on **move semantics** to make `return` simple and efficient

#### `make_unique`

```cpp
struct S {
  int i;
  string s;
  double d;
  // ...
};

auto p1 = make_shared<S>(1,"Ankh Morpork",4.65); // p1 is a shared_ptr<S>
auto p2 = make_unique<S>(2,"Oz",7.62);           // p2 is a unique_ptr<S>
```

### `weak_ptr` class

TODO

### Best practices

- Use `shared_ptr` only if you actually need shared ownership

#### typedef smart pointer types

From [isocpp](https://isocpp.org/wiki/faq/exceptions#selfcleaning-members):

By the way, if you think your `Fred` class is going to be allocated into a smart pointer, be nice to your users and create a `typedef` within your `Fred` class:

```cpp
#include <memory>
class Fred {
public:
  typedef std::unique_ptr<Fred> Ptr;
  // ...
};
```

That `typedef` simplifies the syntax of all the code that uses your objects: your users can say `Fred::Ptr` instead of `std::unique_ptr<Fred>`:

```cpp
#include "Fred.h"
void f(std::unique_ptr<Fred> p);  // explicit but verbose
void f(Fred::Ptr             p);  // simpler
void g()
{
  std::unique_ptr<Fred> p1( new Fred() );  // explicit but verbose
  Fred::Ptr             p2( new Fred() );  // simpler
  // ...
}
```

## RAII

- "Resource Acquisition Is Initialization"
  - **resources** ("anything that exists in limited supply")
    - allocated heap memory (here: acquisition = allocation)
    - thread of execution
    - open socket
    - open file
    - locked mutex
    - disk space
    - database connection
- aka
  - Constructor Acquires, Destructor Releases (CADRe)
  - Scope-Bound Resource Management (SBRM) (for the special case of automatic variables)
    - name because of "the basic use case where the lifetime of an RAII object ends due to scope exit"
- read: [cppreference: raii](https://en.cppreference.com/w/cpp/language/raii)
- RAII guarantees that 
  - the resource is available to any function that may access the object (resource availability is a **class invariant**, eliminating redundant runtime tests). 
  - all resources are released when the lifetime of their controlling object ends, in reverse order of acquisition. 
  - Likewise, **if resource acquisition fails** (the constructor exits with an exception), all resources acquired by every fully-constructed member and base subobject are released in reverse order of initialization.

BS5.2.2
- The technique of 
  - acquiring resources in a constructor and 
  - releasing them in a destructor
- basis for most C++ general resource management techniques
  - very commonly used to manage **data that can vary in size** during the lifetime of an object
- allows us to eliminate 
  - "naked `new` operations"
    - that is, to avoid allocations in general code and keep them buried inside the implementation of well-behaved abstractions
  - "naked `delete` operations"
  - Avoiding naked `new` and naked `delete` makes code 
    - far less error-prone and 
    - far easier to keep free of resource leaks

Wikipedia
- In RAII
  - holding a resource is a class [invariant](#invariants), and is tied to object [lifetime](#lifetimes)
  - resource **allocation** (or acquisition) is done during object creation (specifically **initialization**), by the **constructor**
  - resource **deallocation** (release) is done during object destruction (specifically finalization), by the **destructor**
  - In other words, resource acquisition must succeed for initialization to succeed.

# Time

- in `<chrono>`
  - Clocks, `time_point`, and `duration` for measuring how long some action takes, and as the basis for anything to do with time.
  - `day`, `month`, `year`, and `weekdays` for mapping `time_points` into our everyday lives.
  - `time_zone` and `zoned_time` to deal with differences in time reporting across the globe.

## Clocks

- **best practice:**
  - subtracting two `time_points` gives a `duration`
  - often a good idea to convert a `duration`, use `duration_cast`
  - use time-unit suffixes (in namespace `std::chrono_literals`)
    - greatly increases readability 
    - makes code more maintainable
- useful for:
  - quick measurements: 
    - Don't make statements about "efficiency" of code without first doing time measurements
    - Always measure repeatedly (to avoid rare events, cache effects, etc)

```cpp
#include <chrono>

using namespace std::chrono; // in sub-namespace std::chrono; see §3.3

auto t0 = system_clock::now();      // start time measurement
do_work();
auto t1 = system_clock::now();      // stop time measurement

// Subtracting two "time_points" gives a "duration"
cout << t1-t0 << "\n";                                            // default unit: 20223[1/00000000]s
// often a good idea to convert a "duration", use "duration_cast"
cout << duration_cast<milliseconds>(t1-t0).count() << "ms\n";     // specify unit: 2ms
cout << duration_cast<nanoseconds>(t1-t0).count() << "ns\n";      // specify unit: 2022300ns

// time-unit suffixes
this_thread::sleep_for(10ms+33us); // wait for 10 milliseconds and 33 microseconds
```

### `system_clock` vs `steady_clock`

From [stackoverflow](https://stackoverflow.com/a/31553641):

What is the difference between `steady_clock` vs `system_clock` in layman terms?
- If you're holding a `system_clock` in your hand, you would call it a **watch**, and it would tell you what time it is.
- If you're holding a `steady_clock` in your hand, you would call it a **stopwatch**, and it would tell you how fast someone ran a lap, but it would not tell you what time it is.
- If you had to, you could time someone running a lap with your **watch**. But if your watch (like mine) periodically talked to another machine (such as the atomic clock in Boulder CO) to correct itself to the current time, it might make minor mistakes in timing that lap. The **stopwatch** won't make that mistake, but it also can't tell you what the correct current time is.

## Best practices

From [stackoverflow](https://stackoverflow.com/a/31553641):

There is a simple rule I follow with the `<chrono>` library. The rule is actually not completely correct (thus it is a guideline). But it is close enough to correct to be a guideline that is nearly always followed:
- Don't use `count().`
- And a corollary: Don't use `time_since_epoch().`

The `<chrono>` library is designed around a **type-safe** system meant to protect you from units conversions mistakes. If you accidentally attempt an unsafe conversion, the error is caught at compile time (as opposed to it being a run time error).
- The member functions `count()` and `time_since_epoch()` are "escape hatches" out of this type-safe system ... to be used only in cases of emergency.

# Exception Handling

- best read: [isocpp](https://isocpp.org/wiki/faq/exceptions)

## Definitions

- an exception is **raised** by **throwing** an expression
- **exception safe code:** code that properly "cleans up" during exception handling
  - must ensure that
    - objects are valid, 
    - resources don't leak, 
    - the program is restored to an appropriate state

## Stack Unwinding

- definition: [cppreference](https://en.cppreference.com/w/cpp/language/throw#Stack_unwinding)
- the process
  - that starts when an exception is thrown
  - that continues up the chain of nested function calls until 
    - a `catch` clause for the exception is found, or 
    - the `main` function itself is exited without having found a matching `catch`
- An exception that is not caught **terminates** the program.
- **Object Destruction**: 
  - from [cppreference](https://en.cppreference.com/w/cpp/language/throw#Stack_unwinding):
    - "Once the exception object is constructed, the control flow works **backwards** (up the call stack) until it reaches the start of a `try` block, ..."
    - "As the control flow moves up the call stack, destructors are invoked for all objects with automatic storage duration that are constructed, but not yet destroyed, since the corresponding try-block was entered, **in reverse order** of completion of their constructors."
    - "If an exception is thrown **from a constructor** or (rare) from a destructor of an object (regardless of the object's storage duration), destructors are called for all fully-constructed non-static non-variant members and base classes, in reverse order of completion of their constructors."
  - from Lippman:
    - When a **block** is exited during stack unwinding, the compiler guarantees that objects created in that block are properly **destroyed**.
    - If a local object is of 
      - **class type**, the destructor for that object is called automatically.
      - **built-in type**, the compiler does no work to destroy that object.
        - this includes **raw pointers**: `int *a`, `MyClass *b` (note: `b` is a raw pointer, although `MyClass` is a class type)
        - good [example](https://stackoverflow.com/a/3181111): "On you specific questions, when an exception is thrown in a constructor, all fully constructed subobjects will be destroyed. That means that in the case of `b` it will be destroyed, in the case of `c`, it being a raw pointer, nothing is done."

## throw Expression

- **throw expressions**, which the detecting part uses to indicate that it encountered something it can't handle.
  - We say that a `throw` **raises** an exception.

Example:

Naive way: by returning an error indicator (without `throw` expressions):

```cpp
Sales_item item1, item2;
cin >> item1 >> item2;
// first check that item1 and item2 represent the same book
if (item1.isbn() == item2.isbn()) {
  cout << item1 + item2 << endl;
  return 0;           // indicate success
} else {
  cerr << "Data must refer to same ISBN"
            << endl;
  return -1;          // indicate failure
}
```

better: separate the part that adds the objects from the part that manages the interaction with a user:
- throw an expression (that is an **object** of type `runtime_error`)
- throwing an exception 
  - terminates the current function (calls `std::terminate` which itself calls `std::abort`) and
    - see [std::terminate](https://en.cppreference.com/w/cpp/error/terminate)
  - transfers control to a **handler** that will know how to handle this error
- Because the statements following a `throw` are not executed, a throw is like a `return`
  - It is usually part of a conditional statement or is the last (or only) statement in a function.
- type `runtime_error`
  - in the `stdexcept` header
  - must initialize a `runtime_error` by giving it a `string` or a C-style character string

```cpp
// first check that the data are for the same item
if (item1.isbn() != item2.isbn())
  throw runtime_error("Data must refer to same ISBN");
// if we're still here, the ISBNs are the same
cout << item1 + item2 << endl;
```

## try Block

- **try blocks**, which the handling part uses to deal with an exception.
  - A try block starts with the keyword `try` and ends with one or more `catch` clauses.
  - Exceptions thrown from code executed inside a `try` block are usually handled by one of the `catch` clauses.
  - Because they "handle" the exception, catch clauses are also known as **exception handlers**.
- Following the `try` block is a list of one or more `catch` clauses. A `catch` consists of three parts: 
  - the keyword `catch`, 
  - the **declaration** of a (possibly unnamed) object within parentheses (referred to as an **exception declaration**),
  - and a **block**.
    - When a `catch` is selected to handle an exception, the associated block is executed.
- Once the `catch` finishes, execution continues with the statement immediately following the last `catch` clause of the `try` block
- When a **handler** is entered, objects created along the call chain will have been destroyed.

```cpp
try {
  program-statements
} catch (exception-declaration) {
  handler-statements
} catch (exception-declaration) {
  handler-statements
} // ...
```

## Standard Exceptions

Usage:
- to report problems encountered in the functions in the standard library
- also intended to be used in the programs we write

Headers:
- 4 headers
  - `exception`
    - defines `exception` (exception without additional information)
  - `stdexcept`
    - defines general-purpose exception classes:
      - `exception`
      - `runtime_error`
      - `range_error`
      - `overflow_error`
      - `underflow_error`
      - `logic_error`
      - `domain_error`
      - `invalid_argumentlength_error`
      - `out_of_range`
  - `new`
    - defines `bad_alloc`
  - `type_info`
    - defines `bad_cast`

### Exception Classes

- are used to pass information about what happened between a `throw` and an associated `catch`.
- we can **create**, **copy**, and **assign** objects of any of the exception types
- initialization
  - most exception type objects are initialized from either a `string` or a **C-style string** (that provides additional information about the error that occurred)
  - types that can only be default initialized (cannot take an initializer)
    - `exception`
    - `bad_alloc`
    - `bad_cast`
- exception types define a `what` function
  - takes no arguments 
  - returns a `const char*` that points to a C-style character string
    - contents of returned string:
      - types that take a string initializer: return that string
      - other types: return value depends on the compiler
  - purpose: provide some sort of textual description of the exception thrown

```cpp
// https://cplusplus.com/reference/exception/exception/what/
// exception::what
#include <iostream>       // std::cout
#include <exception>      // std::exception

struct ooops : std::exception {
  const char* what() const noexcept {return "Ooops!\n";}
};

int main () {
  try {
      throw ooops();
  } catch (std::exception& ex) {
      std::cout << ex.what();
  }
  return 0;
}
```

## Matching

- During the search for a matching `catch`, the `catch` that is found is **not** necessarily the one that matches the exception best. 
  - Instead, the selected `catch` is **the first one** that matches the exception at all. 
- As a consequence, in a list of `catch` clauses, the most specialized catch must appear first.

## Rethrow

- a `throw` that is not followed by an expression ("empty" `throw`)
- to pass an exception out to another `catch`
  - the (current) exception object is passed up the chain
- can appear only in
  - in a `catch`
  - in a function called (directly or indirectly) from a `catch`
- if it appears in other places: `std::terminate` is called

```cpp
catch (my_error &eObj) {                // specifier must be a reference type (if we want to modify the exception object, before rethrowing)
  eObj.status = errCodes::severeErr;    // modifies the exception object
  throw;                                // the status member of the exception object is severeErr
} catch (other_error eObj) {
  // ...
  throw;
}
```

## Catch-All Handler

- **informal:** to catch any unhandled exception
- to catch any exception that might occur, regardless of type
- use an **ellipsis** for the exception declaration
- A catch-all clause matches any type of exception
- often used in combination with a [rethrow](#rethrow) expression
- If a `catch(...)` is used in combination with other catch clauses, **it must be last**.
  - Any `catch` that follows a catch-all can never be matched.

```cpp
void manip() {
  try {
    // actions that cause an exception to be thrown
  }
  catch (...) {
    // work to partially handle the exception
    throw;   // rethrow
  }
}
```

## Handle a Constructor that fails

From [isocpp](https://isocpp.org/wiki/faq/exceptions#ctors-can-throw):

Options:
- 1) Throw an exception.
  - Constructors don't have a return type, so it's not possible to use return codes. 
  - **The best way** to signal constructor failure is therefore to throw an exception. 
- 2) "zombie" state: If you don’t have the option of using exceptions, the "least bad" work-around is to put the object into a "zombie" state by setting an internal status bit so the object acts sort of like it's dead even though it is technically still alive.
  - In practice the "zombie" thing gets pretty ugly.

related: [Constructors throwing Exceptions](#constructors-throwing-exceptions)

# argc, argv

see [stackoverflow](https://stackoverflow.com/questions/3024197/what-does-int-argc-char-argv-mean)

# Debugging

see "C notes"

tools:
- gdb
- valgrind

# Unit Testing

## Best Practices

- [Unit Testing Basics](https://www.jetbrains.com/help/clion/unit-testing-tutorial.html#basics)

## Test Runners

### ctest

`ctest` doesn't provide any testing macros/functions/classes on its own. It's just a **test runner**.

[Why useful?](https://www.reddit.com/r/cpp/comments/iwbdx7/is_ctest_worth_the_effort/):
- "**CTest** is useful for running multiple types of tests. You might have unit tests for C++ in **Catch2**, unit tests for python bindings in **pytest**, and you might have application-level testing that runs you program with specified arguments in a short **shell script**. CTest is the place to wire all these frameworks together so you can run all your testing in one shot. It works well for that."
- "And since I haven't seen it mentioned, the big C++ unit testing frameworks can integrate with CTest so you can see the pass/fail status of each test run by the framework"

## Test Frameworks

### Catch2

catch2 vs gtest:
- see [snorristurluson.github.io](https://snorristurluson.github.io/Catch2/)
- see [anteru.net](https://anteru.net/blog/2017/from-google-test-to-catch/)

### GoogleTest, gtest

- based on the **xUnit** architecture

#### Build

To see some **gtest samples**:
- build as [Standalone CMake Project](https://github.com/google/googletest/tree/main/googletest#standalone-cmake-project)

Build method used in AdvCpp course: 
- build by [Incorporating Into An Existing CMake Project](https://github.com/google/googletest/tree/main/googletest#incorporating-into-an-existing-cmake-project)
  - "Use CMake to download GoogleTest as part of the build's configure step. This approach doesn't have the limitations of the other methods." 

Just add to your `CMakeLists.txt` (CMake 3.14 or later):
```cmake
include(FetchContent)
FetchContent_Declare(
  googletest
  # Specify the commit you depend on and update it regularly.
  URL https://github.com/google/googletest/archive/5376968f6948923e2411081fd9372e71a59d8e77.zip
)
# For Windows: Prevent overriding the parent project's compiler/linker settings
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(googletest)

# Now simply link against gtest or gtest_main as needed. Eg
add_executable(example example.cpp)
target_link_libraries(example gtest_main)
add_test(NAME example_test COMMAND example)
```
