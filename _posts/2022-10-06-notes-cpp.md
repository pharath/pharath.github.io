---
title: "C++ Notes"
read_time: false
excerpt: "For learning C++"
header:
    teaser: /assets/images/Cpp_logo.png
    overlay_image: /assets/images/Cpp_logo.png
    overlay_filter: 0.5 
toc: true
toc_label: "Contents"
toc_sticky: true
categories:
    - Notes
tags:
    - c++
    - notes

---

# C++11

- see p. xix "New Features in C++11"

# DEFINITIONS

## areas of memory

- **stack** - Local variables, function parameters 
- **code space** - Code
- **global namespace** - global variables 
- **registers** - used for internal housekeeping functions, such as keeping track of the top of the stack and the instruction pointer
- **free store = heap** - Just about all of the remaining memory 

## Operators

- the **scope** operator "`::`"
- the **output** operator "`<<`"
  - returns its left-hand operand
- the **input** operator "`>>`"
  - returns its left-hand operand
- assignment operator (`=`)
- addition operator (`+`)
- compound assignment operator (`+=`)
- the dot operator (`.`)
  - returns the member named by the right-hand operand
- the call operator (`()`)
- increment operator "`++`"
- decrement operator "`--`"

## Expressions, literals

source: [https://en.cppreference.com/w/cpp/language/expressions](https://en.cppreference.com/w/cpp/language/expressions)

- **expression** := sequence of **operators** and their **operands**, that specifies a computation.
- **primary expression** := literals, [id-expressions](https://www.ibm.com/docs/en/i/7.4?topic=expressions-identifier-c-only), lambda-expressions, fold-expressions, requires-expressions
  - **literals** := the tokens of a C++ program that represent **constant** values ( = Konstanten ) (dh alle Zeichen, die man "nicht ändern kann") 
    - **integer literals** (eg `1`, `2`, `3`, ...)
    - **character literals** (eg einzelne Buchstaben)
    - **boolean literals** (`true` und `false`)
    - **nullptr** (Merke: `nullptr` ist ein **literal**!)
- C++ expression **properties**: "*each C++ expression is characterized by two independent properties*"
  - **1. type**
  - **2. value category:**
    - **Primary categories:**
      - **prvalue expression** (eg literals (s.o.), arithmetic expressions [`+`,`-`,`%`,...], ...)
      - **xvalue expression**
      - **lvalue expression**
    - **Mixed categories:**
      - **glvalue expression**
      - **rvalue expression**

# Header Files

## Newline at EOF

It is good style to always put a newline at the end of text files (POSIX Standard), [stackoverflow](https://stackoverflow.com/questions/729692/why-should-text-files-end-with-a-newline)
- this is part of language standards:
  - in `C`: newline required at the end of header files
  - in `C++`: before `C++11`: newline required at the end of header files
  - "*No newline at end of file*" compiler warning, [stackoverflow](https://stackoverflow.com/questions/72271/no-newline-at-end-of-file-compiler-warning)
- in `git`: [stackoverflow](https://stackoverflow.com/questions/5813311/whats-the-significance-of-the-no-newline-at-end-of-file-log)

# Include Syntax

Usual practice is to use the `#include "local.h"` form for headers inside a `library/package/module`, and the `#include <external.h>` form for headers from `external/3rd-party` or system libraries.

Lippman, Lajoie, Moo: Headers from the **standard library** are enclosed in angle brackets (`< >`). Those that are not part of the library are enclosed in double quotes (`" "`).

# keywords

- see Table 2.3

## "using"

Using the namespace designation is **good form** because, if you use `using namespace some_namespace`, you run the risk of inadvertently using objects from the wrong library. This takes some **effort to fix**, whereas using the namespace designation cannot lead to such conflicts (see [example](https://stackoverflow.com/a/1452738)). I.e. from a **maintenance** perspective using the namespace designation is **best practice**.

# Variables aka Objects

"A region of memory that can contain data and has a type."

C++ programmers use the terms "variable" and "object" interchangeably.

## Types

- primitive types (aka "built-in types")
  - arithmetic types
    - integral types (`char`, `int`, `bool`)
    - floating-point types (`float`, `double`)
  - `void`
- non-primitive types
  - class types
  - library types (e.g. `string`, `istream`, `ostream`)
  - compound types (2.3 "a type that is defined in terms of another type")
    - pointer types
    - reference types (2.3.1)
    - array types
    - container types (9)
      - sequential (full list, see table 9.1) ("element order corresponds to the position at which elements are put into the container")
        - `string` (see "C Notes")
        - `array`
        - `vector`
        - linked lists
          - `list` (doubly linked)
          - `forward_list` (singly linked)
      - associative ("store elements based on the value of a key")
      - unordered

## Initialization

- in C++: initialization != assignment
  - **Initialization** happens when a variable is given a value **when it is created**. 
  - **Assignment** obliterates an object's current value and replaces that value with a new one.

### List Initialization

- C++11
- initialization using **curly braces**
- The compiler will not let us list initialize variables of **built-in type** if the initializer might lead to the loss of information

```cpp
long double ld = 3.1415926536;

int a{ld}, b = {ld}; // error: narrowing conversion required
int c(ld), d = ld;   // ok: but value will be truncated
```

#### Where the form of initialization matters

Examples 
- when we use the **copy initialization** form (i.e., when we use "="), we can supply only a single initializer; 
- when we supply an **in-class initializer** (see [here](#in-class-initialization)), we must either use copy initialization or use curly braces. 
- when we **supply a list of (vector) element values** we can only do this by using list initialization in which the initializers are enclosed in curly braces.
  - We cannot supply a list of initializers using parentheses:
```cpp
vector<string> v1{"a", "an", "the"}; // list initialization
vector<string> v2("a", "an", "the"); // error
```
 
### Default Initialization

When we do not initialize an object/variable.

Controlled by the **default constructor** (see ["Default Constructor"](#default-constructor)).

Default values:
- object of **built-in type**
  - outside a function (global scope): **0**
  - inside a function/block (local scope): **uninitialized/undefined** 
    - best practice: 
      - (in-class) initialize every built-in type object
      - provide a default constructor
- object of **class type**
  - value defined by the class
    - most classes supply a default value
    - some classes require that every object be explicitly initialized
- object of **compound type**
  - inside a function/block (local scope): **uninitialized/undefined**
    - best practice: 
      - (in-class) initialize every compound type object
      - provide a default constructor
 
### Copy Initialization

- using `=`
```cpp
string s1;            // default initialization; s1 is the empty string
string s2 = s1;       // s2 is a copy of s1
string s3 = "hiya";   // s3 is a copy of the string literal
```

### Direct Initialization

- when we omit the `=`
```cpp
string s4(10, ’c’);   // s4 is cccccccccc
```

### In-class Initialization

When we create objects, the in-class initializers will be used to initialize the data members. 

- "Initializer provided as part of the declaration of a class data member."
- C++11
- **Members without an initializer** are default initialized
- form: 
  - initializer in curly braces
  - initializer after a `=` sign 
  - **not:** initializer in parentheses

## Declaration vs Definition
 
- **"separate compilation"**: split programs into several files, each of which can be compiled independently.
- To support separate compilation, C++ distinguishes between declarations and definitions. 
  - A **declaration** makes a name known to the program. A file that wants to use a name defined elsewhere includes a declaration for that name. 
  - A **definition** creates the associated entity.
- A **variable declaration** specifies the type and name of a variable. 
- A **variable definition** is a declaration. 
  - In addition to specifying the name and type, a definition also **allocates storage** and may provide the variable with an **initial value**.
- Variables must be **defined exactly once** but can be **declared many times**.
- To use the same variable in multiple files, we must define that variable in one - and only one - file. Other files that use that variable must declare - but not define - that variable

### extern

- `extern`: To obtain a declaration that is **not** also a definition, we add the `extern` keyword and must not provide an explicit initializer.
- inside a function
  - It is an error to provide an initializer on an `extern` 
- outside a function 
  - we can initialize an `extern`, however, this overrides the `extern`. The `extern` becomes a definition in this case.

## Static typing

- C++ is a statically typed language, which means that **types are checked at compile time**. 
- The process by which types are checked is referred to as **type checking**.
- consequence of static typing: must declare the type of a variable before we can use that variable

## const objects

- may call only const member functions
- a `const` object does not assume its "constness" until after the constructor completes the object's initialization

# Classes

## Constructors

- "Classes control object **initialization** by defining one or more special member functions known as **constructors**."
- Constructors 
  - have the same **name** as the class.
  - control object **initialization**
  - are special member functions, but
    - have no return type
    - must not be declared as `const`
- a class may have multiple constructors (&rarr; overloading)
- can write to const objects during their construction

### Default Constructor

- "a constructor which can be called with no arguments" (cppreference)
- either: **explicitly defined default constructor**
- or: **synthesized default constructor** (implicitly defined default constructor)
  - the compiler **implicitly** defines this constructor, if we do not explicitly define one
    - but **only if** a class declares **NO** constructors
  - member initialization
    - if there is an **in-class initializer**, use it to initialize the member
    - else **default initialize** the member
- when we **have to** explicitly define a default constructor
  - 1. we have defined at least one constructor, and therefore, the compiler will not generate a default constructor
  - 2. to make sure that **class members of built-in types** or compound types cannot end up uninitialized
    - **in function blocks**: objects of built-in or compound type that are defined inside a block have **undefined value** when they are default initialized (see ["Default Initialization"](#default-initialization))
    - **in class blocks**: the same problem arises for default initialized **members** of built-in type
  - 3. sometimes the compiler cannot synthesize a default constructor
- `= default` keyword
  - C++11
  - we can ask the compiler to generate the constructor for us by writing `= default` after the parameter list
    - this constructor does exactly the same work as the synthesized default constructor

### Constructor Initializer List

- When a member is omitted from the constructor initializer list, it is implicitly initialized **using the same process as is used by the synthesized default constructor**

## Access Control and Encapsulation

access Specifiers (to enforce encapsulation, i.e. hiding of implementation details)
- `public` members: defines the interface
- `private` members: encapsulate (i.e., hide) the implementation

The only difference between `struct` and `class` is the **default access level**:
- If we use the `struct` keyword, the members defined before the first access specifier are `public`
- if we use `class`, then the members are `private`

Best practice:
- When we define a class intending for all of its members to be `public`, we use `struct`. 
- If we intend to have `private` members, then we use `class`.

Benefits of Encapsulation:
- User code cannot inadvertently corrupt the state of an encapsulated object.
- The implementation of an encapsulated class can change over time without requiring changes in user-level code.

## Friends

- A class can allow another class or function to **access its nonpublic members** by making that class or function a `friend`
  - `friend` declarations 
    - may appear only inside a class definition
    - may appear anywhere in the class
  - friends
    - are not members
    - are not affected by the access control of the section in which they are declared
  - A friend declaration **is not a general declaration** of the function. 
    - we must also declare the function **separately** from the friend declaration (some compilers do not require this, but this is best practice)
- best practice: 
  - group friend declarations together at the beginning or end of the class definition
  - declare each friend (outside the class) in the same header as the class

# Containers

- each container is defined in a header file with the same name as the type
- containers are class templates (3.3)
- container types: see ["Types"](#types)

# Nullpointer: nullptr, NULL

## Definition

- [Bjarne Stroustrup comment](https://www.stroustrup.com/bs_faq2.html#null)
- ([g++ doc](https://gcc.gnu.org/onlinedocs/libstdc++/manual/support.html#std.support.types.null))
- `NULL` ist definiert als [macro](https://gcc.gnu.org/onlinedocs/cpp/Macros.html) (i.e. a piece of code in a program that is replaced by the value of the macro; a macro is defined by `#define` directive; whenever a macro name is encountered by the [preprocessor](https://en.wikipedia.org/wiki/Preprocessor), it replaces the name with the definition of the macro): 
  - From [cppreference](https://en.cppreference.com/w/cpp/types/NULL):
    ```cpp
    #define NULL 0
    //since C++11
    #define NULL nullptr
    ```
  - dh `NULL` und `0` waren früher **dasselbe** [bis C++11] und jetzt sind `NULL` und `nullptr` **dasselbe** (aber how come [implicit cast difference](#implicit-cast-of-null-and-nullptr)?)
- "Unless you need to be compatible with C++98/C++03 or C you should prefer to use `nullptr` instead of `NULL`." ([g++ doc](https://gcc.gnu.org/onlinedocs/libstdc++/manual/support.html#std.support.types.null))

## Implicit Cast of NULL and nullptr

### To Pointer Types

- `NULL` und `nullptr` beide implicitly convertible to any **pointer** type
    - A **null pointer** constant (see `NULL`), can be converted to any **pointer** type [i.e. type with asterisk `*`], and the result is the null pointer value of that type. ([cppreference](https://en.cppreference.com/w/cpp/language/implicit_conversion))

### To Integral Types

- Unlike `NULL`, `nullptr` is **not** implicitly convertible or comparable to integral types [e.g. `int`, `char`] ([geeksforgeeks](https://www.geeksforgeeks.org/understanding-nullptr-c/))
    - `int x = NULL` geht; 
    - `int x = nullptr` geht **nicht**!
- `nullptr` is of type `nullptr_t`, which is implicitly convertible and comparable to any pointer type or pointer-to-member type. **It is not implicitly convertible or comparable to integral types** [e.g. `int`, `char`], **except for** `bool`. ([C++11](https://en.wikipedia.org/wiki/C%2B%2B11#Null_pointer_constant))

## Type of NULL and nullptr

- "In C, the macro `NULL` may have the type `void*`, but that is not allowed in C++." ([cppreference](https://en.cppreference.com/w/cpp/types/NULL))
    - how come?: [stackoverflow](https://stackoverflow.com/a/69057243)
    - soll heißen: `NULL` hat in C++ **absichtlich nicht (wie in C)** den Type `void*`, weil there is no **implicit cast** from `void*` to any other type in C++ (in C wäre das aber möglich!). Bis C++11 war `NULL` das [integer literal](https://en.cppreference.com/w/cpp/language/integer_literal) "`0`", konnte damit also einen der integer literal types (s. Tabelle in [integer literal](https://en.cppreference.com/w/cpp/language/integer_literal)) haben. Seit C++11 hat `NULL` den type `nullptr_t` ([doc](https://en.cppreference.com/w/cpp/types/nullptr_t)).
      (dh zB
      ```cpp
      void* ptr = nullptr; 
      int foo = *ptr;    // this implicit cast is not allowed in C++
      ```
      gibt einen Compiler Error `error: ‘void*’ is not a pointer-to-object type`
      (**fix**: use a different type (a "pointer-to-object" type) instead of `void*` -  `void*` is a "pointer-to-nothing")
      Aber 
      ```cpp
      char* ptr = nullptr; 
      int foo = *ptr;
      ```
      gibt keinen Compiler Error, weil `char*` ein pointer-to-object type ist.)

# Polymorphism

1. function **overloading**
2. templates
3. virtual functions ( **overriding** )

[source](https://www.geeksforgeeks.org/templates-cpp/)
- "Both function overloading and templates are examples of **polymorphism** features of OOP."
- function templates vs overloading: 
  - "Function overloading is used when multiple functions do quite similar (not identical) operations, templates are used when multiple functions do identical operations."

# Templates

- can make the code shorter and more manageable

## Function Templates

**Function Template**:

[stackoverflow](https://www.cplusplus.com/doc/oldtutorial/templates/)

```cpp
// function template
#include <iostream>
using namespace std;

template <class T>
T GetMax (T a, T b) {
  T result;
  result = (a>b)? a : b;
  return (result);
}

int main () {
  int i=5, j=6, k;
  long l=10, m=5, n;
  k=GetMax<int>(i,j);
  n=GetMax<long>(l,m);
  cout << k << endl;
  cout << n << endl;
  return 0;
}
```

**Generic Type**: Function templates are special functions that can operate with **generic types**. This allows us to create a function template whose functionality can be adapted to more than one type or class without repeating the entire code for each type.

**Template Parameter**: In C++ this can be achieved using **template parameters**. A template parameter is a special kind of parameter that can be used to pass a type as argument: just like regular function parameters can be used to pass values to a function, template parameters allow to pass also types to a function. These function templates can use these parameters as if they were any other regular type.

## Class Templates

[source](https://www.geeksforgeeks.org/templates-cpp/):
- to create a single class to work with different data types
- useful when a class defines something that is independent of the data type. 
  - Can be useful for classes like LinkedList, BinaryTree, Stack, Queue, Array, etc.

```cpp
// C++ Program to implement
// template Array class
#include <iostream>
using namespace std;

template <typename T> class Array {
private:
    T* ptr;
    int size;

public:
    Array(T arr[], int s);
    void print();
};

template <typename T> Array<T>::Array(T arr[], int s)
{
    ptr = new T[s];
    size = s;
    for (int i = 0; i < size; i++)
        ptr[i] = arr[i];
}

template <typename T> void Array<T>::print()
{
    for (int i = 0; i < size; i++)
        cout << " " << *(ptr + i);
    cout << endl;
}

int main()
{
    int arr[5] = { 1, 2, 3, 4, 5 };
    Array<int> a(arr, 5);
    a.print();
    return 0;
}
```

# Overloading vs Overriding

- overloading: the same function name, but with a different signature (i.e. name of the function, the parameter list, and the keyword `const`, if used)
- overriding: the same function name and the same signature

# Overloading

[stackoverflow](https://www.tutorialspoint.com/cplusplus/cpp_overloading.htm)

**Function Overloading**, **Operator Overloading**: C++ allows you to specify more than one definition for a **function** name or an **operator** in the same scope, which is called **function overloading** and **operator overloading** respectively. 

**overloaded declaration**, **overload resolution**: An overloaded declaration is a declaration that is declared with the same name as a previously declared declaration in the same scope, except that both declarations have different arguments and obviously different definition (implementation). When you call an overloaded **function** or **operator**, the compiler determines the most appropriate definition to use, by comparing the argument types you have used to call the function or operator with the parameter types specified in the definitions. The process of selecting the most appropriate overloaded function or operator is called **overload resolution**.

# Overriding

- "**Overriding** a function means changing the implementation of a base class function in a derived class." (Day 12, J Liberty)

## "Normal" Overriding

- "When a derived class creates a function with the same return type and signature as a member function in the base class, but with a new implementation, it is said to be **overriding** that function. When you make an object of the derived class, the correct function is called." (Day 12, J Liberty)

## virtual

- C++ allows **pointers to base classes** to be assigned to derived class objects `BaseClass* pBase = new DerivedClass;` (Day 12, J Liberty)
  - `pBase` can invoke any method on `BaseClass`, but what we would like is for those methods that are overridden in `DerivedClass()` to call the correct function
- phth: "normal" overriding (cf. above) is possible **without** the `virtual` (see Day 12, J Liberty), but, if a pointer to the base class is assigned to the derived class object, and we use this pointer to call an overridden function, the overriding will not work

[source](https://www.programiz.com/cpp-programming/virtual-functions):
- A **virtual function** is a member function in the base class that we *expect* to redefine in derived classes.
- Basically, a virtual function is used in the base class in order to ensure that the function is **overridden**. This especially applies to cases where a pointer of base class points to an object of a derived class.

```cpp
// source: https://www.geeksforgeeks.org/virtual-functions-in-derived-classes-in-cpp/
// C++ Program to demonstrate Virtual
// functions in derived classes
#include <iostream>
using namespace std;

class A {
public:
	virtual void fun() { cout << "\n A::fun() called "; } 
};

class B : public A {
public:
	void fun() { cout << "\n B::fun() called "; }
};

class C : public B {
public:
	void fun() { cout << "\n C::fun() called "; }
};

int main()
{
	// An object of class C
	C c;

	// A pointer of class B pointing
	// to memory location of c
	B* b = &c;

	// this line prints "C::fun() called"
    // (Note: without the "virtual" in "class A" this line prints "\n A::fun() called ")
	b->fun();

	getchar(); // to get the next character
	return 0;
}
```

# Double Colon prepended to the class name

[stackoverflow](https://stackoverflow.com/questions/4269034/what-is-the-meaning-of-prepended-double-colon)

This ensures that resolution occurs from the global namespace, instead of starting at the namespace you're currently in. For instance, if you had two different classes called `Configuration` as such:

```cpp
class Configuration; // class 1, in global namespace
namespace MyApp
{
    class Configuration; // class 2, different from class 1
    function blah()
    {
        // resolves to MyApp::Configuration, class 2
        Configuration::doStuff(...) 
        // resolves to top-level Configuration, class 1
        ::Configuration::doStuff(...)
    }
}
```

Basically, it allows you to traverse up to the global namespace since your name might get clobbered by a new definition inside another namespace, in this case `MyApp`.

# argc, argv

[stackoverflow](https://stackoverflow.com/questions/3024197/what-does-int-argc-char-argv-mean)

# Common Types

## std::array

- "a container that encapsulates **fixed size** arrays"
- "an aggregate type"
- "same semantics as a `struct` holding a **C-style array** `T[N]` as its only non-static data member."
  - **But**: "Unlike a C-style array, it doesn't decay to `T*` automatically."

## std::vector

- **flexible-size** array (as opposed to the **fixed-size** array `std::array`)

## std::string

- A specialized container that contains characters.
- similar to `vector`

### Convert to C-style string (null-terminated string)

`.c_str()` converts a string to a null-terminated string (C-style string)

[stackoverflow](https://stackoverflow.com/questions/7416445/what-is-use-of-c-str-function-in-c) (s. Antwort von hkBattousai)

# Streams

A **stream** is a sequence of characters read from or written to an IO device. The term stream is intended to suggest that the characters are generated, or consumed, sequentially over time.

## iostream library

Defines the **types**: `istream` and `ostream`
Objects of type `istream`:
- `cin`
Objects of type `ostream`:
- `cout`
- `cerr`
- `clog`

## Buffer, Print Statements

**buffer**: A region of storage used to hold data. IO facilities often store input (or output) in a buffer and read or write the buffer independently from actions in the program. Output buffers can be explicitly flushed to force the buffer to be written. By default, reading cin flushes cout; cout is also flushed when the program ends normally.

`std::cout << "string" << std::endl`: Writing `endl` has the effect of ending the current line and **flushing the buffer** associated with that device. Flushing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.
- **Best practice**: Programmers often add **print statements** during debugging. Such statements should **always flush the stream**. Otherwise, if the program crashes, output may be left in the buffer, leading to incorrect inferences about where the program crashed.

# typedef struct

[Why should we typedef a struct so often in C? - Stack Overflow](https://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c)

# Lambdas

From [learn.microsoft](https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170):
- In C++11 and later, a **lambda expression** - often called **a lambda** - is a convenient way of defining an anonymous function object (a closure) right at the location where it's invoked or passed as an argument to a function. Typically lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous functions.

# Functions

## const member functions

A "const function", denoted with the keyword `const` after a function declaration, makes it a compiler error for this class function to change a member variable of the class. However, reading of a class variables is okay inside of the function, but writing inside of this function will generate a compiler error. [stackoverflow](https://stackoverflow.com/a/3141107)

"const member functions cannot change the object on which they are called."
- The purpose of that `const` is to modify the type of the implicit `this` pointer.

## inline functions

- A function specified as `inline` (usually) is expanded "in line" at each call. 
  - the word "usually" means that this expansion does not happen sometimes because the compiler can choose to ignore the `inline`! (see point below)
- inline functions may be defined multiple times in the program (unlike ordinary functions), but all definitions must match
  - therefore, inline functions normally are **defined in headers**
- `inline` removes the **run-time overhead** of using a normal function.
  - Explanation: **Calling** a function is likely to be slower than **evaluating** the equivalent expression.
    - On most machines, a **function call** does a lot of work:
      - Registers are saved before the call and restored after the return;
      - arguments may be copied; and
      - the program branches to a new location.
- The inline specification is only a **request** to the compiler.
  - The compiler may choose to ignore this request.
- In general, the inline mechanism is meant to optimize **small, straight-line functions that are called frequently**.
  - Many compilers will not inline a recursive function.
  - A 75-line function will almost surely not be expanded inline.

### inline member functions

- member functions ...
  - defined inside the class: automatically inline
  - defined outside the class: need to specify as `inline`
  - declared inside the class: need to specify as `inline`
- inline member functions should be defined in the same header as the corresponding class definition (for the same reason as described for inline functions)
- it is legal to specify `inline` on both the declaration and the definition. 
  - Best practice: specifying `inline` only on the definition outside the class can make the class easier to read.

## return values

ignoring return values:
- "calling a function and ignoring the return result is *very* common", [stackoverflow](https://stackoverflow.com/a/38919156)
- `printf("hello\n");` ignores the return value, [stackoverflow](https://stackoverflow.com/a/38919103)

# Debugging

see "C notes"

tools:
- gdb
- valgrind

# Unit Testing

## Best Practices

- [Unit Testing Basics](https://www.jetbrains.com/help/clion/unit-testing-tutorial.html#basics)

## Test Runners

### ctest

`ctest` doesn't provide any testing macros/functions/classes on its own. It's just a **test runner**.

[Why useful?](https://www.reddit.com/r/cpp/comments/iwbdx7/is_ctest_worth_the_effort/):
- "**CTest** is useful for running multiple types of tests. You might have unit tests for C++ in **Catch2**, unit tests for python bindings in **pytest**, and you might have application-level testing that runs you program with specified arguments in a short **shell script**. CTest is the place to wire all these frameworks together so you can run all your testing in one shot. It works well for that."
- "And since I haven't seen it mentioned, the big C++ unit testing frameworks can integrate with CTest so you can see the pass/fail status of each test run by the framework"

## Test Frameworks

### Catch2

catch2 vs gtest:
- [snorristurluson.github.io](https://snorristurluson.github.io/Catch2/)
- [anteru.net](https://anteru.net/blog/2017/from-google-test-to-catch/)

### GoogleTest, gtest

- based on the **xUnit** architecture

#### Build

To see some **gtest samples**:
- build as [Standalone CMake Project](https://github.com/google/googletest/tree/main/googletest#standalone-cmake-project)

Build method used in AdvCpp course: 
- build by [Incorporating Into An Existing CMake Project](https://github.com/google/googletest/tree/main/googletest#incorporating-into-an-existing-cmake-project)
  - "Use CMake to download GoogleTest as part of the build's configure step. This approach doesn't have the limitations of the other methods." 

Just add to your `CMakeLists.txt` (CMake 3.14 or later):
```cmake
include(FetchContent)
FetchContent_Declare(
  googletest
  # Specify the commit you depend on and update it regularly.
  URL https://github.com/google/googletest/archive/5376968f6948923e2411081fd9372e71a59d8e77.zip
)
# For Windows: Prevent overriding the parent project's compiler/linker settings
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(googletest)

# Now simply link against gtest or gtest_main as needed. Eg
add_executable(example example.cpp)
target_link_libraries(example gtest_main)
add_test(NAME example_test COMMAND example)
```
