<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>C Notes - Pharath Palesuvaran</title>
<meta name="description" content="For learning C. Content mostly from Bradley L. Jones, Peter Aitken - Sams Teach Yourself C in 21 Days -Sams (2002).">


  <meta name="author" content="Pharath Palesuvaran">
  
  <meta property="article:author" content="Pharath Palesuvaran">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Pharath Palesuvaran">
<meta property="og:title" content="C Notes">
<meta property="og:url" content="http://localhost:4000/notes/notes-c/">


  <meta property="og:description" content="For learning C. Content mostly from Bradley L. Jones, Peter Aitken - Sams Teach Yourself C in 21 Days -Sams (2002).">



  <meta property="og:image" content="http://localhost:4000/assets/images/C_logo.png">





  <meta property="article:published_time" content="2022-09-22T00:00:00+02:00">






<link rel="canonical" href="http://localhost:4000/notes/notes-c/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Pharath Palesuvaran Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/pharath/home/master/assets/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/pharath/home/master/assets/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/pharath/home/master/assets/favicons/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/pharath/home/master/assets/favicons/site.webmanifest">
<link rel="shortcut icon" href="https://raw.githubusercontent.com/pharath/home/master/assets/favicons/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="https://raw.githubusercontent.com/pharath/home/master/assets/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">

<script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } }); </script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\(","\\)"] ],
    },
		TeX: {
    	Macros: {
				bra: ["\\langle{#1}|", 1],
				ket: ["|{#1}\\rangle", 1],
        braket: ["\\langle{#1}\\rangle", 1],
				bk: ["\\langle{#1}|{#2}|{#3}\\rangle", 3]
    	}
  	}
	});

</script>
<!--
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML' async></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML' async></script>
-->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML' async></script>

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/pytorch-logo.png" alt="Pharath Palesuvaran"></a>
        
        <a class="site-title" href="/">
          Pharath Palesuvaran
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/posts/">Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/">Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">Tags</a>
            </li><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li></ul>
        
        <button class="search__toggle" type="button" accesskey="s">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      
  







<div class="page__hero--overlay"
  style=" background-image: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url('/assets/images/C_logo.png');"
>
  
    <div class="wrapper">
      <h1 id="page-title" class="page__title" itemprop="headline">
        
          C Notes

        
      </h1>
      
        <p class="page__lead">For learning C. Content mostly from Bradley L. Jones, Peter Aitken - Sams Teach Yourself C in 21 Days -Sams (2002).
</p>
      
      

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2022-09-22T00:00:00+02:00">September 22, 2022</time>
      </span>
    

    

    
  </p>


      
      
    </div>
  
  
</div>







<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person" class="h-card">

  
    <div class="author__avatar">
      <a href="http://localhost:4000/">
        <img src="/assets/images/profile_pic.jpg" alt="Pharath Palesuvaran" itemprop="image" class="u-photo">
      </a>
    </div>
  

  <div class="author__content">
    <h3 class="author__name p-name" itemprop="name">
      <a class="u-url" rel="me" href="http://localhost:4000/" itemprop="url">Pharath Palesuvaran</a>
    </h3>
    
      <div class="author__bio p-note" itemprop="description">
        <p>Machine Learning, Computer Vision, Self-driving cars and a very rusty first degree in Physics</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name" class="p-locality">Aachen (Germany)</span>
        </li>
      

      
        
          
            <li><a href="mailto:phrth2@gmail.com" rel="nofollow noopener noreferrer me"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span></a></li>
          
        
          
        
          
            <li><a href="https://twitter.com/pharath_one" rel="nofollow noopener noreferrer me" itemprop="sameAs"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label">Twitter</span></a></li>
          
        
          
            <li><a href="https://github.com/pharath" rel="nofollow noopener noreferrer me" itemprop="sameAs"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
            <li><a href="/_pages/404.md" rel="nofollow noopener noreferrer me"><i class="fab fa-fw fa-instagram" aria-hidden="true"></i><span class="label">Instagram</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer me">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="C Notes">
    <meta itemprop="description" content="For learning C. Content mostly from Bradley L. Jones, Peter Aitken - Sams Teach Yourself C in 21 Days -Sams (2002).">
    <meta itemprop="datePublished" content="2022-09-22T00:00:00+02:00">
    

    <div class="page__inner-wrap">
      

      <section class="page__content e-content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> Contents</h4></header>
              <ul class="toc__menu"><li><a href="#concepts">Concepts</a></li><li><a href="#about-c">About C</a></li><li><a href="#documentation">Documentation</a></li><li><a href="#build">Build</a><ul><li><a href="#source-code">Source Code</a></li><li><a href="#object-code">Object Code</a></li><li><a href="#binary-files-elf-files">Binary files (ELF files)</a><ul><li><a href="#elf-header">ELF Header</a></li></ul></li></ul></li><li><a href="#operator-precedence-associativity">Operator Precedence, Associativity</a></li><li><a href="#variables">Variables</a><ul><li><a href="#global-variables-aka-external-variables">Global variables (aka External variables)</a><ul><li><a href="#best-practice">Best practice</a></li></ul></li><li><a href="#local-variables">Local variables</a></li><li><a href="#static-variables-vs-automatic-variables">Static variables vs. Automatic variables</a><ul><li><a href="#storage-duration">Storage Duration</a></li></ul></li></ul></li><li><a href="#int">Int</a><ul><li><a href="#low-order-byte-and-high-order-byte">Low-order byte and High-order byte</a></li></ul></li><li><a href="#arrays">Arrays</a><ul><li><a href="#definition">Definition</a></li><li><a href="#declaration">Declaration</a></li><li><a href="#initialization">Initialization</a></li><li><a href="#subscripts">Subscripts</a></li><li><a href="#passing-arrays-to-a-function">Passing arrays to a function</a></li><li><a href="#copy-2d-array-and-assign-it-to-another">Copy 2d array and assign it to another</a></li><li><a href="#out-of-bounds-error">Out of bounds error</a></li><li><a href="#best-practice-1">Best practice</a></li></ul></li><li><a href="#program-inputoutput-devices">Program Input/Output, Devices</a></li><li><a href="#streams">Streams</a><ul><li><a href="#five-standard-streams">Five Standard Streams</a></li></ul></li><li><a href="#stream-functions">Stream Functions</a><ul><li><a href="#input-functions">Input Functions</a></li><li><a href="#output-functions">Output Functions</a></li></ul></li><li><a href="#printf">printf</a><ul><li><a href="#escape-sequences">Escape sequences</a></li><li><a href="#format-specifiers">Format specifiers</a></li></ul></li><li><a href="#scanf-gets-fgets">scanf, gets, fgets</a><ul><li><a href="#control-characters">Control Characters</a></li><li><a href="#scanf">scanf</a></li><li><a href="#gets">gets</a></li><li><a href="#fgets">fgets</a></li></ul></li><li><a href="#char">Char</a></li><li><a href="#strings">Strings</a><ul><li><a href="#definitions">Definitions</a></li><li><a href="#string-literals">String Literals</a><ul><li><a href="#faq---string-literals">FAQ - string literals</a></li></ul></li><li><a href="#create-strings-as-char-arrays">Create Strings as char arrays</a></li><li><a href="#create-strings-without-arrays">Create Strings without arrays</a><ul><li><a href="#allocate-string-space-at-compilation">Allocate string space at compilation</a></li><li><a href="#allocate-string-space-at-runtime-malloc">Allocate string space at runtime (malloc)</a></li></ul></li></ul></li><li><a href="#pointer">Pointer</a><ul><li><a href="#size-of-pointers">Size of pointers</a></li><li><a href="#data-type-of-pointers">Data type of pointers</a></li><li><a href="#null-pointer">NULL pointer</a><ul><li><a href="#usage">Usage</a></li><li><a href="#difference-between-a-void-pointer-and-a-null-pointer">Difference between a void pointer and a NULL pointer?</a></li></ul></li><li><a href="#pointer-arithmetic">Pointer arithmetic</a></li><li><a href="#address-of-a-pointer--multiple-indirection">Address of a pointer / multiple indirection</a></li><li><a href="#passing-function-arguments">Passing Function arguments</a></li></ul></li><li><a href="#structs">Structs</a><ul><li><a href="#3-ways-to-access-a-structure-member">3 ways to access a structure member</a></li><li><a href="#typedef">typedef</a></li></ul></li><li><a href="#type-conversions">Type Conversions</a><ul><li><a href="#type-promotion-implicit-conversion-automatic-conversion">Type Promotion (implicit conversion, automatic conversion)</a></li><li><a href="#cast--typecast-explicit-conversion">Cast / Typecast (explicit conversion)</a></li></ul></li><li><a href="#memory">Memory</a><ul><li><a href="#areas-of-memory">Areas of memory</a><ul><li><a href="#registers">Registers</a></li><li><a href="#code-space">Code space</a></li><li><a href="#stack">Stack</a><ul><li><a href="#function-calls-stack-pointer-esp-and-frame-pointer-ebp">Function Calls: Stack Pointer (ESP) and Frame Pointer (EBP)</a></li></ul></li><li><a href="#global-namespace">Global namespace</a></li><li><a href="#free-store-heap">Free store (Heap)</a></li></ul></li><li><a href="#ram-available-for-allocation">RAM available for allocation</a></li><li><a href="#static-vs-dynamic-memory-allocation">Static vs. Dynamic Memory Allocation</a><ul><li><a href="#static-memory-allocation">Static Memory Allocation</a></li><li><a href="#dynamic-memory-allocation">Dynamic Memory Allocation</a></li></ul></li><li><a href="#allocation-functions">Allocation Functions</a><ul><li><a href="#malloc-stdlibh">malloc (stdlib.h)</a></li><li><a href="#calloc-stdlibh">calloc (stdlib.h)</a></li><li><a href="#realloc-stdlibh">realloc (stdlib.h)</a></li></ul></li><li><a href="#deallocation">Deallocation</a><ul><li><a href="#free-stdlibh">free (stdlib.h)</a></li></ul></li><li><a href="#manipulation">Manipulation</a></li></ul></li><li><a href="#linked-list">Linked List</a></li></ul>

            </nav>
          </aside>
        
        <h1 id="concepts">Concepts</h1>

<ul>
  <li><a href="https://online.rwth-aachen.de/RWTHonline/ee/ui/ca2/app/desktop/#/slc.tm.cp/student/courses/458361?$ctx=design=ca;lang=de&amp;$scrollTo=toc_overview">RWTH Grundgebiete der Informatik 1</a>
    <ul>
      <li>Gegenstand der Vorlesung ist die Einführung in Programmiertechniken, Datenstrukturen und Algorithmen anhand von C.</li>
      <li>Grundlegende Programmelemente:
        <ul>
          <li>Skalare und zusammengesetzte Datentypen, Anweisungen, Kontrollfluß, Funktionen, Klassen, C-Programmstruktur und Programmierumgebung;</li>
        </ul>
      </li>
      <li>Programmanalyse:
        <ul>
          <li>Wachstumsordnungen, Komplexitätsklassen, best/worst case Analyse;</li>
        </ul>
      </li>
      <li>Lineare Datenstrukturen:
        <ul>
          <li>Listen, Stacks, Queues, Iteration und Rekursion;</li>
        </ul>
      </li>
      <li>Nichtlineare Datenstrukturen und Suchverfahren:
        <ul>
          <li>Bäume, Graphen, Suchbäume, Hashtabellen;</li>
        </ul>
      </li>
      <li>Algorithmenentwurf:
        <ul>
          <li>Sortierverfahren, Heuristiken, Greedy-Algorithmen, grundlegende Optimierungsverfahren</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="about-c">About C</h1>

<ul>
  <li>C is a <strong>procedural</strong> language, whereas C++ is an <strong>object-oriented</strong> language</li>
</ul>

<h1 id="documentation">Documentation</h1>

<ul>
  <li>standard library
    <ul>
      <li>On Unix-like systems, the authoritative documentation of the actually implemented API is provided in the form of <code class="language-plaintext highlighter-rouge">man</code> pages.</li>
      <li>On most systems, man pages on standard library functions are in section 3 (e.g. <code class="language-plaintext highlighter-rouge">man 3 malloc</code>, <code class="language-plaintext highlighter-rouge">man 3 puts</code>, etc.)</li>
      <li>Section 7 may contain some more generic pages on underlying concepts (e.g. <code class="language-plaintext highlighter-rouge">man 7 math_error</code> in Linux).</li>
    </ul>
  </li>
</ul>

<h1 id="build">Build</h1>

<h2 id="source-code">Source Code</h2>

<ul>
  <li>TODO</li>
</ul>

<h2 id="object-code">Object Code</h2>

<ul>
  <li>With the help of an adequate <strong>compiler</strong>, for example GCC, your source code is translated into <strong>object code</strong>, first.</li>
</ul>

<h2 id="binary-files-elf-files">Binary files (ELF files)</h2>

<ul>
  <li><a href="https://linuxhint.com/understanding_elf_file_format/">What is an ELF file</a></li>
  <li>Eventually, the <strong>linker</strong> translates the object code into a <strong>binary file</strong> that links the object code with the referenced <strong>libraries</strong>.</li>
  <li>This binary file contains the single instructions as machine code that are understood by the CPU, and are executed as soon the compiled program is run.</li>
  <li>The binary file follows a specific <strong>structure</strong>, and one of the most common ones is named <strong>ELF</strong> that abbreviates <strong>Executable and Linkable Format</strong>.</li>
  <li>ELF is widely used for
    <ul>
      <li>executable files</li>
      <li>relocatable object files</li>
      <li>shared libraries</li>
      <li>core dumps</li>
    </ul>
  </li>
  <li>The specification does <strong>not</strong> clarify the <strong>filename extension</strong> for ELF files. In use is a variety of letter combinations, such as
    <ul>
      <li>.axf,</li>
      <li>.bin,</li>
      <li>.elf,</li>
      <li>.o,</li>
      <li>.prx,</li>
      <li>.puff,</li>
      <li>.ko,</li>
      <li>.so, and</li>
      <li>.mod,</li>
      <li>or none.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">man elf</code> gives you a handy summary about the structure of an ELF file</li>
</ul>

<h3 id="elf-header">ELF Header</h3>

<ul>
  <li>reading the ELF header:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">readelf -h elf_file</code>
        <ul>
          <li>read more about <code class="language-plaintext highlighter-rouge">readelf</code> in (<a href="https://linuxhint.com/understanding_elf_file_format/">What is an ELF file</a>)</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">objdump -h elf_file</code></li>
    </ul>
  </li>
  <li>The ELF header is 32 bytes long, and identifies the format of the file.</li>
  <li>It starts with a sequence of four unique bytes that are 0x7F followed by 0x45, 0x4c, and 0x46 which translates into the three letters E, L, and F.</li>
  <li>Among other values, the header also indicates
    <ul>
      <li>whether it is an ELF file for 32 or 64-bit format,</li>
      <li>uses little or big endianness,</li>
      <li>shows the ELF version</li>
      <li>as well as for which operating system the file was compiled for in order to interoperate with the right application binary interface (ABI) and cpu instruction set.</li>
    </ul>
  </li>
</ul>

<h1 id="operator-precedence-associativity">Operator Precedence, Associativity</h1>

<ul>
  <li>When multiple operators of the same precedence level are used in an expression, they are evaluated according to their <strong>associativity</strong> (<a href="https://www.programiz.com/cpp-programming/operators-precedence-associativity">source</a>)</li>
</ul>

<h1 id="variables">Variables</h1>

<h2 id="global-variables-aka-external-variables">Global variables (aka External variables)</h2>

<ul>
  <li>external variable: a variable defined outside of any function</li>
  <li>scope: the scope is the entire source code file that contains the variable definition</li>
  <li>If you don’t explicitly initialize an external variable when it’s defined, the compiler initializes it to 0.
    <ul>
      <li>this is different than local variables!</li>
    </ul>
  </li>
</ul>

<h3 id="best-practice">Best practice</h3>

<ul>
  <li>use them rarely
    <ul>
      <li>because usage violates the principle of <strong>modular independence</strong>
        <ul>
          <li>i.e each function should be self-contained/modular</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>use them only when all or most of the program’s functions need access to the variable</li>
  <li>When a function uses an external variable, it is good programming practice to declare the variable within the function using the <code class="language-plaintext highlighter-rouge">extern</code> keyword (see <a href="https://en.cppreference.com/w/c/language/storage_duration">Storage-class specifiers</a>)</li>
</ul>

<h2 id="local-variables">Local variables</h2>

<ul>
  <li>aren’t automatically initialized to 0 by the compiler
    <ul>
      <li>if not initialized they have an <strong>undefined</strong> or <strong>garbage value</strong></li>
    </ul>
  </li>
</ul>

<h2 id="static-variables-vs-automatic-variables">Static variables vs. Automatic variables</h2>

<ul>
  <li>local variables are <strong>automatic</strong> by default, i.e.
    <ul>
      <li>created anew each time the function is called</li>
      <li>destroyed when execution leaves the function
        <ul>
          <li>thus doesn’t retain its value between calls to the function in which it is defined.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>In order for a local variable to retain its value between function calls, it must be defined as <strong>static</strong> with the <code class="language-plaintext highlighter-rouge">static</code> keyword.
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">lineCount</span><span class="p">;</span>
  <span class="cm">/* Additional code goes here */</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>(optional) if you want to, you can include the <code class="language-plaintext highlighter-rouge">auto</code> keyword in the definition
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
  <span class="cm">/* Additional code goes here */</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">static</code> and <code class="language-plaintext highlighter-rouge">auto</code> are <strong>Storage-class specifiers</strong> (see <a href="#storage-duration">below</a>)</li>
</ul>

<h3 id="storage-duration">Storage Duration</h3>

<p>From cppreference: <a href="https://en.cppreference.com/w/c/language/storage_duration#Storage_duration">Storage duration</a></p>
<ul>
  <li><strong>Storage-class specifiers</strong>: Specify <em>storage duration</em> (…) of objects and functions.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">auto</code> (automatic storage duration)</li>
      <li><code class="language-plaintext highlighter-rouge">register</code> (automatic storage duration)</li>
      <li><code class="language-plaintext highlighter-rouge">static</code> (static storage duration)</li>
      <li><code class="language-plaintext highlighter-rouge">extern</code> (static storage duration)</li>
      <li><code class="language-plaintext highlighter-rouge">_Thread_local</code> (thread storage duration)</li>
    </ul>
  </li>
  <li><strong>Storage duration</strong>: Every object has a property called <em>storage duration</em>, which limits the <em>object lifetime</em>. There are four kinds of storage duration in C:
    <ul>
      <li><strong>static</strong>
        <ul>
          <li>The storage duration is the entire execution of the program</li>
          <li>All objects declared static have this storage duration.</li>
        </ul>
      </li>
      <li><strong>automatic</strong>
        <ul>
          <li>The storage is allocated when the block in which the object was declared is entered and deallocated when it is exited by any means (goto, return, reaching the end).</li>
          <li>All function parameters and non-static block-scope objects have this storage duration, as well as compound literals used at block scope.</li>
        </ul>
      </li>
      <li><strong>thread</strong>
        <ul>
          <li>The storage duration is the entire execution of the thread in which it was created</li>
        </ul>
      </li>
      <li><strong>allocated</strong>
        <ul>
          <li>The storage is allocated and deallocated on request, using <strong>dynamic memory allocation</strong> functions</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="int">Int</h1>

<ul>
  <li>don’t convert <code class="language-plaintext highlighter-rouge">int</code> to <code class="language-plaintext highlighter-rouge">float</code>
    <ul>
      <li>when an integer type is converted to a floating-point type, the resulting floating-point value might not exactly match the integer value (e.g. <code class="language-plaintext highlighter-rouge">2.999995</code> instead of <code class="language-plaintext highlighter-rouge">3</code>)</li>
      <li>keep integer values in type <code class="language-plaintext highlighter-rouge">short</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, or variables <code class="language-plaintext highlighter-rouge">long long</code></li>
    </ul>
  </li>
</ul>

<h2 id="low-order-byte-and-high-order-byte">Low-order byte and High-order byte</h2>

<ul>
  <li>In C, the size of an <code class="language-plaintext highlighter-rouge">int</code> is implementation defined, but is usually 2, or 4 bytes in size. The <strong>high-order byte</strong> would be the byte that contains the largest portion of the value. The <strong>low-order byte</strong> would be the byte that contains the smallest portion of the value.
    <ul>
      <li>For example, if you have a 16-bit <code class="language-plaintext highlighter-rouge">int</code>, and the value is 5,243, you’d write that in hex as 0x147B. The high order byte is the 0x14 (1 byte = 8 bit, sodass 256 Werte möglich sind, was in hex <strong>2 Ziffern</strong> sind! Daher die 14 und nicht nur die 1 hinter dem 0x.), and the low-order byte is the 0x7B. A <code class="language-plaintext highlighter-rouge">char</code> is only 1 byte, so it is always contained within the lowest order byte. When written in hex (in left-to-right fashion) the low-order byte will always be the right-most 2 digits, and the high-order byte will be the left-most 2 digits (assuming they write all the bytes out, including leading 0s). (<a href="https://stackoverflow.com/questions/47117509/high-order-and-low-order-byte">stackoverflow</a>)</li>
    </ul>
  </li>
</ul>

<h1 id="arrays">Arrays</h1>

<h2 id="definition">Definition</h2>

<ul>
  <li><strong>array</strong>: a collection of data storage locations, each storing the same type of data and having the same name</li>
  <li><strong>array elements</strong>: the storage locations of an array</li>
</ul>

<h2 id="declaration">Declaration</h2>

<ul>
  <li>When you declare an array, the compiler <strong>sets aside a block of memory large enough to hold the entire array</strong>.</li>
  <li>Individual array elements are stored in <strong>sequential memory locations</strong>.</li>
</ul>

<h2 id="initialization">Initialization</h2>

<ul>
  <li>You can initialize <strong>all or part of</strong> an array when you first declare it
    <ul>
      <li>ANSI standard: the elements that are not initialized will be set to <strong>zero</strong>.
        <ul>
          <li>however, it is best to make sure you know what a value is initialized to by setting it yourself.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>If you omit the array size, the compiler creates an array just large enough</li>
  <li>If you include too many initializers, the compiler detects an error.
    <ul>
      <li><strong>Note</strong>: This is different from using subscripts which are out of bounds which will <strong>not</strong> be detected by the compiler!</li>
    </ul>
  </li>
</ul>

<h2 id="subscripts">Subscripts</h2>

<ul>
  <li>the last element is <strong>one less</strong> than the number of elements in the array.</li>
</ul>

<h2 id="passing-arrays-to-a-function">Passing arrays to a function</h2>

<ul>
  <li><strong>problem 1</strong>: The only way you can pass an array to a function is by using a pointer to an array. (see <a href="#passing-function-arguments">Passing Function arguments</a>)</li>
  <li><strong>problem 2</strong>: function that can handle arrays of different sizes (e.g. a function that finds the largest element in an array of integers)
    <ul>
      <li>How does the function know the size of the array whose address it was passed?
        <ul>
          <li><strong>method 1</strong>: identify the last array element by storing a <strong>special value</strong> there (see <a href="#strings">Strings</a>)</li>
          <li><strong>method 2</strong>: Pass the function the array size as an argument</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="copy-2d-array-and-assign-it-to-another">Copy 2d array and assign it to another</h2>

<p>From <a href="https://stackoverflow.com/questions/13903388/how-to-assign-values-of-array-to-another-arraymaking-copy-in-c">stackoverflow</a>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="sc">'a'</span><span class="p">,</span><span class="sc">'b'</span><span class="p">,</span><span class="sc">'c'</span><span class="p">},{</span><span class="sc">'d'</span><span class="p">,</span><span class="sc">'e'</span><span class="p">,</span><span class="sc">'f'</span><span class="p">},{</span><span class="sc">'g'</span><span class="p">,</span><span class="sc">'h'</span><span class="p">,</span><span class="sc">'i'</span><span class="p">}</span> <span class="p">};</span>
<span class="kt">char</span> <span class="n">arr_copy</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>

<span class="n">memcpy</span><span class="p">(</span><span class="n">arr_copy</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">arr_copy</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="out-of-bounds-error">Out of bounds error</h2>

<ul>
  <li>The C compiler doesn’t recognize whether your program uses an array subscript that is out of bounds.</li>
  <li>Your program compiles and links, but out-of-range subscripts generally produce erroneous results
    <ul>
      <li>from <a href="https://stackoverflow.com/questions/9137157/no-out-of-bounds-error">source</a>:
        <ul>
          <li>though, <code class="language-plaintext highlighter-rouge">clang</code> will do it for some cases if you pass <code class="language-plaintext highlighter-rouge">-fcatch-undefined-behavior</code></li>
          <li>The <code class="language-plaintext highlighter-rouge">gcc</code> equivalent is <code class="language-plaintext highlighter-rouge">-fsanitize=undefined</code>. The <code class="language-plaintext highlighter-rouge">-ggdb</code> flag also helps; it causes compilation with extra debugging info, which can be the difference between having/not having line numbers pointing to the error in the code in <code class="language-plaintext highlighter-rouge">fsanitizer</code> output.</li>
          <li>but this does not mean it is part of the C Standard!</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="best-practice-1">Best practice</h2>

<ul>
  <li>use <code class="language-plaintext highlighter-rouge">#define</code> statements to create constants that can be used when declaring arrays. Then you can easily change the number of elements in the array.</li>
  <li>do <strong>not</strong> use multidimensional arrays with <strong>more than three</strong> dimensions</li>
</ul>

<h1 id="program-inputoutput-devices">Program Input/Output, Devices</h1>

<ul>
  <li>input
    <ul>
      <li>Data moved from an external location into RAM, where the program can access it</li>
    </ul>
  </li>
  <li>output
    <ul>
      <li>Data sent to a location external to the program (common destinations: screen, printer, disk files)</li>
    </ul>
  </li>
  <li>devices
    <ul>
      <li>collective term for input sources and output destinations</li>
    </ul>
  </li>
</ul>

<h1 id="streams">Streams</h1>

<ul>
  <li>C carries out all input and output operations by means of streams</li>
  <li><strong>stream</strong>: a sequence of bytes of data (e.g. a sequence of characters)
    <ul>
      <li><strong>input stream</strong>: sequence of bytes flowing into a program</li>
      <li><strong>output stream</strong>: sequence of bytes flowing out of a program</li>
    </ul>
  </li>
  <li><strong>advantage</strong>: streams make input/output programming <strong>device independent</strong></li>
  <li><strong>file</strong>: every C stream is connected to a <strong>file</strong>, which is an intermediate step between the stream that your program deals with and the actual physical device being used for input or output
    <ul>
      <li>the details of interactions between streams, files, and devices are taken care of automatically by the C library functions and the operating system</li>
    </ul>
  </li>
  <li><strong>2 modes of C streams</strong>
    <ul>
      <li><strong>text stream</strong>: consists only of characters (e.g. text data)</li>
      <li><strong>binary stream</strong>: consists of any sort of data</li>
    </ul>
  </li>
</ul>

<h2 id="five-standard-streams">Five Standard Streams</h2>

<p>(the first 3 are C ANSI standard, the last 2 are only under Windows and DOS)</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Format Specifier</th>
      <th style="text-align: center">Type</th>
      <th style="text-align: center">Device</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">stdin</td>
      <td style="text-align: center">Standard input</td>
      <td style="text-align: center">Keyboard</td>
    </tr>
    <tr>
      <td style="text-align: center">stdout</td>
      <td style="text-align: center">Standard output</td>
      <td style="text-align: center">Screen</td>
    </tr>
    <tr>
      <td style="text-align: center">stderr</td>
      <td style="text-align: center">Standard error</td>
      <td style="text-align: center">Screen</td>
    </tr>
    <tr>
      <td style="text-align: center">stdprn*</td>
      <td style="text-align: center">Standard printer</td>
      <td style="text-align: center">Printer (LPT1:)</td>
    </tr>
    <tr>
      <td style="text-align: center">stdaux*</td>
      <td style="text-align: center">Standard auxiliary</td>
      <td style="text-align: center">Serial port (COM1:)</td>
    </tr>
  </tbody>
</table>

<h1 id="stream-functions">Stream Functions</h1>

<ul>
  <li>functions that deal with stream input and output</li>
</ul>

<h2 id="input-functions">Input Functions</h2>

<ul>
  <li>hierarchy of 3 levels
    <ul>
      <li>character input (<code class="language-plaintext highlighter-rouge">getchar</code>, <code class="language-plaintext highlighter-rouge">getch</code>, <code class="language-plaintext highlighter-rouge">getche</code>, <code class="language-plaintext highlighter-rouge">getc</code>, <code class="language-plaintext highlighter-rouge">fgetc</code>, <code class="language-plaintext highlighter-rouge">ungetc</code>)</li>
      <li>line input (<code class="language-plaintext highlighter-rouge">gets</code>, <code class="language-plaintext highlighter-rouge">fgets</code>)</li>
      <li>formatted input (<code class="language-plaintext highlighter-rouge">scanf</code>, <code class="language-plaintext highlighter-rouge">fflush</code>)</li>
    </ul>
  </li>
</ul>

<h2 id="output-functions">Output Functions</h2>

<ul>
  <li>3 categories
    <ul>
      <li>character output (<code class="language-plaintext highlighter-rouge">putchar</code>, <code class="language-plaintext highlighter-rouge">putc</code>, <code class="language-plaintext highlighter-rouge">fputc</code>)</li>
      <li>line output (<code class="language-plaintext highlighter-rouge">puts</code>, <code class="language-plaintext highlighter-rouge">fputs</code>)</li>
      <li>formatted output (<code class="language-plaintext highlighter-rouge">printf</code>, <code class="language-plaintext highlighter-rouge">fprintf</code>)</li>
    </ul>
  </li>
</ul>

<h1 id="printf">printf</h1>

<h2 id="escape-sequences">Escape sequences</h2>

<ul>
  <li>see <a href="https://en.wikipedia.org/wiki/Escape_sequences_in_C#Table_of_escape_sequences">Table of escape sequences</a></li>
</ul>

<h2 id="format-specifiers">Format specifiers</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Format Specifier</th>
      <th style="text-align: center">Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%c</code></td>
      <td style="text-align: center">Character</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%d</code></td>
      <td style="text-align: center">Signed integer</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%e</code> or <code class="language-plaintext highlighter-rouge">%E</code></td>
      <td style="text-align: center">Scientific notation of floats</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%f</code></td>
      <td style="text-align: center">Float values</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%g</code> or <code class="language-plaintext highlighter-rouge">%G</code></td>
      <td style="text-align: center">Similar as <code class="language-plaintext highlighter-rouge">%e</code> or <code class="language-plaintext highlighter-rouge">%E</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%hi</code></td>
      <td style="text-align: center">Signed integer (short)</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%hu</code></td>
      <td style="text-align: center">Unsigned Integer (short)</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%i</code></td>
      <td style="text-align: center">Unsigned integer</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%l</code> or <code class="language-plaintext highlighter-rouge">%ld</code> or <code class="language-plaintext highlighter-rouge">%li</code></td>
      <td style="text-align: center">Long</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%lf</code></td>
      <td style="text-align: center">Double</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%Lf</code></td>
      <td style="text-align: center">Long double</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%lu</code></td>
      <td style="text-align: center">Unsigned int or unsigned long</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%lli</code> or <code class="language-plaintext highlighter-rouge">%lld</code></td>
      <td style="text-align: center">Long long</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%llu</code></td>
      <td style="text-align: center">Unsigned long long</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%o</code></td>
      <td style="text-align: center">Octal representation</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%p</code></td>
      <td style="text-align: center">Pointer</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%s</code></td>
      <td style="text-align: center">String</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%u</code></td>
      <td style="text-align: center">Unsigned int</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%x</code> or <code class="language-plaintext highlighter-rouge">%X</code></td>
      <td style="text-align: center">Hexadecimal representation</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%n</code></td>
      <td style="text-align: center">Prints nothing</td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">%%</code></td>
      <td style="text-align: center">Prints <code class="language-plaintext highlighter-rouge">%</code> character</td>
    </tr>
  </tbody>
</table>

<p>These are the basic format specifiers. We can add some other parts with the format specifiers. These are like below</p>
<ul>
  <li>A minus symbol (-) sign tells left alignment</li>
  <li>A number after <code class="language-plaintext highlighter-rouge">%</code> specifies the minimum field width. If string is less than the width, it will be filled with spaces</li>
  <li>A period (.) is used to separate field width and precision</li>
</ul>

<h1 id="scanf-gets-fgets">scanf, gets, fgets</h1>

<p>Read all characters up to the next newline character (<code class="language-plaintext highlighter-rouge">'\n'</code>, must use <strong>single</strong> quotes else it is a string literal).</p>

<h2 id="control-characters">Control Characters</h2>

<ul>
  <li><strong>EOF</strong>: If you’re typing at the terminal and you want to provoke an end-of-file, use CTRL-D (unix-style systems) or CTRL-Z (Windows).</li>
</ul>

<h2 id="scanf">scanf</h2>

<ul>
  <li>limitations:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">scanf()</code> cannot take strings with <strong>spaces</strong> in between characters as input, <code class="language-plaintext highlighter-rouge">gets()</code> and <code class="language-plaintext highlighter-rouge">fgets()</code> can</li>
    </ul>
  </li>
</ul>

<h2 id="gets">gets</h2>

<ul>
  <li>prototype: <code class="language-plaintext highlighter-rouge">char *gets(char *str);</code></li>
  <li>input stream is read from <code class="language-plaintext highlighter-rouge">stdin</code> until
    <ul>
      <li>a newline (<code class="language-plaintext highlighter-rouge">'\n'</code>) or</li>
      <li>end-of-<strong>file</strong> (see <a href="#control-characters">Control Characters</a>) is encountered</li>
    </ul>
  </li>
  <li>the newline (<code class="language-plaintext highlighter-rouge">'\n'</code>) is <strong>replaced</strong> with a null character (<code class="language-plaintext highlighter-rouge">'\0'</code>)</li>
  <li>return value:
    <ul>
      <li>a pointer to the string (the same as <code class="language-plaintext highlighter-rouge">str</code>)</li>
      <li>if <code class="language-plaintext highlighter-rouge">gets()</code> encounters an error or reads end-of-file: a null pointer</li>
    </ul>
  </li>
  <li>the string is stored at the location indicated by <code class="language-plaintext highlighter-rouge">str</code></li>
  <li><strong>important</strong>: allocate sufficient memory space to store the string before calling <code class="language-plaintext highlighter-rouge">gets()</code></li>
</ul>

<h2 id="fgets">fgets</h2>

<ul>
  <li>prototype: <code class="language-plaintext highlighter-rouge">char *fgets(char *str, int n, FILE *fp);</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">FILE *fp</code> is used to specify the input stream (e.g. <code class="language-plaintext highlighter-rouge">stdin</code>)</li>
      <li><code class="language-plaintext highlighter-rouge">str</code> indicates where the input string is stored</li>
      <li><code class="language-plaintext highlighter-rouge">n</code> specifies the maximum number of characters to be input</li>
    </ul>
  </li>
  <li>input stream is read until
    <ul>
      <li>a newline (<code class="language-plaintext highlighter-rouge">'\n'</code>) or</li>
      <li>end-of-line is encountered or</li>
      <li><code class="language-plaintext highlighter-rouge">n - 1</code> characters have been read</li>
    </ul>
  </li>
  <li>the newline (<code class="language-plaintext highlighter-rouge">'\n'</code>) is <strong>included</strong> in the string (different from <code class="language-plaintext highlighter-rouge">gets()</code>!) and a <code class="language-plaintext highlighter-rouge">'\0'</code> is appended before it is stored (i.e. strings are stored with trailing <code class="language-plaintext highlighter-rouge">'\n\0'</code>)</li>
  <li>the return values are the same as for <code class="language-plaintext highlighter-rouge">gets()</code></li>
  <li>the string is stored at the location indicated by <code class="language-plaintext highlighter-rouge">str</code></li>
</ul>

<h1 id="char">Char</h1>

<ul>
  <li>use <strong>single quotations</strong> when initializing a variable</li>
  <li>char constants:
    <ul>
      <li>literal:
        <ul>
          <li>enclose a single character in <strong>single quotation marks</strong>
            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">code</span> <span class="o">=</span> <span class="sc">'x'</span><span class="p">;</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>symbolic:
        <ul>
          <li>using <code class="language-plaintext highlighter-rouge">#define</code>
            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define EX 'x'
</span><span class="kt">char</span> <span class="n">code</span> <span class="o">=</span> <span class="n">EX</span><span class="p">;</span> <span class="cm">/* Sets code equal to 'x' */</span>
</code></pre></div>            </div>
          </li>
          <li>using <code class="language-plaintext highlighter-rouge">const</code>
            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span> <span class="n">A</span> <span class="o">=</span> <span class="sc">'Z'</span><span class="p">;</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>When you store the character <code class="language-plaintext highlighter-rouge">a</code> in a type <code class="language-plaintext highlighter-rouge">char</code> variable, the compiler is really storing the ASCII value <code class="language-plaintext highlighter-rouge">97</code></li>
  <li>if you want to print the extended ASCII (aka CP437) characters, you must use an <code class="language-plaintext highlighter-rouge">unsigned char</code>
    <ul>
      <li>not good practice, use UTF-8 instead (see <a href="https://en.wikipedia.org/wiki/Code_page_437#Character_set">mapping from extended ASCII to UTF-8</a>)</li>
    </ul>
  </li>
</ul>

<h1 id="strings">Strings</h1>

<h2 id="definitions">Definitions</h2>

<ul>
  <li>a string is a sequence of characters delineated by
    <ul>
      <li>a pointer that points to the string’s first character and</li>
      <li>a null character <code class="language-plaintext highlighter-rouge">\0</code> that indicates the end of the string (“null-terminated” string)</li>
    </ul>
  </li>
  <li>From <a href="https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf">C18 6.4.5</a>:
    <ul>
      <li>A <strong>character string literal</strong> is a sequence of zero or more multibyte characters enclosed in double-quotes, as in <code class="language-plaintext highlighter-rouge">"xyz"</code>.</li>
      <li>A <strong>UTF–8 string literal</strong> is the same, except prefixed by <code class="language-plaintext highlighter-rouge">u8</code>.</li>
      <li>A <strong>wide string literal</strong> is the same, except prefixed by the letter <code class="language-plaintext highlighter-rouge">L</code>,<code class="language-plaintext highlighter-rouge">u</code>, or <code class="language-plaintext highlighter-rouge">U</code>.</li>
    </ul>
  </li>
</ul>

<h2 id="string-literals">String Literals</h2>

<p>String Literals sind “besondere” <code class="language-plaintext highlighter-rouge">char</code> arrays, die im read-only memory sein <strong>können</strong>, aber nicht müssen (abhängig von C implementation). Nach ISO C dürfen sie nicht modifiziert werden!</p>

<p>From <a href="https://en.cppreference.com/w/c/language/string_literal">cppreference</a>:</p>
<ul>
  <li><strong>character string literal</strong>: The type of the literal is <code class="language-plaintext highlighter-rouge">char[N]</code>, where <code class="language-plaintext highlighter-rouge">N</code> is the size of the string in code units of the execution narrow encoding, including the null terminator.</li>
  <li>A string literal is not necessarily a string; if a string literal has embedded null characters, it represents an array which contains more than one string:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="s">"abc</span><span class="se">\0</span><span class="s">def"</span><span class="p">;</span> <span class="c1">// strlen(p) == 3, but the array has size 8</span>
</code></pre></div>    </div>
  </li>
  <li>String literals are <strong>not modifiable</strong> (and in fact may be placed in read-only memory such as <code class="language-plaintext highlighter-rouge">.rodata</code>). If a program attempts to modify the static array formed by a string literal, the behavior is undefined.
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
<span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'M'</span><span class="p">;</span> <span class="c1">// Undefined behavior</span>
<span class="kt">char</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'M'</span><span class="p">;</span> <span class="c1">// OK: a is not a string literal</span>
</code></pre></div>    </div>
    <p><strong>phth note</strong>: The latter variant is treated as</p>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">'H'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'o'</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">};</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'M'</span><span class="p">;</span> <span class="c1">// OK: a is not a string literal</span>
</code></pre></div>    </div>
    <p>thus, <code class="language-plaintext highlighter-rouge">char a[] = "Hello";</code> <strong>copies</strong> each <code class="language-plaintext highlighter-rouge">char</code> byte of the string literal <code class="language-plaintext highlighter-rouge">"Hello"</code> into the <strong>newly created</strong> memory block of the array <code class="language-plaintext highlighter-rouge">a</code>, but the memory block storing <code class="language-plaintext highlighter-rouge">"Hello"</code>is <strong>not</strong> modified! <code class="language-plaintext highlighter-rouge">a</code> is a standard array, thus, like all standard arrays, it is modifiable. <code class="language-plaintext highlighter-rouge">a</code> points to <strong>the array’s</strong> first element <code class="language-plaintext highlighter-rouge">'H'</code> and <strong>not</strong> to the string literal <code class="language-plaintext highlighter-rouge">"Hello"</code>’s first element!</p>
    <ul>
      <li>from <a href="https://en.cppreference.com/w/c/language/array_initialization">cppreference</a>:
        <ul>
          <li>Successive bytes of the string literal (…), including the terminating null byte/character, initialize the elements of the array</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Notes:</p>
<ul>
  <li>phth: <code class="language-plaintext highlighter-rouge">.rodata</code> is the “<a href="https://en.wikipedia.org/wiki/Data_segment">read-only data segment</a>”, a portion of an object file or the corresponding address space of a program that contains static constants.</li>
  <li>phth: “may be placed in read-only memory” means they do not have to!</li>
</ul>

<p>From the <a href="http://port70.net/~nsz/c/c89/rationale/c1.html#3-1-4">C89 Rationale, 3.1.4 String literals</a>:</p>
<ul>
  <li>String literals are specified to be <strong>unmodifiable</strong>.</li>
  <li>This specification allows implementations (phth: z.B. <code class="language-plaintext highlighter-rouge">gcc</code>, <code class="language-plaintext highlighter-rouge">clang</code>, etc)
    <ul>
      <li>to share copies of strings with identical text,</li>
      <li>to place string literals <strong>in read-only memory</strong>, and
        <ul>
          <li>d.h. ob string literals in read-only memory sind oder nicht ist abhängig von der implementation</li>
        </ul>
      </li>
      <li>perform certain optimizations.</li>
    </ul>
  </li>
  <li>However, string literals <strong>do not</strong> have the type array of <code class="language-plaintext highlighter-rouge">const char</code>,
    <ul>
      <li>in order to avoid the problems of pointer type checking, particularly with library functions, since assigning a pointer-to-<code class="language-plaintext highlighter-rouge">const char</code> to a plain pointer-to-<code class="language-plaintext highlighter-rouge">char</code> is not valid.</li>
    </ul>
  </li>
  <li>Those members of the Committee who insisted that string literals should be modifiable were content to have this practice designated a common extension (see F.5.5).</li>
</ul>

<h3 id="faq---string-literals">FAQ - string literals</h3>

<p>Good example code:</p>
<ul>
  <li>see first two answers in <a href="https://stackoverflow.com/questions/44294649/if-chars-are-read-only-why-can-i-overwrite-them">If char*s are read only, why can I overwrite them?</a>
    <ul>
      <li>explains: <a href="https://stackoverflow.com/questions/3843446/static-c-string-allocation-question">char *str and char str[] are not the same</a></li>
      <li><strong>Warning</strong>: <a href="https://stackoverflow.com/a/62279000">this stackoverflow answer</a> is wrong!
        <ul>
          <li>proof: see below: comment by <a href="https://stackoverflow.com/users/12139179/roberts-supports-monica-cellio">RobertS supports Monica Cellio</a>, 13949 reputation: “‘Short answer: they are basically the same.’ - No, they aren’t. Both methods are completely different.”</li>
        </ul>
      </li>
      <li>the same from a compiler perspective: <a href="https://stackoverflow.com/questions/17337825/why-string-is-not-modifiable-in-new-compilers">Why string is not modifiable in new compilers</a></li>
    </ul>
  </li>
</ul>

<h2 id="create-strings-as-char-arrays">Create Strings as char arrays</h2>

<p>element-by-element:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">string</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">'A'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'m'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'\0'</span> <span class="p">};</span>
</code></pre></div></div>

<p>using string literal:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">string</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Alabama"</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">message</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Great Caesar</span><span class="se">\'</span><span class="s">s Ghost!"</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>use <strong>double quotes</strong></li>
  <li>The array’s name is a type <code class="language-plaintext highlighter-rouge">char</code> pointer to the beginning of the string</li>
  <li>the compiler calculates the size of the array for you, if no subscript is provided
    <ul>
      <li><strong>Note</strong>: The expression within the brackets <code class="language-plaintext highlighter-rouge">[]</code> is referred to as a <strong>subscript</strong></li>
    </ul>
  </li>
  <li>the compiler <strong>automatically</strong> adds the terminating null character at the end of the string</li>
</ul>

<h2 id="create-strings-without-arrays">Create Strings without arrays</h2>

<h3 id="allocate-string-space-at-compilation">Allocate string space at compilation</h3>

<p><strong>static memory allocation</strong>: explicitly allocating memory in the program source code by declaring variables, structures, and arrays</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="s">"Great Caesar</span><span class="se">\'</span><span class="s">s Ghost!"</span><span class="p">;</span>
</code></pre></div></div>
<p><del>i.e. <code class="language-plaintext highlighter-rouge">*message</code> and <code class="language-plaintext highlighter-rouge">message[]</code> are equivalent!</del></p>
<ul>
  <li>wrong: <a href="https://stackoverflow.com/questions/3843446/static-c-string-allocation-question">why they are different</a></li>
</ul>

<p><strong>Note</strong>:</p>
<ul>
  <li>The pointer <code class="language-plaintext highlighter-rouge">*message</code> itself is stored at a different location than the literal string <code class="language-plaintext highlighter-rouge">"Great Caesar\'s Ghost!"</code> (see section <a href="#pointer">Pointer</a>).</li>
  <li>The array’s name is a type <code class="language-plaintext highlighter-rouge">char</code> pointer to the beginning of the string</li>
</ul>

<h3 id="allocate-string-space-at-runtime-malloc">Allocate string space at runtime (malloc)</h3>

<p><strong>dynamic memory allocation</strong>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* allocate memory for a 100-character string */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
    <span class="n">str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span> <span class="s">"Not enough memory to allocate buffer</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">"String was allocated!</span><span class="se">\n</span><span class="s">"</span> <span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Note that <code class="language-plaintext highlighter-rouge">void *malloc()</code> is typecast so that its return value is the proper type - a pointer to a <code class="language-plaintext highlighter-rouge">char</code> variable. Further details about <code class="language-plaintext highlighter-rouge">malloc()</code> are under section <a href="#memory">Memory</a>.</p>

<h1 id="pointer">Pointer</h1>

<ul>
  <li>The address of a variable is actually the address of the first (lowest) byte it occupies</li>
  <li>Each pointer is equal to the address of the first byte of the pointed-to variable</li>
</ul>

<h2 id="size-of-pointers">Size of pointers</h2>

<ul>
  <li>The size of a pointer in C/C++ depends upon different issues like Operating system, CPU architecture etc.</li>
  <li>Usually it depends upon the <strong>word size of underlying processor</strong>, for example
    <ul>
      <li>for a <strong>32 bit computer</strong> the pointer size can be <strong>4 bytes</strong></li>
      <li>for a <strong>64 bit computer</strong> the pointer size can be <strong>8 bytes</strong>.</li>
    </ul>
  </li>
  <li>So, <strong>for a specific architecture</strong> pointer size <strong>will be fixed</strong>.</li>
  <li>It is <strong>common to all data types</strong> like <code class="language-plaintext highlighter-rouge">int *</code>, <code class="language-plaintext highlighter-rouge">float *</code> etc.</li>
</ul>

<h2 id="data-type-of-pointers">Data type of pointers</h2>

<p>From <a href="https://stackoverflow.com/a/26976670">stackoverflow</a>:</p>
<ul>
  <li>But really, what is a type? The gist of it is that a type is a way to determine how data in memory is supposed to be interpreted. A variable of the type <code class="language-plaintext highlighter-rouge">char</code> represents a character. A variable of the type <code class="language-plaintext highlighter-rouge">int</code> represents an integer. Same applies to pointers: <code class="language-plaintext highlighter-rouge">char *x</code> is not of the type <code class="language-plaintext highlighter-rouge">char</code>, it’s of the type <code class="language-plaintext highlighter-rouge">char *</code> (pointer to <code class="language-plaintext highlighter-rouge">char</code>). This means that <code class="language-plaintext highlighter-rouge">char *x</code> itself is a location in memory we can use to read one or more <code class="language-plaintext highlighter-rouge">char</code> values.</li>
  <li>TL;TR: Yes, a pointer is a data type (<code class="language-plaintext highlighter-rouge">void *</code> in its purest form). The pure form is quite unusable (because you can’t dereference it). Instead of having to cast the pointer every time you decide to use it, C offers the convenience of derived pointer types (like <code class="language-plaintext highlighter-rouge">char *</code>, <code class="language-plaintext highlighter-rouge">int *</code> and so on). But really, they’re pointers, and therefore a data-type in their own right.</li>
</ul>

<h2 id="null-pointer">NULL pointer</h2>

<p>Definition:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define NULL ( (void *) 0)
</span></code></pre></div></div>

<p><strong>C11 standard</strong> definition:</p>
<ul>
  <li>An integer constant expression with the value <code class="language-plaintext highlighter-rouge">0</code>, or such an expression cast to type <code class="language-plaintext highlighter-rouge">void *</code>, is called a <strong>null pointer constant</strong>.</li>
  <li>If a null pointer constant is converted to a pointer type, the resulting pointer, called a <strong>null pointer</strong>, is guaranteed to compare unequal to a pointer to any object or function.</li>
</ul>

<h3 id="usage">Usage</h3>

<ol>
  <li>To initialize a pointer variable when that pointer variable hasn’t been assigned any valid memory address yet.
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span> <span class="n">pInt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>To check for a null pointer before accessing any pointer variable. By doing so, we can perform error handling in pointer related code, e.g., dereference a pointer variable only if it’s not <code class="language-plaintext highlighter-rouge">NULL</code>.
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">pInt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="cm">/* We could use if(pInt) as well */</span>
<span class="p">{</span> 
 <span class="cm">/* Some code */</span> 
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span> 
 <span class="cm">/* Some code */</span> 
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>To pass a null pointer to a function argument when we don’t want to pass any valid memory address.
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fun</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
 <span class="cm">/*Fun specific stuff is done with ptr here*/</span>
 <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">fun</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="difference-between-a-void-pointer-and-a-null-pointer">Difference between a void pointer and a NULL pointer?</h3>

<p>From <a href="https://stackoverflow.com/a/4116332">stackoverflow</a>:</p>

<p>In C, there is <code class="language-plaintext highlighter-rouge">void</code>, <code class="language-plaintext highlighter-rouge">void</code> pointer and <code class="language-plaintext highlighter-rouge">NULL</code> pointer.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">void</code> is absence of type. I.E. a function returning a <code class="language-plaintext highlighter-rouge">void</code> type is a function that returns nothing.</li>
  <li><code class="language-plaintext highlighter-rouge">void</code> pointer: is a pointer to a memory location whose type can be anything: a structure, an int, a float, you name it.</li>
  <li>A <code class="language-plaintext highlighter-rouge">NULL</code> pointer is a pointer to location <code class="language-plaintext highlighter-rouge">0x00</code>, that is, no location. Pointing to nothing.</li>
</ul>

<p>Examples:</p>

<p><code class="language-plaintext highlighter-rouge">void</code> function:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printHello</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">void</code> pointer:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">si</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// malloc is a function that could return a pointer to anything</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">NULL</code> pointer:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="c1">// s pointer points to nowhere (nothing)</span>
</code></pre></div></div>

<h2 id="pointer-arithmetic">Pointer arithmetic</h2>

<p>If you have a pointer <code class="language-plaintext highlighter-rouge">ptr</code> that points to a data object of type <code class="language-plaintext highlighter-rouge">obj</code>,</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ptr</span><span class="o">++</span>
</code></pre></div></div>
<p>has the same effect as</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="address-of-a-pointer--multiple-indirection">Address of a pointer / multiple indirection</h2>

<ul>
  <li><strong>multiple indirection</strong>: You can use the address-of operator to find the address of a pointer, so you can have <strong>pointers to pointers</strong>.
    <ul>
      <li>The most common use involves <strong>arrays of pointers</strong>.
        <ul>
          <li>The most common use of an array of pointers is with <strong>strings</strong>.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="passing-function-arguments">Passing Function arguments</h2>

<p>Using “passing by reference” (coll.) we can overcome two limitations of functions:</p>
<ul>
  <li>Arguments are passed by value, and</li>
  <li>the return statement can return only one value</li>
</ul>

<h1 id="structs">Structs</h1>

<h2 id="3-ways-to-access-a-structure-member">3 ways to access a structure member</h2>

<ul>
  <li>Using the structure name</li>
  <li>Using a pointer to the structure with the indirection operator (<code class="language-plaintext highlighter-rouge">*</code>)</li>
  <li>Using a pointer to the structure with the indirect membership operator (<code class="language-plaintext highlighter-rouge">-&gt;</code>)
    <ul>
      <li>sometimes called “structure pointer operator”</li>
    </ul>
  </li>
</ul>

<p>Therefore, if <code class="language-plaintext highlighter-rouge">p_str</code> is a pointer to the structure <code class="language-plaintext highlighter-rouge">str</code>,</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">str</span><span class="p">.</span><span class="n">memb</span>
<span class="p">(</span><span class="o">*</span><span class="n">p_str</span><span class="p">).</span><span class="n">memb</span>
<span class="n">p_str</span><span class="o">-&gt;</span><span class="n">memb</span>
</code></pre></div></div>
<p>are equivalent.</p>

<h2 id="typedef">typedef</h2>

<p>Whether you use <code class="language-plaintext highlighter-rouge">typedef</code> or a structure tag to declare structures makes little difference</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">coord</span><span class="p">;</span>
</code></pre></div></div>
<p>or using a structure tag</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">coord</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h1 id="type-conversions">Type Conversions</h1>

<h2 id="type-promotion-implicit-conversion-automatic-conversion">Type Promotion (implicit conversion, automatic conversion)</h2>

<p>If the components of an expression have different types, an expression has the same type as its <strong>most comprehensive component</strong>. From least-comprehensive to most-comprehensive, the numerical data types are</p>
<ul>
  <li>char</li>
  <li>short</li>
  <li>int</li>
  <li>long</li>
  <li>long long</li>
  <li>float</li>
  <li>double</li>
  <li>long double</li>
</ul>

<p><strong>Note</strong>: Promotion means that a copy of the variable is created and used in the expression evaluation. The type of the variable is <strong>not</strong> changed!</p>

<p><strong>Promotion by Assignment</strong>: expression on the right side of an assignment statement is always promoted to the type of the data object on the left side of the assignment operator</p>
<ul>
  <li>may cause <strong>demotion</strong>
    <ul>
      <li>e.g. <code class="language-plaintext highlighter-rouge">float</code> to <code class="language-plaintext highlighter-rouge">int</code> (<strong>Caution</strong>: fractional part is lost!)</li>
    </ul>
  </li>
</ul>

<h2 id="cast--typecast-explicit-conversion">Cast / Typecast (explicit conversion)</h2>

<ul>
  <li>e.g. <code class="language-plaintext highlighter-rouge">(float)i</code> when <code class="language-plaintext highlighter-rouge">i</code> is an integer</li>
  <li>can be performed on <strong>arithmetic expressions</strong> and <strong>pointers</strong></li>
  <li>makes an internal <strong>copy</strong> of the variable using the new type (similar to promotion)</li>
  <li>most common use: <code class="language-plaintext highlighter-rouge">f1 = (float)i1/i2;</code> to avoid using the fractional part in an integer division
    <ul>
      <li>casting one of the <code class="language-plaintext highlighter-rouge">int</code> variables is sufficient</li>
    </ul>
  </li>
  <li>casting <strong>pointers</strong>:
    <ul>
      <li>Before you can use a <code class="language-plaintext highlighter-rouge">void</code> pointer, you <strong>must cast</strong> it to the proper type</li>
      <li><strong>don’t</strong> need to cast <strong>any</strong> pointer
        <ul>
          <li>in order to assign a value to it</li>
          <li>to compare it with <code class="language-plaintext highlighter-rouge">NULL</code></li>
        </ul>
      </li>
      <li><strong>must</strong> cast a pointer
        <ul>
          <li>before dereferencing</li>
          <li>before performing pointer arithmetic with it</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="memory">Memory</h1>

<h2 id="areas-of-memory">Areas of memory</h2>

<p>When a program begins the operating system sets up following areas of memory (depending on the requirements of the compiler):</p>
<ul>
  <li>registers,</li>
  <li>code space,</li>
  <li>stack,</li>
  <li>global namespace, and</li>
  <li>free store (heap)</li>
</ul>

<h3 id="registers">Registers</h3>

<ul>
  <li>area of memory built right into the CPU</li>
  <li>important registers:
    <ul>
      <li>instruction pointer
        <ul>
          <li>set of registers responsible for pointing, at any given moment, to the next line of code</li>
        </ul>
      </li>
      <li>stack pointer (see <a href="#stack">section “stack”</a>)</li>
      <li>frame pointer (see <a href="#stack">section “stack”</a>)</li>
    </ul>
  </li>
</ul>

<h3 id="code-space">Code space</h3>

<ul>
  <li>memory set aside to hold the binary form of the instructions you created in your program</li>
</ul>

<h3 id="stack">Stack</h3>

<ul>
  <li>area of memory allocated for your program to hold the data required by each of the functions in your program</li>
  <li>last-in, first-out
    <ul>
      <li>data is <strong>pushed</strong> onto the stack and <strong>popped</strong> off the stack</li>
    </ul>
  </li>
  <li>stack pointer
    <ul>
      <li>analogy: series of cubbyholes
        <ul>
          <li><strong>the top of the stack</strong>: whatever cubby the stack pointer (which is another register) happens to be pointing to</li>
          <li><strong>sequential address</strong>: Each of the cubbies has a sequential address</li>
          <li>one of those sequential addresses is kept in the stack pointer register (i.e. the top of the stack)</li>
          <li>Everything <strong>below that magic address</strong>, known as the top of the stack, is considered to be <strong>on the stack</strong>.</li>
          <li>Everything <strong>above the top of the stack</strong> is considered to be <strong>off the stack and invalid</strong>.</li>
        </ul>
      </li>
      <li>when data is popped off the stack the stack pointer is moved down the stack
        <ul>
          <li>the data above the stack pointer is called <strong>garbage</strong> and is <strong>not reliable</strong> (it might or might not be changed at any time!)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="function-calls-stack-pointer-esp-and-frame-pointer-ebp">Function Calls: Stack Pointer (ESP) and Frame Pointer (EBP)</h4>

<p><a href="https://www.uninformativ.de/blog/postings/2011-04-02/0/POSTING-de.html">source</a></p>

<p>Der Knackpunkt ist das Register <strong>ESP</strong> (SP = <strong>Stack Pointer</strong>). Dieses enthält die Speicheradresse, die auf das letzte Element auf dem Stack zeigt.</p>

<p>(…), aber schöner wäre es, wenn ich mir irgendwo diejenige Speicheradresse merken könnte, die den “Anfang” des Stacks kennzeichnet.</p>

<p>Das ist die Idee des “<strong>Frame Pointers</strong>” oder “Base Pointers”. Dafür wird normalerweise das Register <strong>EBP</strong> (BP = Base Pointer) verwendet. Ich muss mich allerdings selbst darum kümmern. Die gängige Vorgehensweise ist, beim Betritt einer “Funktion”</p>
<ul>
  <li>den alten Wert von EBP auf dem Stack zu speichern und dann</li>
  <li>den aktuellen Wert von ESP nach EBP zu kopieren.</li>
  <li>Danach kann ich ESP “beliebig” verändern und habe dennoch mit EBP immer einen festen Referenzpunkt.</li>
</ul>

<p>Verlasse ich die Funktion wieder, muss ich natürlich aufräumen. Dies erreicht man, indem man</p>
<ul>
  <li>EBP zurück nach ESP kopiert und dann</li>
  <li>den ehemals gespeicherten EBP-Wert vom Stack zurück nach EBP holt.</li>
</ul>

<p>Genaueres weiter unten in <a href="https://www.uninformativ.de/blog/postings/2011-04-02/0/POSTING-de.html">source</a> ab “Richtig interessant wird der Frame Pointer, wenn man Funktionen aufrufen möchte. (…)”.</p>

<p>Other references:</p>
<ul>
  <li><a href="https://stackoverflow.com/questions/21718397/what-are-the-esp-and-the-ebp-registers">What are the ESP and the EBP registers?</a></li>
</ul>

<p>Definitions (from <a href="https://people.cs.rutgers.edu/~pxk/419/notes/frames.html">cs.rutgers.edu</a>):</p>
<ul>
  <li><strong>stack frame</strong>: Each <strong>function</strong> has local memory associated with it to hold incoming parameters, local variables, and (in some cases) temporary variables. This region of memory is called a <strong>stack frame</strong> and is allocated on the process’ stack.</li>
  <li><strong>frame pointer</strong>: A <strong>frame pointer</strong> (the <strong>ebp register</strong> on intel x86 architectures, <strong>rbp</strong> on 64-bit architectures) contains the base address of the function’s frame. The code to access local variables within a function is generated in terms of offsets to the frame pointer.
    <ul>
      <li><strong>Note</strong>: The <strong>stack pointer</strong> (the <strong>esp register</strong> on intel x86 architectures or <strong>rsp</strong> on 64-bit architectures) may change during the execution of a function as values are pushed or popped off the stack (such as pushing parameters in preparation to calling another function). The frame pointer doesn’t change throughout the function.</li>
    </ul>
  </li>
</ul>

<h3 id="global-namespace">Global namespace</h3>

<ul>
  <li>global variables</li>
</ul>

<h3 id="free-store-heap">Free store (Heap)</h3>

<ul>
  <li><strong>in C++</strong>: You allocate memory on the free store in C++ by using the <code class="language-plaintext highlighter-rouge">new</code> keyword.</li>
</ul>

<h2 id="ram-available-for-allocation">RAM available for allocation</h2>

<p>When you run a C program, the program is loaded from disk into the computer’s memory. The memory space the program occupies includes the <strong>program code</strong>, as well as space for all the program’s <strong>static data</strong> - that is, data items that are declared in the source code. <strong>The memory left over is what’s available for allocation.</strong></p>

<h2 id="static-vs-dynamic-memory-allocation">Static vs. Dynamic Memory Allocation</h2>

<p><a href="https://techdifferences.com/difference-between-static-and-dynamic-memory-allocation.html">source</a></p>

<h3 id="static-memory-allocation">Static Memory Allocation</h3>

<ul>
  <li>Static memory allocation is a technique where the computer assigns memory to the program <strong>during its compilation</strong>.</li>
  <li>Memory once assigned <strong>cannot vary in size</strong>, i.e. you can not increase or decrease the allocated memory size.</li>
  <li>Once assigned to the program, the static memory remains throughout the program, i.e. from the moment the program is compiled upto the moment the program completes its execution. After the program executes completely, the memory is deallocated, and it can be allocated to some other entity.</li>
  <li>This technique allocates the memory to the program <strong>from the stack</strong> storage.</li>
  <li>In static memory allocation, the program <strong>executes faster</strong> because the memory is assigned to the program before its execution.
    <ul>
      <li>But it is quite difficult to determine how much memory would be required to run the program, and hence most of the time, memory allocation decisions are to be taken at the run time (see <a href="#dynamic-memory-allocation">Dynamic Memory Allocation</a>).</li>
    </ul>
  </li>
</ul>

<h3 id="dynamic-memory-allocation">Dynamic Memory Allocation</h3>

<ul>
  <li>In dynamic memory allocation, the memory is allocated <strong>at the run time</strong>, i.e. when the programmer executes the program</li>
  <li>this technique assigns the memory <strong>from the heap</strong> storage.</li>
  <li>The memory allocated dynamically can be deallocated at any moment during the program execution.</li>
  <li>Even the memory allocated <strong>can be resized</strong>, i.e. you can increase or decrease the memory size.
    <ul>
      <li>This method is more efficient as it provides the memory space according to the program’s needs.</li>
    </ul>
  </li>
  <li>As the memory is allocated at the run time, this makes an <strong>execution a little slower</strong> when compared to static memory allocation.</li>
  <li>The functions used to allocate and deallocate the memory dynamically are <code class="language-plaintext highlighter-rouge">calloc()</code>, <code class="language-plaintext highlighter-rouge">realloc()</code>, and <code class="language-plaintext highlighter-rouge">free()</code>.</li>
</ul>

<h2 id="allocation-functions">Allocation Functions</h2>

<ul>
  <li>all allocation functions return a type <code class="language-plaintext highlighter-rouge">void</code> pointer
    <ul>
      <li>a type <code class="language-plaintext highlighter-rouge">void</code> pointer must be cast to the appropriate type before being used (see section “Cast”)</li>
    </ul>
  </li>
  <li>When a memory allocation function is called, you <strong>must check its return value</strong> to ensure that the memory was allocated successfully.</li>
  <li>In addition, your programs must be able to <strong>gracefully handle the situation when a memory allocation request fails</strong></li>
</ul>

<h3 id="malloc-stdlibh">malloc (stdlib.h)</h3>

<ul>
  <li>allocates a group of bytes</li>
  <li>prototype: <code class="language-plaintext highlighter-rouge">void *malloc(size_t num);</code></li>
  <li>returns a pointer to the first byte</li>
  <li>returns <code class="language-plaintext highlighter-rouge">NULL</code>
    <ul>
      <li>if the requested storage space couldn’t be allocated or</li>
      <li>if <code class="language-plaintext highlighter-rouge">num == 0</code>.</li>
    </ul>
  </li>
</ul>

<h3 id="calloc-stdlibh">calloc (stdlib.h)</h3>

<ul>
  <li>allocates a group of objects</li>
  <li>prototype: <code class="language-plaintext highlighter-rouge">void *calloc(size_t num, size_t size);</code></li>
  <li>returns a pointer to the first byte</li>
  <li>clears all the allocated memory (set to <code class="language-plaintext highlighter-rouge">0</code>)</li>
  <li>returns <code class="language-plaintext highlighter-rouge">NULL</code>
    <ul>
      <li>if the requested storage space couldn’t be allocated or</li>
      <li>if <code class="language-plaintext highlighter-rouge">num == 0</code>.</li>
      <li>if <code class="language-plaintext highlighter-rouge">size == 0</code>.</li>
    </ul>
  </li>
</ul>

<h3 id="realloc-stdlibh">realloc (stdlib.h)</h3>

<ul>
  <li>changes the size of a block of memory that was previously allocated with or <code class="language-plaintext highlighter-rouge">calloc()</code>, <code class="language-plaintext highlighter-rouge">malloc()</code></li>
  <li>prototype: <code class="language-plaintext highlighter-rouge">void *realloc(void *ptr, size_t size);</code></li>
  <li>expand block:
    <ul>
      <li>if sufficient space exists: expand <strong>old</strong> block, return <code class="language-plaintext highlighter-rouge">ptr</code></li>
      <li>if sufficient space <strong>does not</strong> exist: allocate a <strong>new</strong> block, copy data to <strong>new</strong> block, free <strong>old</strong> block, return a pointer to the new block</li>
    </ul>
  </li>
  <li>if <code class="language-plaintext highlighter-rouge">ptr == NULL</code>: like <code class="language-plaintext highlighter-rouge">malloc()</code></li>
  <li>if <code class="language-plaintext highlighter-rouge">size == 0</code>: <code class="language-plaintext highlighter-rouge">free(ptr)</code></li>
  <li>if memory is insufficient: leave <strong>old</strong> block unchanged</li>
  <li>returns <code class="language-plaintext highlighter-rouge">NULL</code>
    <ul>
      <li>if memory is insufficient (either for expanding the <strong>old</strong> block or for allocating a <strong>new</strong> one)</li>
      <li>if <code class="language-plaintext highlighter-rouge">size == 0</code>.</li>
    </ul>
  </li>
</ul>

<h2 id="deallocation">Deallocation</h2>

<h3 id="free-stdlibh">free (stdlib.h)</h3>

<ul>
  <li>releases the memory pointed to by <code class="language-plaintext highlighter-rouge">ptr</code></li>
  <li>prototype: <code class="language-plaintext highlighter-rouge">void free(void *ptr);</code></li>
  <li>must have been allocated with <code class="language-plaintext highlighter-rouge">malloc()</code>, <code class="language-plaintext highlighter-rouge">calloc()</code>, or <code class="language-plaintext highlighter-rouge">realloc()</code></li>
  <li>If <code class="language-plaintext highlighter-rouge">ptr</code> is <code class="language-plaintext highlighter-rouge">NULL</code>, <code class="language-plaintext highlighter-rouge">free()</code> does nothing</li>
</ul>

<h2 id="manipulation">Manipulation</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">memset()</code></li>
  <li><code class="language-plaintext highlighter-rouge">memcpy()</code></li>
  <li><code class="language-plaintext highlighter-rouge">memmove()</code></li>
</ul>

<h1 id="linked-list">Linked List</h1>

<ul>
  <li>TODO</li>
</ul>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#c" class="page__taxonomy-item p-category" rel="tag">c</a><span class="sep">, </span>
    
      <a href="/tags/#notes" class="page__taxonomy-item p-category" rel="tag">notes</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#notes" class="page__taxonomy-item p-category" rel="tag">Notes</a>
    
    </span>
  </p>


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2022-09-22T00:00:00+02:00">September 22, 2022</time></p>

      </footer>

      <section class="page__share">
  

  <a href="https://twitter.com/intent/tweet?text=C+Notes%20http%3A%2F%2Flocalhost%3A4000%2Fnotes%2Fnotes-c%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fnotes%2Fnotes-c%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fnotes%2Fnotes-c%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/notes/notes-OS/" class="pagination--pager" title="Operating Systems Notes
">Previous</a>
    
    
      <a href="/notes/notes-SE/" class="pagination--pager" title="Software Engineering Notes
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h2 class="page__related-title">You May Also Enjoy</h2>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="/assets/images/mario-question-block.jpeg" alt="">
      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/notes/notes-html/" rel="permalink">HTML Notes
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2022-10-10T00:00:00+02:00">October 10, 2022</time>
      </span>
    

    

    
  </p>


    <p class="archive__item-excerpt" itemprop="description">For learning html.
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="/assets/images/Cpp_logo.png" alt="">
      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/notes/notes-cpp/" rel="permalink">C++ Notes
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2022-10-06T00:00:00+02:00">October 6, 2022</time>
      </span>
    

    

    
  </p>


    <p class="archive__item-excerpt" itemprop="description">For learning C++
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="/assets/images/C_logo.png" alt="">
      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/cheatsheet/cheatsheet-android/" rel="permalink">Android Cheatsheet
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2022-10-04T00:00:00+02:00">October 4, 2022</time>
      </span>
    

    

    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Useful tips for using Android
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="/assets/images/C_logo.png" alt="">
      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/notes/notes-SE/" rel="permalink">Software Engineering Notes
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2022-10-03T00:00:00+02:00">October 3, 2022</time>
      </span>
    

    

    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Software Engineering Basics
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://twitter.com/pharath_one" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/pharath" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="/_pages/404.md" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-instagram" aria-hidden="true"></i> Instagram</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2022 Pharath Palesuvaran. </div>


      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
